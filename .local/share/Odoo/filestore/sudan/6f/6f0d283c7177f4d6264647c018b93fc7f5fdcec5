
/***************************************************
*  Filepath: /mail/static/src/core/web/wysiwyg.js  *
*  Lines: 92                                       *
***************************************************/
odoo.define('@mail/core/web/wysiwyg', ['@web/core/utils/render', '@web_editor/js/wysiwyg/wysiwyg', '@web_editor/js/editor/odoo-editor/src/OdooEditor', '@web/core/utils/patch', '@mail/core/web/mention_list', '@web/core/utils/urls', '@web/core/popover/popover_hook', '@web/core/utils/misc'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { renderToElement } = require("@web/core/utils/render");
const { Wysiwyg } = require("@web_editor/js/wysiwyg/wysiwyg");
const { closestBlock, setCursorEnd } = require("@web_editor/js/editor/odoo-editor/src/OdooEditor");
const { patch } = require("@web/core/utils/patch");
const { MentionList } = require("@mail/core/web/mention_list");
const { url } = require("@web/core/utils/urls");
const { usePopover } = require("@web/core/popover/popover_hook");
const { isEventHandled } = require("@web/core/utils/misc");

patch(Wysiwyg.prototype, {
    setup() {
        super.setup();
        if (this.inDiscuss) {
            this.mentionList = usePopover(MentionList, {
                position: `bottom-start`,
                onClose: () => this.focus(),
            });
            this.triggerMentionList = this.triggerMentionList.bind(this);
        }
    },
    get inDiscuss() {
        return this.props.options.recordInfo?.res_model === "mail.compose.message";
    },
    async startEdition() {
        const res = await super.startEdition(...arguments);
        // Only enable mention list in full chatter mode web editor
        if (this.inDiscuss) {
            this.odooEditor.document.addEventListener("keydown", this.triggerMentionList, true);
            this.odooEditor.document.addEventListener("click", this.triggerMentionList, true);
        }
        return res;
    },
    destroy() {
        super.destroy();
        if (this.inDiscuss && this.odooEditor) {
            this.odooEditor.document.removeEventListener("keydown", this.triggerMentionList, true);
            this.odooEditor.document.removeEventListener("click", this.triggerMentionList, true);
        }
    },
    async triggerMentionList(ev) {
        if (!this.inDiscuss) {
            return;
        }
        // Let event be handled by bubbling handlers and other handlers from Odoo Editor first.
        await new Promise((resolve) => setTimeout(resolve, 0));
        const selection = this.odooEditor.document.getSelection();
        if (
            this.isSelectionInEditable() &&
            selection.isCollapsed &&
            selection.rangeCount &&
            !this.mentionList.isOpen &&
            (ev.key === "@" || ev.key === "#")
        ) {
            this.stepBeforeMention = this.odooEditor._historySteps.length - 2;
            const closest = closestBlock(this.odooEditor.document.getSelection().anchorNode);
            this.mentionList.open(closest, {
                type: ev.key === "@" ? "partner" : "channel",
                onSelect: this.selectMention.bind(this),
            });
        } else if (!isEventHandled(ev, "MentionList.onKeydown")) {
            this.mentionList.close();
        }
    },
    selectMention(ev, option) {
        if (!this.inDiscuss) {
            return;
        }
        this.mentionList.close();
        const mentionBlock = renderToElement("mail.Wysiwyg.mentionLink", {
            option,
            href: `${url("/web")}#model=${option.partner ? "res.partner" : "discuss.channel"}&id=${
                option.partner ? option.partner.id : option.channel.id
            }`,
        });
        const nameNode = document.createTextNode(`${option.partner ? "@" : "#"}${option.label}`);
        const space = document.createTextNode("\u00A0");
        mentionBlock.appendChild(nameNode);
        this.odooEditor.historyRevertUntil(this.stepBeforeMention);
        this.odooEditor.execCommand("insert", mentionBlock);
        this.odooEditor.execCommand("insert", space);
        setCursorEnd(space, false);
        this.odooEditor.historyStep();
    },
});

return __exports;
});
;

/******************************************************
*  Filepath: /web/static/src/legacy/js/core/class.js  *
*  Lines: 164                                         *
******************************************************/
odoo.define('@web/legacy/js/core/class', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
/**
 * Improved John Resig's inheritance, based on:
 *
 * Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 *
 * Adds "include()"
 *
 * Defines The Class object. That object can be used to define and inherit classes using
 * the extend() method.
 *
 * Example::
 *
 *     var Person = Class.extend({
 *      init: function(isDancing){
 *         this.dancing = isDancing;
 *       },
 *       dance: function(){
 *         return this.dancing;
 *       }
 *     });
 *
 * The init() method act as a constructor. This class can be instanced this way::
 *
 *     var person = new Person(true);
 *     person.dance();
 *
 *     The Person class can also be extended again:
 *
 *     var Ninja = Person.extend({
 *       init: function(){
 *         this._super( false );
 *       },
 *       dance: function(){
 *         // Call the inherited version of dance()
 *         return this._super();
 *       },
 *       swingSword: function(){
 *         return true;
 *       }
 *     });
 *
 * When extending a class, each re-defined method can use this._super() to call the previous
 * implementation of that method.
 *
 * @class Class
 */
function OdooClass(){}

var initializing = false;
// eslint-disable-next-line no-undef
var fnTest = /xyz/.test(function(){xyz();}) ? /\b_super\b/ : /.*/;

/**
 * Subclass an existing class
 *
 * @param {Object} prop class-level properties (class attributes and instance methods) to set on the new class
 */
OdooClass.extend = function() {
    var _super = this.prototype;
    // Support mixins arguments
    var args = [...arguments];
    args.unshift({});

    const prop = {};
    args.forEach((arg) => {
        Object.assign(prop, arg);
    });

    // Instantiate a web class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var This = this;
    var prototype = new This();
    initializing = false;

    // Copy the properties over onto the new prototype
    Object.keys(prop).forEach((name) => {
        // Check if we're overwriting an existing function
        prototype[name] = typeof prop[name] == "function" &&
                          fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same
                        // method but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so
                        // we remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
    });

    // The dummy class constructor
    function Class() {
        if(this.constructor !== OdooClass){
            throw new Error("You can only instanciate objects with the 'new' operator");
        }
        // All construction is actually done in the init method
        this._super = null;
        if (!initializing && this.init) {
            var ret = this.init.apply(this, arguments);
            if (ret) { return ret; }
        }
        return this;
    }
    Class.include = function (properties) {
        Object.keys(properties).forEach((name) => {
            if (typeof properties[name] !== 'function'
                    || !fnTest.test(properties[name])) {
                prototype[name] = properties[name];
            } else if (typeof prototype[name] === 'function'
                       && prototype.hasOwnProperty(name)) {
                prototype[name] = (function (name, fn, previous) {
                    return function () {
                        var tmp = this._super;
                        this._super = previous;
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(name, properties[name], prototype[name]);
            } else if (typeof _super[name] === 'function') {
                prototype[name] = (function (name, fn) {
                    return function () {
                        var tmp = this._super;
                        this._super = _super[name];
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(name, properties[name]);
            }
        });
    };

    // Populate our constructed prototype object
    Class.prototype = prototype;

    // Enforce the constructor to be what we expect
    Class.constructor = Class;

    // And make this class extendable
    Class.extend = this.extend;

    return Class;
};

__exports[Symbol.for("default")] = OdooClass;

return __exports;
});
;

/*******************************************************
*  Filepath: /web/static/src/legacy/js/core/dialog.js  *
*  Lines: 468                                          *
*******************************************************/
odoo.define('@web/legacy/js/core/dialog', ['@web/legacy/js/core/dom', '@web/legacy/js/core/widget', '@web/core/l10n/translation', '@web/core/utils/render', '@web/core/utils/functions'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const dom = require("@web/legacy/js/core/dom")[Symbol.for("default")];
const Widget = require("@web/legacy/js/core/widget")[Symbol.for("default")];
const { _t } = require("@web/core/l10n/translation");
const { renderToElement } = require("@web/core/utils/render");
const { uniqueId } = require("@web/core/utils/functions");

/**
 * A useful class to handle dialogs.
 * Attributes:
 *
 * ``$footer``
 *   A jQuery element targeting a dom part where buttons can be added. It
 *   always exists during the lifecycle of the dialog.
 **/
var Dialog = Widget.extend({
    tagName: 'main',
    custom_events: Object.assign({}, Widget.prototype.custom_events, {
        focus_control_button: '_onFocusControlButton',
        close_dialog: '_onCloseDialog',
    }),
    events: Object.assign({}, Widget.prototype.events, {
        'keydown .modal-footer button': '_onFooterButtonKeyDown',
    }),
    /**
     * @param {Widget} parent
     * @param {Object} [options]
     * @param {string} [options.title=Odoo]
     * @param {string} [options.subtitle]
     * @param {string} [options.size=large] - 'extra-large', 'large', 'medium'
     *        or 'small'
     * @param {boolean} [options.fullscreen=false] - whether or not the dialog
     *        should be open in fullscreen mode (the main usecase is mobile)
     * @param {string} [options.dialogClass] - class to add to the modal-body
     * @param {jQuery} [options.$content]
     *        Element which will be the $el, replace the .modal-body and get the
     *        modal-body class
     * @param {Object[]} [options.buttons]
     *        List of button descriptions. Note: if no buttons, a "ok" primary
     *        button is added to allow closing the dialog
     * @param {string} [options.buttons[].text]
     * @param {string} [options.buttons[].classes]
     *        Default to 'btn-primary' if only one button, 'btn-secondary'
     *        otherwise
     * @param {boolean} [options.buttons[].close=false]
     * @param {function} [options.buttons[].click]
     * @param {boolean} [options.buttons[].disabled]
     * @param {boolean} [options.technical=true]
     *        If set to false, the modal will have the standard frontend style
     *        (use this for non-editor frontend features)
     * @param {jQueryElement} [options.$parentNode]
     *        Element in which dialog will be appended, by default it will be
     *        in the body
     * @param {boolean|string} [options.backdrop='static']
     *        The kind of modal backdrop to use (see BS documentation)
     * @param {boolean} [options.renderHeader=true]
     *        Whether or not the dialog should be rendered with header
     * @param {boolean} [options.renderFooter=true]
     *        Whether or not the dialog should be rendered with footer
     * @param {function} [options.onForceClose]
     *        Callback that triggers when the modal is closed by other means than with the buttons
     *        e.g. pressing ESC
     */
    init: function (parent, options) {
        var self = this;
        this._super(parent);
        this._opened = new Promise(function (resolve) {
            self._openedResolver = resolve;
        });
        if (this.on_attach_callback) {
            this._opened = this.opened(this.on_attach_callback);
        }
        options = Object.assign({
            title: _t('Odoo'), subtitle: '',
            size: 'large',
            fullscreen: false,
            dialogClass: '',
            $content: false,
            buttons: [{text: _t("Ok"), close: true}],
            technical: true,
            $parentNode: false || $(document.body.querySelector(".o_dialog_container")),
            backdrop: 'static',
            renderHeader: true,
            renderFooter: true,
            onForceClose: false,
        }, options || {});

        this.$content = options.$content;
        this.title = options.title;
        this.subtitle = options.subtitle;
        this.fullscreen = options.fullscreen;
        this.dialogClass = options.dialogClass;
        this.size = options.size;
        this.buttons = options.buttons;
        this.technical = options.technical;
        this.$parentNode = options.$parentNode;
        this.backdrop = options.backdrop;
        this.renderHeader = options.renderHeader;
        this.renderFooter = options.renderFooter;
        this.onForceClose = options.onForceClose;
    },
    /**
     * Wait for XML dependencies and instantiate the modal structure (except
     * modal-body).
     *
     * @override
     */
    willStart: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            // Render modal once xml dependencies are loaded
            self.$modal = $(renderToElement('web.DialogWidget', {
                fullscreen: self.fullscreen,
                title: self.title,
                subtitle: self.subtitle,
                technical: self.technical,
                renderHeader: self.renderHeader,
                renderFooter: self.renderFooter,
                uniqueId: uniqueId("modal_"),
            }));
            switch (self.size) {
                case 'extra-large':
                    self.$modal.find('.modal-dialog').addClass('modal-xl');
                    break;
                case 'large':
                    self.$modal.find('.modal-dialog').addClass('modal-lg');
                    break;
                case 'small':
                    self.$modal.find('.modal-dialog').addClass('modal-sm');
                    break;
            }
            if (self.renderFooter) {
                self.$footer = self.$modal.find(".modal-footer");
                self.set_buttons(self.buttons);
            }
            self.$modal.on('hidden.bs.modal', self.destroy.bind(self));
        });
    },
    /**
     * @override
     */
    renderElement: function () {
        this._super();
        // Note: ideally, the $el which is created/set here should use the
        // 'main' tag, we cannot enforce this as it would require to re-create
        // the whole element.
        if (this.$content) {
            this.setElement(this.$content);
        }
        this.$el.addClass('modal-body ' + this.dialogClass);
    },
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * @param {Object[]} buttons - @see init
     */
    set_buttons: function (buttons) {
        this._setButtonsTo(this.$footer, buttons);
    },

    set_title: function (title, subtitle) {
        this.title = title || "";
        if (subtitle !== undefined) {
            this.subtitle = subtitle || "";
        }

        var $title = this.$modal.find('.modal-title').first();
        var $subtitle = $title.find('.o_subtitle').detach();
        $title.html(this.title);
        $subtitle.html(this.subtitle).appendTo($title);

        return this;
    },

    opened: function (handler) {
        return (handler)? this._opened.then(handler) : this._opened;
    },

    /**
     * Show a dialog
     *
     * @param {Object} options
     * @param {boolean} options.shouldFocusButtons  if true, put the focus on
     * the first button primary when the dialog opens
     */
    open: function (options) {
        $('.tooltip').remove(); // remove open tooltip if any to prevent them staying when modal is opened

        var self = this;
        this.appendTo($('<div/>')).then(function () {
            if (self.isDestroyed()) {
                return;
            }
            self.$modal.find(".modal-body").replaceWith(self.$el);
            self.$modal.attr('open', true);
            if (self.$parentNode) {
                self.$modal.appendTo(self.$parentNode);
            }
            const modalNode = self.$modal[0];
            const modal = new Modal(modalNode, {
                backdrop: self.backdrop,
                keyboard: false,
            });
            modal.show();
            self._openedResolver();
            if (options && options.shouldFocusButtons) {
                self._onFocusControlButton();
            }
        });

        return self;
    },

    close: function () {
        this.destroy();
    },

    /**
     * Close and destroy the dialog.
     *
     * @param {Object} [options]
     * @param {Object} [options.infos] if provided and `silent` is unset, the
     *   `on_close` handler will pass this information related to closing this
     *   information.
     * @param {boolean} [options.silent=false] if set, do not call the
     *   `on_close` handler.
     */
    destroy: function (options) {
        // Need to trigger before real destroy but if 'closed' handler destroys
        // the widget again, we want to avoid infinite recursion
        if (!this.__closed) {
            this.__closed = true;
            this.trigger('closed', options);
        }

        if (this.isDestroyed()) {
            return;
        }

        // Triggers the onForceClose event if the callback is defined
        if (this.onForceClose) {
            this.onForceClose();
        }
        var isFocusSet = this._focusOnClose();

        this._super();

        $('.tooltip').remove(); //remove open tooltip if any to prevent them staying when modal has disappeared
        if (this.$modal) {
            if (this.on_detach_callback) {
                this.on_detach_callback();
            }
            this.$modal.modal('hide');
            this.$modal.remove();
        }

        const modals = $('.modal[role="dialog"]').filter(':visible').filter(this._isBlocking);
        if (modals.length) {
            if (!isFocusSet) {
                modals.last().focus();
            }
            // Keep class modal-open (deleted by bootstrap hide fnct) on body to allow scrolling inside the modal
            $('body').addClass('modal-open');
        }
    },
    /**
     * adds the keydown behavior to the dialogs after external files modifies
     * its DOM.
     */
    rebindButtonBehavior: function () {
        this.$footer.on('keydown', this._onFooterButtonKeyDown);
    },
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Manages the focus when the dialog closes. The default behavior is to set the focus on the top-most opened popup.
     * The goal of this function is to be overridden by all children of the dialog class.
     *
     * @returns: boolean  should return true if the focus has already been set else false.
     */
    _focusOnClose: function() {
        return false;
    },
    /**
     * Render and set the given buttons into a target element
     *
     * @private
     * @param {jQueryElement} $target The destination of the rendered buttons
     * @param {Array} buttons The array of buttons to render
     */
    _setButtonsTo($target, buttons) {
        var self = this;
        $target.empty();
        buttons.forEach((buttonData) => {
            var $button = dom.renderButton({
                attrs: {
                    class: buttonData.classes || (buttons.length > 1 ? 'btn-secondary' : 'btn-primary'),
                    disabled: buttonData.disabled,
                    'data-hotkey': buttonData.hotkey,
                },
                icon: buttonData.icon,
                text: buttonData.text,
            });
            $button.on('click', function (e) {
                var def;
                if (buttonData.click) {
                    def = buttonData.click.call(self, e);
                }
                if (buttonData.close) {
                    self.onForceClose = false;
                    Promise.resolve(def).then(self.close.bind(self));
                }
            });
            if (self.technical) {
                $target.append($button);
            } else {
                $target.prepend($button);
            }
        });
    },
    /**
     * Returns false for non-"blocking" dialogs.
     * This is intended to be overridden by subclasses.
     *
     * @private
     * @param {int} index
     * @param {element} el The element of a dialog.
     * @returns {boolean}
     */
    _isBlocking(index, el) {
        return true;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    /**
     * @private
     */
    _onCloseDialog: function (ev) {
        ev.stopPropagation();
        this.close();
    },
    /**
     * Moves the focus to the first button primary in the footer of the dialog
     *
     * @private
     * @param {odooEvent} e
     */
    _onFocusControlButton: function (e) {
        if (this.$footer) {
            if (e) {
                e.stopPropagation();
            }
            this.$footer.find('.btn-primary:visible:first()').focus();
        }
    },
    /**
     * Manages the TAB key on the buttons. If you the focus is on a primary
     * button and the users tries to tab to go to the next button, display
     * a tooltip
     *
     * @param {jQueryEvent} e
     * @private
     */
    _onFooterButtonKeyDown: function (e) {
        switch(e.key) {
            case "Tab":
                if (!e.shiftKey && e.target.classList.contains("btn-primary")) {
                    e.preventDefault();
                    var $primaryButton = $(e.target);
                    $primaryButton.tooltip({
                        delay: {show: 200, hide:0},
                        title: function(){
                            return renderToElement('FormButton.tooltip',{title:$primaryButton.text().toUpperCase()});
                        },
                        trigger: 'manual',
                    });
                    $primaryButton.tooltip('show');
                }
                break;
        }
    }
});

// static method to open simple alert dialog
Dialog.alert = function (owner, message, options) {
    var buttons = [{
        text: _t("Ok"),
        close: true,
        click: options && options.confirm_callback,
    }];
    return new Dialog(owner, Object.assign({
        size: 'medium',
        buttons: buttons,
        $content: $('<main/>', {
            role: 'alert',
            text: message,
        }),
        title: _t("Alert"),
        onForceClose: options && (options.onForceClose || options.confirm_callback),
    }, options)).open({shouldFocusButtons:true});
};

// static method to open simple confirm dialog
Dialog.confirm = function (owner, message, options) {
    /**
     * Creates an improved callback from the given callback value at the given
     * key from the parent function's options parameter. This is improved to:
     *
     * - Prevent calling given callbacks once one has been called.
     *
     * - Re-allow calling callbacks once a previous callback call's returned
     *   Promise is rejected.
     */
    let isBlocked = false;
    function makeCallback(key) {
        const callback = options && options[key];
        return function () {
            if (isBlocked) {
                // Do not (re)call any callback and return a rejected Promise
                // to prevent closing the Dialog.
                return Promise.reject();
            }
            isBlocked = true;
            const callbackRes = callback && callback.apply(this, arguments);
            Promise.resolve(callbackRes).catch((e) => {
                isBlocked = false;
                return Promise.reject(e);
            });
            return callbackRes;
        };
    }
    var buttons = [
        {
            text: _t("Ok"),
            classes: 'btn-primary',
            close: true,
            click: makeCallback('confirm_callback'),
        },
        {
            text: _t("Cancel"),
            close: true,
            click: makeCallback('cancel_callback'),
        }
    ];
    return new Dialog(owner, Object.assign({
        size: 'medium',
        buttons: buttons,
        $content: $('<main/>', {
            role: 'alert',
            text: message,
        }),
        title: _t("Confirmation"),
        onForceClose: options && (options.onForceClose || options.cancel_callback),
    }, options)).open({shouldFocusButtons:true});
};

__exports[Symbol.for("default")] = Dialog;

return __exports;
});
;

/************************************************************
*  Filepath: /web/static/src/legacy/js/core/minimal_dom.js  *
*  Lines: 145                                               *
************************************************************/
odoo.define('@web/legacy/js/core/minimal_dom', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const DEBOUNCE = __exports.DEBOUNCE = 400;
const BUTTON_HANDLER_SELECTOR = __exports.BUTTON_HANDLER_SELECTOR = 'a, button, input[type="submit"], input[type="button"], .btn';

/**
 * Protects a function which is to be used as a handler by preventing its
 * execution for the duration of a previous call to it (including async
 * parts of that call).
 *
 * Limitation: as the handler is ignored during async actions,
 * the 'preventDefault' or 'stopPropagation' calls it may want to do
 * will be ignored too. Using the 'preventDefault' and 'stopPropagation'
 * arguments solves that problem.
 *
 * @param {function} fct
 *      The function which is to be used as a handler. If a promise
 *      is returned, it is used to determine when the handler's action is
 *      finished. Otherwise, the return is used as jQuery uses it.
 * @param {function|boolean} preventDefault
 * @param {function|boolean} stopPropagation
 */
__exports.makeAsyncHandler = makeAsyncHandler; function makeAsyncHandler(fct, preventDefault, stopPropagation) {
    // TODO in master, add those as arguments.
    const stopImmediatePropagation = this && this.__makeAsyncHandler_stopImmediatePropagation;

    let pending = false;
    function _isLocked() {
        return pending;
    }
    function _lock() {
        pending = true;
    }
    function _unlock() {
        pending = false;
    }
    return function (ev) {
        if (preventDefault === true || preventDefault && preventDefault()) {
            ev.preventDefault();
        }
        if (stopPropagation === true || stopPropagation && stopPropagation()) {
            ev.stopPropagation();
        }
        if (stopImmediatePropagation === true || stopImmediatePropagation && stopImmediatePropagation()) {
            ev.stopImmediatePropagation();
        }

        if (_isLocked()) {
            // If a previous call to this handler is still pending, ignore
            // the new call.
            return;
        }

        _lock();
        const result = fct.apply(this, arguments);
        Promise.resolve(result).then(_unlock, _unlock);
        return result;
    };
}

/**
 * Creates a debounced version of a function to be used as a button click
 * handler. Also improves the handler to disable the button for the time of
 * the debounce and/or the time of the async actions it performs.
 *
 * Limitation: if two handlers are put on the same button, the button will
 * become enabled again once any handler's action finishes (multiple click
 * handlers should however not be bound to the same button).
 *
 * @param {function} fct
 *      The function which is to be used as a button click handler. If a
 *      promise is returned, it is used to determine when the button can be
 *      re-enabled. Otherwise, the return is used as jQuery uses it.
 */
__exports.makeButtonHandler = makeButtonHandler; function makeButtonHandler(fct) {
    // TODO in master, add those as arguments. Even though buttons are probably
    // blocked by the o_website_btn_loading and related classes, it is not
    // necessarily true for all event types.
    const preventDefault = this && this.__makeButtonHandler_preventDefault;
    const stopPropagation = this && this.__makeButtonHandler_stopPropagation;
    const stopImmediatePropagation = this && this.__makeButtonHandler_stopImmediatePropagation;

    // Fallback: if the final handler is not bound to a button, at least
    // make it an async handler (also handles the case where some events
    // might ignore the disabled state of the button).
    fct = makeAsyncHandler.call({
        '__makeAsyncHandler_stopImmediatePropagation': stopImmediatePropagation,
    }, fct, preventDefault, stopPropagation);

    return function (ev) {
        const result = fct.apply(this, arguments);

        const buttonEl = ev.target && ev.target.closest && ev.target.closest(BUTTON_HANDLER_SELECTOR);
        if (!(buttonEl instanceof HTMLElement)) {
            return result;
        }

        // Disable the button for the duration of the handler's action
        // or at least for the duration of the click debounce. This makes
        // a 'real' debounce creation useless. Also, during the debouncing
        // part, the button is disabled without any visual effect.
        buttonEl.classList.add('pe-none');
        Promise.resolve(DEBOUNCE && new Promise(r => setTimeout(r, DEBOUNCE)))
            .then(function () {
                buttonEl.classList.remove('pe-none');
                const restore = addButtonLoadingEffect(buttonEl);
                return Promise.resolve(result).then(restore, restore);
            });

        return result;
    };
}

/**
 * Gives the button a loading effect by disabling it and adding a `fa`
 * spinner icon.
 * The existing button `fa` icons will be hidden through css.
 *
 * @param {HTMLElement} btnEl - the button to disable/load
 * @return {function} a callback function that will restore the button
 *         initial state
 */
__exports.addButtonLoadingEffect = addButtonLoadingEffect; function addButtonLoadingEffect(btnEl) {
    if (!(btnEl instanceof HTMLElement)) {
        return () => {};
    }
    // Note that pe-none is used alongside "disabled" so that the behavior is
    // the same on links not using the "btn" class -> pointer-events disabled.
    btnEl.classList.add('o_website_btn_loading', 'disabled', 'pe-none');
    btnEl.disabled = true;
    const loaderEl = document.createElement('span');
    loaderEl.classList.add('fa', 'fa-refresh', 'fa-spin', 'me-2');
    btnEl.prepend(loaderEl);
    return () => {
        btnEl.classList.remove('o_website_btn_loading', 'disabled', 'pe-none');
        btnEl.disabled = false;
        loaderEl.remove();
    };
}

return __exports;
});
;

/****************************************************
*  Filepath: /web/static/src/legacy/js/core/dom.js  *
*  Lines: 237                                       *
****************************************************/
odoo.define('@web/legacy/js/core/dom', ['@web/legacy/js/core/minimal_dom'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

/**
 * DOM Utility helpers
 *
 * We collect in this file some helpers to help integrate various DOM
 * functionalities with the odoo framework.  A common theme in these functions
 * is the use of the main core.bus, which helps the framework react when
 * something happens in the DOM.
 */

const minimalDom = require('@web/legacy/js/core/minimal_dom');

const dom = Object.assign({}, minimalDom, {
    /**
     * jQuery find function behavior is::
     *
     *      $('A').find('A B') <=> $('A A B')
     *
     * The searches behavior to find options' DOM needs to be::
     *
     *      $('A').find('A B') <=> $('A B')
     *
     * This is what this function does.
     *
     * @param {jQuery} $from - the jQuery element(s) from which to search
     * @param {string} selector - the CSS selector to match
     * @param {boolean} [addBack=false] - whether or not the $from element
     *                                  should be considered in the results
     * @returns {jQuery}
     */
    cssFind: function ($from, selector, addBack) {
        var $results;

        // No way to correctly parse a complex jQuery selector but having no
        // spaces should be a good-enough condition to use a simple find
        var multiParts = selector.indexOf(' ') >= 0;
        if (multiParts) {
            $results = $from.closest('body').find(selector).filter((i, $el) => $from.has($el).length);
        } else {
            $results = $from.find(selector);
        }

        if (addBack && $from.is(selector)) {
            $results = $results.add($from);
        }

        return $results;
    },
    /**
     * Renders a button with standard odoo template. This does not use any xml
     * template to avoid forcing the frontend part to lazy load a xml file for
     * each widget which might want to create a simple button.
     *
     * @param {Object} options
     * @param {Object} [options.attrs] - Attributes to put on the button element
     * @param {string} [options.attrs.type='button']
     * @param {string} [options.attrs.class='btn-secondary']
     *        Note: automatically completed with "btn btn-X"
     *        (@see options.size for the value of X)
     * @param {string} [options.size] - @see options.attrs.class
     * @param {string} [options.icon]
     *        The specific fa icon class (for example "fa-home") or an URL for
     *        an image to use as icon.
     * @param {string} [options.text] - the button's text
     * @returns {jQuery}
     */
    renderButton: function (options) {
        var jQueryParams = Object.assign({
            type: 'button',
        }, options.attrs || {});

        var extraClasses = jQueryParams.class;
        if (extraClasses) {
            // If we got extra classes, check if old oe_highlight/oe_link
            // classes are given and switch them to the right classes (those
            // classes have no style associated to them anymore).
            // TODO ideally this should be dropped at some point.
            extraClasses = extraClasses.replace(/\boe_highlight\b/g, 'btn-primary')
                                       .replace(/\boe_link\b/g, 'btn-link');
        }

        jQueryParams.class = 'btn';
        if (options.size) {
            jQueryParams.class += (' btn-' + options.size);
        }
        jQueryParams.class += (' ' + (extraClasses || 'btn-secondary'));

        var $button = $('<button/>', jQueryParams);

        if (options.icon) {
            if (options.icon.substr(0, 3) === 'fa-') {
                $button.append($('<i/>', {
                    class: 'fa fa-fw o_button_icon ' + options.icon,
                }));
            } else {
                $button.append($('<img/>', {
                    src: options.icon,
                }));
            }
        }
        if (options.text) {
            $button.append($('<span/>', {
                text: options.text,
            }));
        }

        return $button;
    },
    /**
     * Computes the size by which a scrolling point should be decreased so that
     * the top fixed elements of the page appear above that scrolling point.
     *
     * @return {Document} [document=window.document]
     * @returns {number}
     */
    scrollFixedOffset(document = window.document) {
        let size = 0;
        for (const el of document.querySelectorAll('.o_top_fixed_element')) {
            size += $(el).outerHeight();
        }
        return size;
    },
    /**
     * @param {HTMLElement|string} el - the element to scroll to. If "el" is a
     *      string, it must be a valid selector of an element in the DOM or
     *      '#top' or '#bottom'. If it is an HTML element, it must be present
     *      in the DOM.
     *      Limitation: if the element is using a fixed position, this
     *      function cannot work except if is the header (el is then either a
     *      string set to '#top' or an HTML element with the "top" id) or the
     *      footer (el is then a string set to '#bottom' or an HTML element
     *      with the "bottom" id) for which exceptions have been made.
     * @param {number} [options] - same as animate of jQuery
     * @param {number} [options.extraOffset=0]
     *      extra offset to add on top of the automatic one (the automatic one
     *      being computed based on fixed header sizes)
     * @param {number} [options.forcedOffset]
     *      offset used instead of the automatic one (extraOffset will be
     *      ignored too)
     * @param {JQuery} [options.$scrollable] the $element to scroll
     * @return {Promise}
     */
    scrollTo(el, options = {}) {
        if (!el) {
            throw new Error("The scrollTo function was called without any given element");
        }
        const $el = $(el);
        if (typeof(el) === 'string' && $el[0]) {
            el = $el[0];
        }
        const isTopOrBottomHidden = (el === '#top' || el === '#bottom');
        const $scrollable = isTopOrBottomHidden ? $().getScrollingElement() : (options.$scrollable || $el.parent().closestScrollable());
        // If $scrollable and $el are not in the same document, we can safely
        // assume $el is in an $iframe. We retrieve it by filtering the list of
        // iframes in $scrollable to keep only the one that contains $el.
        const scrollDocument = $scrollable[0].ownerDocument;
        const isInOneDocument = isTopOrBottomHidden || scrollDocument === $el[0].ownerDocument;
        const $iframe = !isInOneDocument && $scrollable.find('iframe').filter((i, node) => $(node).contents().has($el));
        const $topLevelScrollable = $().getScrollingElement(scrollDocument);
        const isTopScroll = $scrollable.is($topLevelScrollable);

        function _computeScrollTop() {
            if (el === '#top' || el.id === 'top') {
                return 0;
            }
            if (el === '#bottom' || el.id === 'bottom') {
                return $scrollable[0].scrollHeight - $scrollable[0].clientHeight;
            }

            el.classList.add("o_check_scroll_position");
            let offsetTop = $el.offset().top;
            el.classList.remove("o_check_scroll_position");
            if (el.classList.contains('d-none')) {
                el.classList.remove('d-none');
                offsetTop = $el.offset().top;
                el.classList.add('d-none');
            }
            const isDocScrollingEl = $scrollable.is(el.ownerDocument.scrollingElement);
            let elPosition = offsetTop
                - ($scrollable.offset().top - (isDocScrollingEl ? 0 : $scrollable[0].scrollTop));
            if (!isInOneDocument && $iframe.length) {
                elPosition += $iframe.offset().top;
            }
            let offset = options.forcedOffset;
            if (offset === undefined) {
                offset = (isTopScroll ? dom.scrollFixedOffset(scrollDocument) : 0) + (options.extraOffset || 0);
            }
            return Math.max(0, elPosition - offset);
        }

        const originalScrollTop = _computeScrollTop();

        return new Promise(resolve => {
            const clonedOptions = Object.assign({}, options);

            // During the animation, detect any change needed for the scroll
            // offset. If any occurs, stop the animation and continuing it to
            // the new scroll point for the remaining time.
            // Note: limitation, the animation won't be as fluid as possible if
            // the easing mode is different of 'linear'.
            clonedOptions.progress = function (a, b, remainingMs) {
                if (options.progress) {
                    options.progress.apply(this, ...arguments);
                }
                const newScrollTop = _computeScrollTop();
                if (Math.abs(newScrollTop - originalScrollTop) <= 1.0
                        && (isTopOrBottomHidden || !(el.classList.contains('o_transitioning')))) {
                    return;
                }
                $scrollable.stop();
                dom.scrollTo(el, Object.assign({}, options, {
                    duration: remainingMs,
                    easing: 'linear',
                })).then(() => resolve());
            };

            // Detect the end of the animation to be able to indicate it to
            // the caller via the returned Promise.
            clonedOptions.complete = function () {
                if (options.complete) {
                    options.complete.apply(this, ...arguments);
                }
                resolve();
            };

            $scrollable.animate({scrollTop: originalScrollTop}, clonedOptions);
        });
    },
});
__exports[Symbol.for("default")] = dom;

return __exports;
});
;

/*******************************************************
*  Filepath: /web/static/src/legacy/js/core/mixins.js  *
*  Lines: 424                                          *
*******************************************************/
odoo.define('@web/legacy/js/core/mixins', ['@web/core/utils/numbers'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { floatIsZero } = require("@web/core/utils/numbers");

/**
 * Mixin to structure objects' life-cycles folowing a parent-children
 * relationship. Each object can a have a parent and multiple children.
 * When an object is destroyed, all its children are destroyed too releasing
 * any resource they could have reserved before.
 *
 * @name ParentedMixin
 * @mixin
 */
var ParentedMixin = {
    __parentedMixin : true,
    init: function () {
        this.__parentedDestroyed = false;
        this.__parentedChildren = [];
        this.__parentedParent = null;
    },
    /**
     * Set the parent of the current object. When calling this method, the
     * parent will also be informed and will return the current object
     * when its getChildren() method is called. If the current object did
     * already have a parent, it is unregistered before, which means the
     * previous parent will not return the current object anymore when its
     * getChildren() method is called.
     */
    setParent : function (parent) {
        if (this.getParent()) {
            if (this.getParent().__parentedMixin) {
                const children = this.getParent().getChildren();
                this.getParent().__parentedChildren = children.filter(
                    (child) => child.$el !== this.$el
                );
            }
        }
        this.__parentedParent = parent;
        if (parent && parent.__parentedMixin) {
            parent.__parentedChildren.push(this);
        }
    },
    /**
     * Return the current parent of the object (or null).
     */
    getParent : function () {
        return this.__parentedParent;
    },
    /**
     * Return a list of the children of the current object.
     */
    getChildren : function () {
        return [...this.__parentedChildren];
    },
    /**
     * Returns true if destroy() was called on the current object.
     */
    isDestroyed : function () {
        return this.__parentedDestroyed;
    },
    /**
     * Utility method to only execute asynchronous actions if the current
     * object has not been destroyed.
     *
     * @param {Promise} promise The promise representing the asynchronous
     *                             action.
     * @param {bool} [shouldReject=false] If true, the returned promise will be
     *                              rejected with no arguments if the current
     *                              object is destroyed. If false, the
     *                              returned promise will never be resolved
     *                              or rejected.
     * @returns {Promise} A promise that will mirror the given promise if
     *                       everything goes fine but will either be rejected
     *                       with no arguments or never resolved if the
     *                       current object is destroyed.
     */
    alive: function (promise, shouldReject) {
        var self = this;

        return new Promise(function (resolve, reject) {
            promise.then(function (result) {
                if (!self.isDestroyed()) {
                    resolve(result);
                } else if (shouldReject) {
                    reject();
                }
            }).catch(function (reason) {
                if (!self.isDestroyed()) {
                    reject(reason);
                } else if (shouldReject) {
                    reject();
                }
            });
        });
    },
    /**
     * Inform the object it should destroy itself, releasing any
     * resource it could have reserved.
     */
    destroy : function () {
        this.getChildren().forEach(function (child) {
            child.destroy();
        });
        this.setParent(undefined);
        this.__parentedDestroyed = true;
    },
    /**
     * Find the closest ancestor matching predicate
     */
    findAncestor: function (predicate) {
        var ancestor = this;
        while (ancestor && !(predicate(ancestor)) && ancestor.getParent) {
            ancestor = ancestor.getParent();
        }
        return ancestor;
    },
};

function OdooEvent(target, name, data) {
    this.target = target;
    this.name = name;
    this.data = Object.create(null);
    Object.assign(this.data, data);
    this.stopped = false;
}

OdooEvent.prototype.stopPropagation = function () {
    this.stopped = true;
};

OdooEvent.prototype.is_stopped = function () {
    return this.stopped;
};

/**
 * Backbone's events. Do not ever use it directly, use EventDispatcherMixin instead.
 *
 * This class just handle the dispatching of events, it is not meant to be extended,
 * nor used directly. All integration with parenting and automatic unregistration of
 * events is done in EventDispatcherMixin.
 *
 * Copyright notice for the following Class:
 *
 * (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
 * Backbone may be freely distributed under the MIT license.
 * For all details and documentation:
 * http://backbonejs.org
 *
 */
class Events {
    on(events, callback, context) {
        var ev;
        events = events.split(/\s+/);
        var calls = this._callbacks || (this._callbacks = {});
        while ((ev = events.shift())) {
            var list = calls[ev] || (calls[ev] = {});
            var tail = list.tail || (list.tail = list.next = {});
            tail.callback = callback;
            tail.context = context;
            list.tail = tail.next = {};
        }
        return this;
    }

    off(events, callback, context) {
        var ev, calls, node;
        if (!events) {
            delete this._callbacks;
        } else if ((calls = this._callbacks)) {
            events = events.split(/\s+/);
            while ((ev = events.shift())) {
                node = calls[ev];
                delete calls[ev];
                if (!callback || !node)
                    continue;
                while ((node = node.next) && node.next) {
                    if (node.callback === callback
                            && (!context || node.context === context))
                        continue;
                    this.on(ev, node.callback, node.context);
                }
            }
        }
        return this;
    }

    callbackList() {
        var lst = [];
        for (const [eventName, el] of Object.entries(this._callbacks || {})) {
            var node = el;
            while ((node = node.next) && node.next) {
                lst.push([eventName, node.callback, node.context]);
            }
        }
        return lst;
    }

    trigger(events) {
        var event, node, calls, tail, args, all, rest;
        if (!(calls = this._callbacks))
            return this;
        all = calls.all;
        (events = events.split(/\s+/)).push(null);
        // Save references to the current heads & tails.
        while ((event = events.shift())) {
            if (all)
                events.push({
                    next : all.next,
                    tail : all.tail,
                    event : event
                });
            if (!(node = calls[event]))
                continue;
            events.push({
                next : node.next,
                tail : node.tail
            });
        }
        rest = Array.prototype.slice.call(arguments, 1);
        while ((node = events.pop())) {
            tail = node.tail;
            args = node.event ? [ node.event ].concat(rest) : rest;
            while ((node = node.next) !== tail) {
                node.callback.apply(node.context || this, args);
            }
        }
        return this;
    }
}

/**
 * Mixin containing an event system. Events are also registered by specifying the target object
 * (the object which will receive the event when it is raised). Both the event-emitting object
 * and the target object store or reference to each other. This is used to correctly remove all
 * reference to the event handler when any of the object is destroyed (when the destroy() method
 * from ParentedMixin is called). Removing those references is necessary to avoid memory leak
 * and phantom events (events which are raised and sent to a previously destroyed object).
 *
 * @name EventDispatcherMixin
 * @mixin
 */
var EventDispatcherMixin = Object.assign({}, ParentedMixin, {
    __eventDispatcherMixin: true,
    custom_events: {},
    init: function () {
        ParentedMixin.init.call(this);
        this.__edispatcherEvents = new Events();
        this.__edispatcherRegisteredEvents = [];
        this._delegateCustomEvents();
    },
    /**
     * Proxies a method of the object, in order to keep the right ``this`` on
     * method invocations.
     *
     * This method is similar to ``Function.prototype.bind``, and
     * even more so to ``jQuery.proxy`` with a fundamental difference: its
     * resolution of the method being called is lazy, meaning it will use the
     * method as it is when the proxy is called, not when the proxy is created.
     *
     * Other methods will fix the bound method to what it is when creating the
     * binding/proxy, which is fine in most javascript code but problematic in
     * OpenERP Web where developers may want to replace existing callbacks with
     * theirs.
     *
     * The semantics of this precisely replace closing over the method call.
     *
     * @param {String|Function} method function or name of the method to invoke
     * @returns {Function} proxied method
     */
    proxy: function (method) {
        var self = this;
        return function () {
            var fn = (typeof method === 'string') ? self[method] : method;
            if (fn === void 0) {
                throw new Error("Couldn't find method '" + method + "' in widget " + self);
            }
            return fn.apply(self, arguments);
        };
    },
    _delegateCustomEvents: function () {
        if (Object.keys(this.custom_events || {}).length === 0) { return; }
        for (var key in this.custom_events) {
            if (!this.custom_events.hasOwnProperty(key)) { continue; }

            var method = this.proxy(this.custom_events[key]);
            this.on(key, this, method);
        }
    },
    on: function (events, dest, func) {
        var self = this;
        if (typeof func !== "function") {
            throw new Error("Event handler must be a function.");
        }
        events = events.split(/\s+/);
        events.forEach((eventName) => {
            self.__edispatcherEvents.on(eventName, func, dest);
            if (dest && dest.__eventDispatcherMixin) {
                dest.__edispatcherRegisteredEvents.push({name: eventName, func: func, source: self});
            }
        });
        return this;
    },
    off: function (events, dest, func) {
        var self = this;
        events = events.split(/\s+/);
        events.forEach((eventName) => {
            self.__edispatcherEvents.off(eventName, func, dest);
            if (dest && dest.__eventDispatcherMixin) {
                dest.__edispatcherRegisteredEvents = dest.__edispatcherRegisteredEvents.filter(el => {
                    return !(el.name === eventName && el.func === func && el.source === self);
                });
            }
        });
        return this;
    },
    once: function (events, dest, func) {
        // similar to this.on(), but func is executed only once
        var self = this;
        if (typeof func !== "function") {
            throw new Error("Event handler must be a function.");
        }
        self.on(events, dest, function what() {
            func.apply(this, arguments);
            self.off(events, dest, what);
        });
    },
    trigger: function () {
        this.__edispatcherEvents.trigger.apply(this.__edispatcherEvents, arguments);
        return this;
    },
    trigger_up: function (name, info) {
        var event = new OdooEvent(this, name, info);
        //console.info('event: ', name, info);
        this._trigger_up(event);
        return event;
    },
    _trigger_up: function (event) {
        var parent;
        this.__edispatcherEvents.trigger(event.name, event);
        if (!event.is_stopped() && (parent = this.getParent())) {
            parent._trigger_up(event);
        }
    },
    destroy: function () {
        var self = this;
        this.__edispatcherRegisteredEvents.forEach((event) => {
            event.source.__edispatcherEvents.off(event.name, event.func, self);
        });
        this.__edispatcherRegisteredEvents = [];
        this.__edispatcherEvents.callbackList().forEach(
            ((cal) => {
                this.off(cal[0], cal[2], cal[1]);
            }).bind(this)
        );
        this.__edispatcherEvents.off();
        ParentedMixin.destroy.call(this);
    },
});

/**
 * @name PropertiesMixin
 * @mixin
 */
var PropertiesMixin = Object.assign({}, EventDispatcherMixin, {
    init: function () {
        EventDispatcherMixin.init.call(this);
        this.__getterSetterInternalMap = {};
    },
    set: function (arg1, arg2, arg3) {
        var map;
        var options;
        if (typeof arg1 === "string") {
            map = {};
            map[arg1] = arg2;
            options = arg3 || {};
        } else {
            map = arg1;
            options = arg2 || {};
        }
        var self = this;
        var changed = false;
        for (const [key, val] of Object.entries(map)) {
            var tmp = self.__getterSetterInternalMap[key];
            if (tmp === val)
                return;
            // seriously, why are you doing this? it is obviously a stupid design.
            // the properties mixin should not be concerned with handling fields details.
            // this also has the side effect of introducing a dependency on utils.  Todo:
            // remove this, or move it elsewhere.  Also, learn OO programming.
            if (key === 'value' && self.field && self.field.type === 'float' && tmp && val){
                var digits = self.field.digits;
                if (Array.isArray(digits)) {
                    if (floatIsZero(tmp - val, digits[1])) {
                        return;
                    }
                }
            }
            changed = true;
            self.__getterSetterInternalMap[key] = val;
            if (! options.silent)
                self.trigger("change:" + key, self, {
                    oldValue: tmp,
                    newValue: val
                });
        }
        if (changed)
            self.trigger("change", self);
    },
    get: function (key) {
        return this.__getterSetterInternalMap[key];
    }
});

__exports[Symbol.for("default")] = {
    ParentedMixin: ParentedMixin,
    EventDispatcherMixin: EventDispatcherMixin,
    PropertiesMixin: PropertiesMixin,
};

return __exports;
});
;

/***************************************************************
*  Filepath: /web/static/src/legacy/js/core/service_mixins.js  *
*  Lines: 71                                                   *
***************************************************************/
odoo.define('@web/legacy/js/core/service_mixins', ['@web/env', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { SERVICES_METADATA } = require("@web/env");
const { Component } = require("@odoo/owl");

function protectMethod(widget, fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            Promise.resolve(fn.call(this, ...args))
                .then((result) => {
                    if (!widget.isDestroyed()) {
                        resolve(result);
                    }
                })
                .catch((reason) => {
                    if (!widget.isDestroyed()) {
                        reject(reason);
                    }
                });
        });
    };
}

var ServicesMixin = {
    bindService: function (serviceName) {
        const { services } = Component.env;
        const service = services[serviceName];
        if (!service) {
            throw new Error(`Service ${serviceName} is not available`);
        }
        if (serviceName in SERVICES_METADATA) {
            if (service instanceof Function) {
                return protectMethod(this, service);
            } else {
                const methods = SERVICES_METADATA[serviceName];
                const result = Object.create(service);
                for (const method of methods) {
                    result[method] = protectMethod(this, service[method]);
                }
                return result;
            }
        }
        return service;
    },
    /**
     * @param  {string} service
     * @param  {string} method
     * @return {any} result of the service called
     */
    call: function (service, method) {
        var args = Array.prototype.slice.call(arguments, 2);
        var result;
        this.trigger_up('call_service', {
            service: service,
            method: method,
            args: args,
            callback: function (r) {
                result = r;
            },
        });
        return result;
    },
};

__exports[Symbol.for("default")] = ServicesMixin;

return __exports;
});
;

/*******************************************************
*  Filepath: /web/static/src/legacy/js/core/widget.js  *
*  Lines: 438                                          *
*******************************************************/
odoo.define('@web/legacy/js/core/widget', ['@web/legacy/js/core/class', '@web/legacy/js/core/mixins', '@web/legacy/js/core/service_mixins', '@web/core/assets', '@web/core/utils/render'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const Class = require("@web/legacy/js/core/class")[Symbol.for("default")];
const mixins = require("@web/legacy/js/core/mixins")[Symbol.for("default")];
const ServicesMixin = require("@web/legacy/js/core/service_mixins")[Symbol.for("default")];
const { loadBundle } = require("@web/core/assets");
const { renderToElement } = require("@web/core/utils/render");

/**
 * Base class for all visual components. Provides a lot of functions helpful
 * for the management of a part of the DOM.
 *
 * Widget handles:
 *
 * - Rendering with QWeb.
 * - Life-cycle management and parenting (when a parent is destroyed, all its
 *   children are destroyed too).
 * - Insertion in DOM.
 *
 * **Guide to create implementations of the Widget class**
 *
 * Here is a sample child class::
 *
 *     var MyWidget = Widget.extend({
 *         // the name of the QWeb template to use for rendering
 *         template: "MyQWebTemplate",
 *
 *         init: function (parent) {
 *             this._super(parent);
 *             // stuff that you want to init before the rendering
 *         },
 *         willStart: function () {
 *             // async work that need to be done before the widget is ready
 *             // this method should return a promise
 *         },
 *         start: function() {
 *             // stuff you want to make after the rendering, `this.$el` holds a correct value
 *             this.$(".my_button").click(/* an example of event binding * /);
 *
 *             // if you have some asynchronous operations, it's a good idea to return
 *             // a promise in start(). Note that this is quite rare, and if you
 *             // need to fetch some data, this should probably be done in the
 *             // willStart method
 *             var promise = this._rpc(...);
 *             return promise;
 *         }
 *     });
 *
 * Now this class can simply be used with the following syntax::
 *
 *     var myWidget = new MyWidget(this);
 *     myWidget.appendTo($(".some-div"));
 *
 * With these two lines, the MyWidget instance was initialized, rendered,
 * inserted into the DOM inside the ``.some-div`` div and its events were
 * bound.
 *
 * And of course, when you don't need that widget anymore, just do::
 *
 *     myWidget.destroy();
 *
 * That will kill the widget in a clean way and erase its content from the dom.
 */

var Widget = __exports.Widget = Class.extend(mixins.PropertiesMixin, ServicesMixin, {
    // Backbone-ish API
    tagName: 'div',
    id: null,
    className: null,
    attributes: {},
    events: {},
    /**
     * The name of the QWeb template that will be used for rendering. Must be
     * redefined in subclasses or the default render() method can not be used.
     *
     * @type {null|string}
     */
    template: null,
    /**
     * List of paths to css files that need to be loaded before the widget can
     * be rendered. This will not induce loading anything that has already been
     * loaded.
     *
     * @type {null|string[]}
     */
    cssLibs: null,
    /**
     * List of paths to js files that need to be loaded before the widget can
     * be rendered. This will not induce loading anything that has already been
     * loaded.
     *
     * @type {null|string[]}
     */
    jsLibs: null,
    /**
     * List of xmlID that need to be loaded before the widget can be rendered.
     * The content css (link file or style tag) and js (file or inline) of the
     * assets are loaded.
     * This will not induce loading anything that has already been
     * loaded.
     *
     * @type {null|string[]}
     */
    assetLibs: null,

    /**
     * Constructs the widget and sets its parent if a parent is given.
     *
     * @param {Widget|null} parent Binds the current instance to the given Widget
     *   instance. When that widget is destroyed by calling destroy(), the
     *   current instance will be destroyed too. Can be null.
     */
    init: function (parent) {
        mixins.PropertiesMixin.init.call(this);
        this.setParent(parent);
        // Bind on_/do_* methods to this
        // We might remove this automatic binding in the future
        for (var name in this) {
            if(typeof(this[name]) === "function") {
                if((/^on_|^do_/).test(name)) {
                    this[name] = this[name].bind(this);
                }
            }
        }
    },
    /**
     * Method called between @see init and @see start. Performs asynchronous
     * calls required by the rendering and the start method.
     *
     * This method should return a Promose which is resolved when start can be
     * executed.
     *
     * @returns {Promise}
     */
    willStart: function () {
        var proms = [];
        if (this.jsLibs || this.cssLibs || this.assetLibs) {
            proms.push(loadBundle(this));
        }
        return Promise.all(proms);
    },
    /**
     * Method called after rendering. Mostly used to bind actions, perform
     * asynchronous calls, etc...
     *
     * By convention, this method should return an object that can be passed to
     * Promise.resolve() to inform the caller when this widget has been initialized.
     *
     * Note that, for historic reasons, many widgets still do work in the start
     * method that would be more suited to the willStart method.
     *
     * @returns {Promise}
     */
    start: function () {
        return Promise.resolve();
    },
    /**
     * Destroys the current widget, also destroys all its children before
     * destroying itself.
     */
    destroy: function () {
        mixins.PropertiesMixin.destroy.call(this);
        if (this.$el) {
            this.$el.remove();
        }
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Renders the current widget and appends it to the given jQuery object.
     *
     * @param {jQuery} target
     * @returns {Promise}
     */
    appendTo: function (target) {
        var self = this;
        return this._widgetRenderAndInsert(function (t) {
            self.$el.appendTo(t);
        }, target);
    },
    /**
     * Attach the current widget to a dom element
     *
     * @param {jQuery} target
     * @returns {Promise}
     */
    attachTo: function (target) {
        var self = this;
        this.setElement(target.$el || target);
        return this.willStart().then(function () {
            if (self.__parentedDestroyed) {
                return;
            }
            return self.start();
        });
    },
    /**
     * Hides the widget
     */
    do_hide: function () {
        if (this.$el) {
            this.$el.addClass('o_hidden');
        }
    },
    /**
     * Displays the widget
     */
    do_show: function () {
        if (this.$el) {
            this.$el.removeClass('o_hidden');
        }
    },
    /**
     * Displays or hides the widget
     * @param {boolean} [display] use true to show the widget or false to hide it
     */
    do_toggle: function (display) {
        if (typeof display === "boolean") {
            display ? this.do_show() : this.do_hide();
        } else if (this.$el) {
            this.$el.hasClass('o_hidden') ? this.do_show() : this.do_hide();
        }
    },
    /**
     * Renders the current widget and inserts it after to the given jQuery
     * object.
     *
     * @param {jQuery} target
     * @returns {Promise}
     */
    insertAfter: function (target) {
        var self = this;
        return this._widgetRenderAndInsert(function (t) {
            self.$el.insertAfter(t);
        }, target);
    },
    /**
     * Renders the current widget and inserts it before to the given jQuery
     * object.
     *
     * @param {jQuery} target
     * @returns {Promise}
     */
    insertBefore: function (target) {
        var self = this;
        return this._widgetRenderAndInsert(function (t) {
            self.$el.insertBefore(t);
        }, target);
    },
    /**
     * Renders the current widget and prepends it to the given jQuery object.
     *
     * @param {jQuery} target
     * @returns {Promise}
     */
    prependTo: function (target) {
        var self = this;
        return this._widgetRenderAndInsert(function (t) {
            self.$el.prependTo(t);
        }, target);
    },
    /**
     * Renders the element. The default implementation renders the widget using
     * QWeb, `this.template` must be defined. The context given to QWeb contains
     * the "widget" key that references `this`.
     */
    renderElement: function () {
        var $el;
        if (this.template) {
            $el = $(renderToElement(this.template, { widget: this }));
        } else {
            $el = this._makeDescriptive();
        }
        this._replaceElement($el);
    },
    /**
     * Renders the current widget and replaces the given jQuery object.
     *
     * @param target A jQuery object or a Widget instance.
     * @returns {Promise}
     */
    replace: function (target) {
        return this._widgetRenderAndInsert((t) => {
            this.$el.replaceAll(t);
        }, target);
    },
    /**
     * Re-sets the widget's root element (el/$el/$el).
     *
     * Includes:
     *
     * * re-delegating events
     * * re-binding sub-elements
     * * if the widget already had a root element, replacing the pre-existing
     *   element in the DOM
     *
     * @param {HTMLElement | jQuery} element new root element for the widget
     * @return {Widget} this
     */
    setElement: function (element) {
        if (this.$el) {
            this._undelegateEvents();
        }

        this.$el = (element instanceof $) ? element : $(element);
        this.el = this.$el[0];

        this._delegateEvents();

        return this;
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Helper method, for ``this.$el.find(selector)``
     *
     * @private
     * @param {string} selector CSS selector, rooted in $el
     * @returns {jQuery} selector match
     */
    $: function (selector) {
        if (selector === undefined) {
            return this.$el;
        }
        return this.$el.find(selector);
    },
    /**
     * Attach event handlers for events described in the 'events' key
     *
     * @private
     */
    _delegateEvents: function () {
        var events = this.events;
        if (Object.keys(events || {}).length === 0) { return; }

        for(var key in events) {
            if (!events.hasOwnProperty(key)) { continue; }

            var method = this.proxy(events[key]);

            var match = /^(\S+)(\s+(.*))?$/.exec(key);
            var event = match[1];
            var selector = match[3];

            event += '.widget_events';
            if (!selector) {
                this.$el.on(event, method);
            } else {
                this.$el.on(event, selector, method);
            }
        }
    },
    /**
     * Makes a potential root element from the declarative builder of the
     * widget
     *
     * @private
     * @return {jQuery}
     */
    _makeDescriptive: function () {
        var attrs = Object.assign({}, this.attributes || {});
        if (this.id) {
            attrs.id = this.id;
        }
        if (this.className) {
            attrs['class'] = this.className;
        }
        var $el = $(document.createElement(this.tagName));
        if (Object.keys(attrs || {}).length > 0) {
            $el.attr(attrs);
        }
        return $el;
    },
    /**
     * Re-sets the widget's root element and replaces the old root element
     * (if any) by the new one in the DOM.
     *
     * @private
     * @param {HTMLElement | jQuery} $el
     * @returns {Widget} this instance, so it can be chained
     */
    _replaceElement: function ($el) {
        var $oldel = this.$el;
        this.setElement($el);
        if ($oldel && !$oldel.is(this.$el)) {
            if ($oldel.length > 1) {
                $oldel.wrapAll('<div/>');
                $oldel.parent().replaceWith(this.$el);
            } else {
                $oldel.replaceWith(this.$el);
            }
        }
        return this;
    },
    /**
     * Remove all handlers registered on this.$el
     *
     * @private
     */
    _undelegateEvents: function () {
        this.$el.off('.widget_events');
    },
    /**
     * Render the widget.  This is a private method, and should really never be
     * called by anyone (except this widget).  It assumes that the widget was
     * not willStarted yet.
     *
     * @private
     * @param {function: jQuery -> any} insertion
     * @param {jQuery} target
     * @returns {Promise}
     */
    _widgetRenderAndInsert: function (insertion, target) {
        var self = this;
        return this.willStart().then(function () {
            if (self.__parentedDestroyed) {
                return;
            }
            self.renderElement();
            insertion(target);
            return self.start();
        });
    },
});

__exports[Symbol.for("default")] = Widget;

return __exports;
});
;

/**********************************************
*  Filepath: /web/static/src/legacy/utils.js  *
*  Lines: 56                                  *
**********************************************/
odoo.define('@web/legacy/utils', ['@odoo/owl', '@web/core/assets', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { App, Component, useState, xml } = require("@odoo/owl");
const { templates } = require("@web/core/assets");
const { _t } = require("@web/core/l10n/translation");

const rootTemplate = xml`<SubComp t-props="state"/>`;
__exports.attachComponent = attachComponent; async function attachComponent(parent, element, componentClass, props = {}) {
    class Root extends Component {
        static template = rootTemplate;
        static components = { SubComp: componentClass };
        state = useState(props);
    }

    const env = Component.env;
    const app = new App(Root, {
        env,
        templates,
        dev: env.debug,
        translatableAttributes: ["data-tooltip"],
        translateFn: _t,
    });

    if (parent.__parentedMixin) {
        parent.__parentedChildren.push({
            get $el() {
                return $(app.root.el);
            },
            destroy() {
                app.destroy();
            },
        });
    }

    const originalValidateTarget = App.validateTarget;
    App.validateTarget = () => {};
    const mountPromise = app.mount(element);
    App.validateTarget = originalValidateTarget;
    const component = await mountPromise;
    const subComp = Object.values(component.__owl__.children)[0].component;
    return {
        component: subComp,
        destroy() {
            app.destroy();
        },
        update(props) {
            Object.assign(component.state, props);
        },
    };
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_editor/static/lib/cropperjs/cropper.js  *
*  Lines: 3576                                            *
**********************************************************/
/*!
 * Cropper.js v1.5.5
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2019-08-04T02:26:31.160Z
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.Cropper = factory());
}(this, function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var WINDOW = IS_BROWSER ? window : {};
  var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;
  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
  var NAMESPACE = 'cropper'; // Actions

  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw'; // Classes

  var CLASS_CROP = "".concat(NAMESPACE, "-crop");
  var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
  var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
  var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
  var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

  var DATA_ACTION = "".concat(NAMESPACE, "Action");
  var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

  var DRAG_MODE_CROP = 'crop';
  var DRAG_MODE_MOVE = 'move';
  var DRAG_MODE_NONE = 'none'; // Events

  var EVENT_CROP = 'crop';
  var EVENT_CROP_END = 'cropend';
  var EVENT_CROP_MOVE = 'cropmove';
  var EVENT_CROP_START = 'cropstart';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
  var EVENT_READY = 'ready';
  var EVENT_RESIZE = 'resize';
  var EVENT_WHEEL = 'wheel';
  var EVENT_ZOOM = 'zoom'; // Mime types

  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc
  // Inspired by the default width and height of a canvas element.

  var MIN_CONTAINER_WIDTH = 200;
  var MIN_CONTAINER_HEIGHT = 100;

  var DEFAULTS = {
    // Define the view mode of the cropper
    viewMode: 0,
    // 0, 1, 2, 3
    // Define the dragging mode of the cropper
    dragMode: DRAG_MODE_CROP,
    // 'crop', 'move' or 'none'
    // Define the initial aspect ratio of the crop box
    initialAspectRatio: NaN,
    // Define the aspect ratio of the crop box
    aspectRatio: NaN,
    // An object with the previous cropping result data
    data: null,
    // A selector for adding extra containers to preview
    preview: '',
    // Re-render the cropper when resize the window
    responsive: true,
    // Restore the cropped area after resize the window
    restore: true,
    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,
    // Check the current image's Exif Orientation information
    checkOrientation: true,
    // Show the black modal
    modal: true,
    // Show the dashed lines for guiding
    guides: true,
    // Show the center indicator for guiding
    center: true,
    // Show the white modal to highlight the crop box
    highlight: true,
    // Show the grid background
    background: true,
    // Enable to crop the image automatically when initialize
    autoCrop: true,
    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,
    // Enable to move the image
    movable: true,
    // Enable to rotate the image
    rotatable: true,
    // Enable to scale the image
    scalable: true,
    // Enable to zoom the image
    zoomable: true,
    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,
    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,
    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,
    // Enable to move the crop box
    cropBoxMovable: true,
    // Enable to resize the crop box
    cropBoxResizable: true,
    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,
    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: 200,
    minContainerHeight: 100,
    // Shortcuts of events
    ready: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

  /**
   * Check if the given value is not a number.
   */

  var isNaN = Number.isNaN || WINDOW.isNaN;
  /**
   * Check if the given value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
   */

  function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if the given value is a positive number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
   */

  var isPositiveNumber = function isPositiveNumber(value) {
    return value > 0 && value < Infinity;
  };
  /**
   * Check if the given value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Check if the given value is an object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
   */

  function isObject(value) {
    return _typeof(value) === 'object' && value !== null;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check if the given value is a plain object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
   */

  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }

    try {
      var _constructor = value.constructor;
      var prototype = _constructor.prototype;
      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if the given value is a function.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  var slice = Array.prototype.slice;
  /**
   * Convert array-like or iterable object to an array.
   * @param {*} value - The value to convert.
   * @returns {Array} Returns a new array.
   */

  function toArray(value) {
    return Array.from ? Array.from(value) : slice.call(value);
  }
  /**
   * Iterate the given data.
   * @param {*} data - The data to iterate.
   * @param {Function} callback - The process function for each element.
   * @returns {*} The original data.
   */

  function forEach(data, callback) {
    if (data && isFunction(callback)) {
      if (Array.isArray(data) || isNumber(data.length)
      /* array-like */
      ) {
          toArray(data).forEach(function (value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
        Object.keys(data).forEach(function (key) {
          callback.call(data, data[key], key, data);
        });
      }
    }

    return data;
  }
  /**
   * Extend the given object.
   * @param {*} target - The target object to extend.
   * @param {*} args - The rest objects for merging to the target object.
   * @returns {Object} The extended object.
   */

  var assign = Object.assign || function assign(target) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (isObject(target) && args.length > 0) {
      args.forEach(function (arg) {
        if (isObject(arg)) {
          Object.keys(arg).forEach(function (key) {
            target[key] = arg[key];
          });
        }
      });
    }

    return target;
  };
  var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
  /**
   * Normalize decimal number.
   * Check out {@link http://0.30000000000000004.com/}
   * @param {number} value - The value to normalize.
   * @param {number} [times=100000000000] - The times for normalizing.
   * @returns {number} Returns the normalized number.
   */

  function normalizeDecimalNumber(value) {
    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
  }
  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
  /**
   * Apply styles to the given element.
   * @param {Element} element - The target element.
   * @param {Object} styles - The styles for applying.
   */

  function setStyle(element, styles) {
    var style = element.style;
    forEach(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value = "".concat(value, "px");
      }

      style[property] = value;
    });
  }
  /**
   * Check if the given element has a special class.
   * @param {Element} element - The element to check.
   * @param {string} value - The class to search.
   * @returns {boolean} Returns `true` if the special class was found.
   */

  function hasClass(element, value) {
    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
  }
  /**
   * Add classes to the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be added.
   */

  function addClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        addClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.add(value);
      return;
    }

    var className = element.className.trim();

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = "".concat(className, " ").concat(value);
    }
  }
  /**
   * Remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be removed.
   */

  function removeClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        removeClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.remove(value);
      return;
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }
  /**
   * Add or remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be toggled.
   * @param {boolean} added - Add only.
   */

  function toggleClass(element, value, added) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        toggleClass(elem, value, added);
      });
      return;
    } // IE10-11 doesn't support the second parameter of `classList.toggle`


    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }
  var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
  /**
   * Transform the given string from camelCase to kebab-case
   * @param {string} value - The value to transform.
   * @returns {string} The transformed value.
   */

  function toParamCase(value) {
    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
  }
  /**
   * Get data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to get.
   * @returns {string} The data value.
   */

  function getData(element, name) {
    if (isObject(element[name])) {
      return element[name];
    }

    if (element.dataset) {
      return element.dataset[name];
    }

    return element.getAttribute("data-".concat(toParamCase(name)));
  }
  /**
   * Set data to the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to set.
   * @param {string} data - The data value.
   */

  function setData(element, name, data) {
    if (isObject(data)) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute("data-".concat(toParamCase(name)), data);
    }
  }
  /**
   * Remove data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to remove.
   */

  function removeData(element, name) {
    if (isObject(element[name])) {
      try {
        delete element[name];
      } catch (error) {
        element[name] = undefined;
      }
    } else if (element.dataset) {
      // #128 Safari not allows to delete dataset property
      try {
        delete element.dataset[name];
      } catch (error) {
        element.dataset[name] = undefined;
      }
    } else {
      element.removeAttribute("data-".concat(toParamCase(name)));
    }
  }
  var REGEXP_SPACES = /\s\s*/;

  var onceSupported = function () {
    var supported = false;

    if (IS_BROWSER) {
      var once = false;

      var listener = function listener() {};

      var options = Object.defineProperty({}, 'once', {
        get: function get() {
          supported = true;
          return once;
        },

        /**
         * This setter can fix a `TypeError` in strict mode
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
         * @param {boolean} value - The value to set
         */
        set: function set(value) {
          once = value;
        }
      });
      WINDOW.addEventListener('test', listener, options);
      WINDOW.removeEventListener('test', listener, options);
    }

    return supported;
  }();
  /**
   * Remove event listener from the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */


  function removeListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (!onceSupported) {
        var listeners = element.listeners;

        if (listeners && listeners[event] && listeners[event][listener]) {
          handler = listeners[event][listener];
          delete listeners[event][listener];

          if (Object.keys(listeners[event]).length === 0) {
            delete listeners[event];
          }

          if (Object.keys(listeners).length === 0) {
            delete element.listeners;
          }
        }
      }

      element.removeEventListener(event, handler, options);
    });
  }
  /**
   * Add event listener to the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */

  function addListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var _handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (options.once && !onceSupported) {
        var _element$listeners = element.listeners,
            listeners = _element$listeners === void 0 ? {} : _element$listeners;

        _handler = function handler() {
          delete listeners[event][listener];
          element.removeEventListener(event, _handler, options);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          listener.apply(element, args);
        };

        if (!listeners[event]) {
          listeners[event] = {};
        }

        if (listeners[event][listener]) {
          element.removeEventListener(event, listeners[event][listener], options);
        }

        listeners[event][listener] = _handler;
        element.listeners = listeners;
      }

      element.addEventListener(event, _handler, options);
    });
  }
  /**
   * Dispatch event on the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Object} data - The additional event data.
   * @returns {boolean} Indicate if the event is default prevented or not.
   */

  function dispatchEvent(element, type, data) {
    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

    if (isFunction(Event) && isFunction(CustomEvent)) {
      event = new CustomEvent(type, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    return element.dispatchEvent(event);
  }
  /**
   * Get the offset base on the document.
   * @param {Element} element - The target element.
   * @returns {Object} The offset data.
   */

  function getOffset(element) {
    var box = element.getBoundingClientRect();
    return {
      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    };
  }
  var location = WINDOW.location;
  var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
  /**
   * Check if the given URL is a cross origin URL.
   * @param {string} url - The target URL.
   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
   */

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);
    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  /**
   * Add timestamp to the given URL.
   * @param {string} url - The target URL.
   * @returns {string} The result URL.
   */

  function addTimestamp(url) {
    var timestamp = "timestamp=".concat(new Date().getTime());
    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
  }
  /**
   * Get transforms base on the given object.
   * @param {Object} obj - The target object.
   * @returns {string} A string contains transform values.
   */

  function getTransforms(_ref) {
    var rotate = _ref.rotate,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        translateX = _ref.translateX,
        translateY = _ref.translateY;
    var values = [];

    if (isNumber(translateX) && translateX !== 0) {
      values.push("translateX(".concat(translateX, "px)"));
    }

    if (isNumber(translateY) && translateY !== 0) {
      values.push("translateY(".concat(translateY, "px)"));
    } // Rotate should come first before scale to match orientation transform


    if (isNumber(rotate) && rotate !== 0) {
      values.push("rotate(".concat(rotate, "deg)"));
    }

    if (isNumber(scaleX) && scaleX !== 1) {
      values.push("scaleX(".concat(scaleX, ")"));
    }

    if (isNumber(scaleY) && scaleY !== 1) {
      values.push("scaleY(".concat(scaleY, ")"));
    }

    var transform = values.length ? values.join(' ') : 'none';
    return {
      WebkitTransform: transform,
      msTransform: transform,
      transform: transform
    };
  }
  /**
   * Get the max ratio of a group of pointers.
   * @param {string} pointers - The target pointers.
   * @returns {number} The result ratio.
   */

  function getMaxZoomRatio(pointers) {
    var pointers2 = assign({}, pointers);
    var ratios = [];
    forEach(pointers, function (pointer, pointerId) {
      delete pointers2[pointerId];
      forEach(pointers2, function (pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;
        ratios.push(ratio);
      });
    });
    ratios.sort(function (a, b) {
      return Math.abs(a) < Math.abs(b);
    });
    return ratios[0];
  }
  /**
   * Get a pointer from an event object.
   * @param {Object} event - The target event object.
   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
   * @returns {Object} The result pointer contains start and/or end point coordinates.
   */

  function getPointer(_ref2, endOnly) {
    var pageX = _ref2.pageX,
        pageY = _ref2.pageY;
    var end = {
      endX: pageX,
      endY: pageY
    };
    return endOnly ? end : assign({
      startX: pageX,
      startY: pageY
    }, end);
  }
  /**
   * Get the center point coordinate of a group of pointers.
   * @param {Object} pointers - The target pointers.
   * @returns {Object} The center point coordinate.
   */

  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    forEach(pointers, function (_ref3) {
      var startX = _ref3.startX,
          startY = _ref3.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {
      pageX: pageX,
      pageY: pageY
    };
  }
  /**
   * Get the max sizes in a rectangle under the given aspect ratio.
   * @param {Object} data - The original sizes.
   * @param {string} [type='contain'] - The adjust type.
   * @returns {Object} The result sizes.
   */

  function getAdjustedSizes(_ref4) // or 'cover'
  {
    var aspectRatio = _ref4.aspectRatio,
        height = _ref4.height,
        width = _ref4.width;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
    var isValidWidth = isPositiveNumber(width);
    var isValidHeight = isPositiveNumber(height);

    if (isValidWidth && isValidHeight) {
      var adjustedWidth = height * aspectRatio;

      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
        height = width / aspectRatio;
      } else {
        width = height * aspectRatio;
      }
    } else if (isValidWidth) {
      height = width / aspectRatio;
    } else if (isValidHeight) {
      width = height * aspectRatio;
    }

    return {
      width: width,
      height: height
    };
  }
  /**
   * Get the new sizes of a rectangle after rotated.
   * @param {Object} data - The original sizes.
   * @returns {Object} The result sizes.
   */

  function getRotatedSizes(_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        degree = _ref5.degree;
    degree = Math.abs(degree) % 180;

    if (degree === 90) {
      return {
        width: height,
        height: width
      };
    }

    var arc = degree % 90 * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var newWidth = width * cosArc + height * sinArc;
    var newHeight = width * sinArc + height * cosArc;
    return degree > 90 ? {
      width: newHeight,
      height: newWidth
    } : {
      width: newWidth,
      height: newHeight
    };
  }
  /**
   * Get a canvas which drew the given image.
   * @param {HTMLImageElement} image - The image for drawing.
   * @param {Object} imageData - The image data.
   * @param {Object} canvasData - The canvas data.
   * @param {Object} options - The options.
   * @returns {HTMLCanvasElement} The result canvas.
   */

  function getSourceCanvas(image, _ref6, _ref7, _ref8) {
    var imageAspectRatio = _ref6.aspectRatio,
        imageNaturalWidth = _ref6.naturalWidth,
        imageNaturalHeight = _ref6.naturalHeight,
        _ref6$rotate = _ref6.rotate,
        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
        _ref6$scaleX = _ref6.scaleX,
        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
        _ref6$scaleY = _ref6.scaleY,
        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
    var aspectRatio = _ref7.aspectRatio,
        naturalWidth = _ref7.naturalWidth,
        naturalHeight = _ref7.naturalHeight;
    var _ref8$fillColor = _ref8.fillColor,
        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
        _ref8$maxWidth = _ref8.maxWidth,
        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
        _ref8$maxHeight = _ref8.maxHeight,
        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
        _ref8$minWidth = _ref8.minWidth,
        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
        _ref8$minHeight = _ref8.minHeight,
        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

    var destMaxSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var destMinSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = fillColor;
    context.fillRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    context.rotate(rotate * Math.PI / 180);
    context.scale(scaleX, scaleY);
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    context.imageSmoothingQuality = imageSmoothingQuality;
    /**
     * ODOO FIX START
     *
     * Canevas is translated and then translated back. For the second translation the
     * translation distances were rounded to the nearest integer below when it should
     * not since the distances of the first translation are either an integer or the
     * half of an integer.
     *
     * Fix proposed by https://github.com/fengyuanchen/cropperjs/pull/866
     */
    params = params.map(normalizeDecimalNumber);
    context.drawImage(image, params[0], params[1], Math.floor(params[2]), Math.floor(params[3]));
    // ODOO FIX END
    context.restore();
    return canvas;
  }
  var fromCharCode = String.fromCharCode;
  /**
   * Get string from char code in data view.
   * @param {DataView} dataView - The data view for read.
   * @param {number} start - The start index.
   * @param {number} length - The read length.
   * @returns {string} The read result.
   */

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    length += start;

    for (var i = start; i < length; i += 1) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  /**
   * Transform Data URL to array buffer.
   * @param {string} dataURL - The Data URL to transform.
   * @returns {ArrayBuffer} The result array buffer.
   */

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var uint8 = new Uint8Array(arrayBuffer);
    forEach(uint8, function (value, i) {
      uint8[i] = binary.charCodeAt(i);
    });
    return arrayBuffer;
  }
  /**
   * Transform array buffer to Data URL.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
   * @param {string} mimeType - The mime type of the Data URL.
   * @returns {string} The result Data URL.
   */

  function arrayBufferToDataURL(arrayBuffer, mimeType) {
    var chunks = []; // Chunk Typed Array for better performance (#435)

    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);

    while (uint8.length > 0) {
      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
      // eslint-disable-next-line prefer-spread
      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
      uint8 = uint8.subarray(chunkSize);
    }

    return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
  }
  /**
   * Get orientation value from given array buffer.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
   * @returns {number} The read orientation value.
   */

  function resetAndGetOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var orientation; // Ignores range error when the image does not have correct Exif information

    try {
      var littleEndian;
      var app1Start;
      var ifdStart; // Only handle JPEG image (start by 0xFFD8)

      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;

        while (offset + 1 < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D
          /* bigEndian */
          ) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);

        var _offset;

        var i;

        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(_offset, littleEndian) === 0x0112
          /* Orientation */
          ) {
              // 8 is the offset of the current tag's value
              _offset += 8; // Get the original orientation value

              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    } catch (error) {
      orientation = 1;
    }

    return orientation;
  }
  /**
   * Parse Exif Orientation value.
   * @param {number} orientation - The orientation to parse.
   * @returns {Object} The parsed result.
   */

  function parseOrientation(orientation) {
    var rotate = 0;
    var scaleX = 1;
    var scaleY = 1;

    switch (orientation) {
      // Flip horizontal
      case 2:
        scaleX = -1;
        break;
      // Rotate left 180°

      case 3:
        rotate = -180;
        break;
      // Flip vertical

      case 4:
        scaleY = -1;
        break;
      // Flip vertical and rotate right 90°

      case 5:
        rotate = 90;
        scaleY = -1;
        break;
      // Rotate right 90°

      case 6:
        rotate = 90;
        break;
      // Flip horizontal and rotate right 90°

      case 7:
        rotate = 90;
        scaleX = -1;
        break;
      // Rotate left 90°

      case 8:
        rotate = -90;
        break;

      default:
    }

    return {
      rotate: rotate,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var render = {
    render: function render() {
      this.initContainer();
      this.initCanvas();
      this.initCropBox();
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    },
    initContainer: function initContainer() {
      var element = this.element,
          options = this.options,
          container = this.container,
          cropper = this.cropper;
      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);
      var containerData = {
        width: Math.max(container.offsetWidth, Number(options.minContainerWidth) || 200),
        height: Math.max(container.offsetHeight, Number(options.minContainerHeight) || 100)
      };
      this.containerData = containerData;
      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });
      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },
    // Canvas (image wrapper)
    initCanvas: function initCanvas() {
      var containerData = this.containerData,
          imageData = this.imageData;
      var viewMode = this.options.viewMode;
      var rotated = Math.abs(imageData.rotate) % 180 === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else if (viewMode === 3) {
        canvasHeight = containerData.width / aspectRatio;
      } else {
        canvasWidth = containerData.height * aspectRatio;
      }

      var canvasData = {
        aspectRatio: aspectRatio,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        width: canvasWidth,
        height: canvasHeight
      };
      canvasData.left = (containerData.width - canvasWidth) / 2;
      canvasData.top = (containerData.height - canvasHeight) / 2;
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      this.canvasData = canvasData;
      this.limited = viewMode === 1 || viewMode === 2;
      this.limitCanvas(true, true);
      this.initialImageData = assign({}, imageData);
      this.initialCanvasData = assign({}, canvasData);
    },
    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var viewMode = options.viewMode;
      var aspectRatio = canvasData.aspectRatio;
      var cropped = this.cropped && cropBoxData;

      if (sizeLimited) {
        var minCanvasWidth = Number(options.minCanvasWidth) || 0;
        var minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
          } else if (minCanvasHeight) {
            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio: aspectRatio,
          width: minCanvasWidth,
          height: minCanvasHeight
        });

        minCanvasWidth = _getAdjustedSizes.width;
        minCanvasHeight = _getAdjustedSizes.height;
        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode > (cropped ? 0 : 1)) {
          var newCanvasLeft = containerData.width - canvasData.width;
          var newCanvasTop = containerData.height - canvasData.height;
          canvasData.minLeft = Math.min(0, newCanvasLeft);
          canvasData.minTop = Math.min(0, newCanvasTop);
          canvasData.maxLeft = Math.max(0, newCanvasLeft);
          canvasData.maxTop = Math.max(0, newCanvasTop);

          if (cropped && this.limited) {
            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxTop = Math.max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },
    renderCanvas: function renderCanvas(changed, transformed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;

      if (transformed) {
        var _getRotatedSizes = getRotatedSizes({
          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
          degree: imageData.rotate || 0
        }),
            naturalWidth = _getRotatedSizes.width,
            naturalHeight = _getRotatedSizes.height;

        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
        canvasData.left -= (width - canvasData.width) / 2;
        canvasData.top -= (height - canvasData.height) / 2;
        canvasData.width = width;
        canvasData.height = height;
        canvasData.aspectRatio = naturalWidth / naturalHeight;
        canvasData.naturalWidth = naturalWidth;
        canvasData.naturalHeight = naturalHeight;
        this.limitCanvas(true, false);
      }

      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      this.limitCanvas(false, true);
      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      setStyle(this.canvas, assign({
        width: canvasData.width,
        height: canvasData.height
      }, getTransforms({
        translateX: canvasData.left,
        translateY: canvasData.top
      })));
      this.renderImage(changed);

      if (this.cropped && this.limited) {
        this.limitCropBox(true, true);
      }
    },
    renderImage: function renderImage(changed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;
      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
      assign(imageData, {
        width: width,
        height: height,
        left: (canvasData.width - width) / 2,
        top: (canvasData.height - height) / 2
      });
      setStyle(this.image, assign({
        width: imageData.width,
        height: imageData.height
      }, getTransforms(assign({
        translateX: imageData.left,
        translateY: imageData.top
      }, imageData))));

      if (changed) {
        this.output();
      }
    },
    initCropBox: function initCropBox() {
      var options = this.options,
          canvasData = this.canvasData;
      var aspectRatio = options.aspectRatio || options.initialAspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var cropBoxData = {
        width: canvasData.width,
        height: canvasData.height
      };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.cropBoxData = cropBoxData;
      this.limitCropBox(true, true); // Initialize auto crop area

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;
      this.initialCropBoxData = assign({}, cropBoxData);
    },
    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData,
          limited = this.limited;
      var aspectRatio = options.aspectRatio;

      if (sizeLimited) {
        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        } // The minWidth/Height must be less than maxWidth/Height


        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = Math.max(0, canvasData.left);
          cropBoxData.minTop = Math.max(0, canvasData.top);
          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },
    renderCropBox: function renderCropBox() {
      var options = this.options,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
      this.limitCropBox(false, true);
      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;

      if (options.movable && options.cropBoxMovable) {
        // Turn to move the canvas when the crop box is equal to the container
        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(this.cropBox, assign({
        width: cropBoxData.width,
        height: cropBoxData.height
      }, getTransforms({
        translateX: cropBoxData.left,
        translateY: cropBoxData.top
      })));

      if (this.cropped && this.limited) {
        this.limitCanvas(true, true);
      }

      if (!this.disabled) {
        this.output();
      }
    },
    output: function output() {
      this.preview();
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  };

  var preview = {
    initPreview: function initPreview() {
      var element = this.element,
          crossOrigin = this.crossOrigin;
      var preview = this.options.preview;
      var url = crossOrigin ? this.crossOriginUrl : this.url;
      var alt = element.alt || 'The image to preview';
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      image.alt = alt;
      this.viewBox.appendChild(image);
      this.viewBoxImage = image;

      if (!preview) {
        return;
      }

      var previews = preview;

      if (typeof preview === 'string') {
        previews = element.ownerDocument.querySelectorAll(preview);
      } else if (preview.querySelector) {
        previews = [preview];
      }

      this.previews = previews;
      forEach(previews, function (el) {
        var img = document.createElement('img'); // Save the original size for recover

        setData(el, DATA_PREVIEW, {
          width: el.offsetWidth,
          height: el.offsetHeight,
          html: el.innerHTML
        });

        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        img.src = url;
        img.alt = alt;
        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
        el.innerHTML = '';
        el.appendChild(img);
      });
    },
    resetPreview: function resetPreview() {
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        setStyle(element, {
          width: data.width,
          height: data.height
        });
        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },
    preview: function preview() {
      var imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var cropBoxWidth = cropBoxData.width,
          cropBoxHeight = cropBoxData.height;
      var width = imageData.width,
          height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;

      if (!this.cropped || this.disabled) {
        return;
      }

      setStyle(this.viewBoxImage, assign({
        width: width,
        height: height
      }, getTransforms(assign({
        translateX: -left,
        translateY: -top
      }, imageData))));
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });
        setStyle(element.getElementsByTagName('img')[0], assign({
          width: width * ratio,
          height: height * ratio
        }, getTransforms(assign({
          translateX: -left * ratio,
          translateY: -top * ratio
        }, imageData))));
      });
    }
  };

  var events = {
    bind: function bind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        addListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        addListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        addListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        addListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom);
      }

      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
      }

      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
      }
    },
    unbind: function unbind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        removeListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        removeListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        removeListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        removeListener(element, EVENT_ZOOM, options.zoom);
      }

      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, this.onWheel, {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
      }

      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, this.onResize);
      }
    }
  };

  var handlers = {
    resize: function resize() {
      var options = this.options,
          container = this.container,
          containerData = this.containerData;
      var minContainerWidth = Number(options.minContainerWidth) || MIN_CONTAINER_WIDTH;
      var minContainerHeight = Number(options.minContainerHeight) || MIN_CONTAINER_HEIGHT;

      if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {
        return;
      }

      var ratio = container.offsetWidth / containerData.width; // Resize when width changed or height changed

      if (ratio !== 1 || container.offsetHeight !== containerData.height) {
        var canvasData;
        var cropBoxData;

        if (options.restore) {
          canvasData = this.getCanvasData();
          cropBoxData = this.getCropBoxData();
        }

        this.render();

        if (options.restore) {
          this.setCanvasData(forEach(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          this.setCropBoxData(forEach(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },
    dblclick: function dblclick() {
      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
        return;
      }

      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
    },
    wheel: function wheel(event) {
      var _this = this;

      var ratio = Number(this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (this.disabled) {
        return;
      }

      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

      if (this.wheeling) {
        return;
      }

      this.wheeling = true;
      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (event.deltaY) {
        delta = event.deltaY > 0 ? 1 : -1;
      } else if (event.wheelDelta) {
        delta = -event.wheelDelta / 120;
      } else if (event.detail) {
        delta = event.detail > 0 ? 1 : -1;
      }

      this.zoom(-delta * ratio, event);
    },
    cropStart: function cropStart(event) {
      var buttons = event.buttons,
          button = event.button;

      if (this.disabled // No primary button (Usually the left button)
      // Note that touch events have no `buttons` or `button` property
      || isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
      || event.ctrlKey) {
        return;
      }

      var options = this.options,
          pointers = this.pointers;
      var action;

      if (event.changedTouches) {
        // Handle touch event
        forEach(event.changedTouches, function (touch) {
          pointers[touch.identifier] = getPointer(touch);
        });
      } else {
        // Handle mouse event and pointer event
        pointers[event.pointerId || 0] = getPointer(event);
      }

      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
        action = ACTION_ZOOM;
      } else {
        action = getData(event.target, DATA_ACTION);
      }

      if (!REGEXP_ACTIONS.test(action)) {
        return;
      }

      if (dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      } // This line is required for preventing page zooming in iOS browsers


      event.preventDefault();
      this.action = action;
      this.cropping = false;

      if (action === ACTION_CROP) {
        this.cropping = true;
        addClass(this.dragBox, CLASS_MODAL);
      }
    },
    cropMove: function cropMove(event) {
      var action = this.action;

      if (this.disabled || !action) {
        return;
      }

      var pointers = this.pointers;
      event.preventDefault();

      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      }

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          // The first parameter should not be undefined (#432)
          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
        });
      } else {
        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
      }

      this.change(event);
    },
    cropEnd: function cropEnd(event) {
      if (this.disabled) {
        return;
      }

      var action = this.action,
          pointers = this.pointers;

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          delete pointers[touch.identifier];
        });
      } else {
        delete pointers[event.pointerId || 0];
      }

      if (!action) {
        return;
      }

      event.preventDefault();

      if (!Object.keys(pointers).length) {
        this.action = '';
      }

      if (this.cropping) {
        this.cropping = false;
        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
      }

      dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: event,
        action: action
      });
    }
  };

  var change = {
    change: function change(event) {
      var options = this.options,
          canvasData = this.canvasData,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData,
          pointers = this.pointers;
      var action = this.action;
      var aspectRatio = options.aspectRatio;
      var left = cropBoxData.left,
          top = cropBoxData.top,
          width = cropBoxData.width,
          height = cropBoxData.height;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset; // Locking aspect ratio in "free mode" by holding shift key

      if (!aspectRatio && event.shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
      }

      var pointer = pointers[Object.keys(pointers)[0]];
      var range = {
        x: pointer.endX - pointer.startX,
        y: pointer.endY - pointer.startY
      };

      var check = function check(side) {
        switch (side) {
          case ACTION_EAST:
            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            break;

          case ACTION_WEST:
            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            break;

          case ACTION_NORTH:
            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            break;

          case ACTION_SOUTH:
            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            break;

          default:
        }
      };

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;
        // Resize crop box

        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;

          if (width < 0) {
            action = ACTION_WEST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;

          if (height < 0) {
            action = ACTION_SOUTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;

          if (width < 0) {
            action = ACTION_EAST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_SOUTH);
          height += range.y;

          if (height < 0) {
            action = ACTION_NORTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            check(ACTION_NORTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += cropBoxData.width - width;
          } else {
            check(ACTION_NORTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_EAST);
            width += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            top -= height;
          }

          break;
        // Move canvas

        case ACTION_MOVE:
          this.move(range.x, range.y);
          renderable = false;
          break;
        // Zoom canvas

        case ACTION_ZOOM:
          this.zoom(getMaxZoomRatio(pointers), event);
          renderable = false;
          break;
        // Create crop box

        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(this.cropper);
          left = pointer.startX - offset.left;
          top = pointer.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          } // Show the crop box if is hidden


          if (!this.cropped) {
            removeClass(this.cropBox, CLASS_HIDDEN);
            this.cropped = true;

            if (this.limited) {
              this.limitCropBox(true, true);
            }
          }

          break;

        default:
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        this.action = action;
        this.renderCropBox();
      } // Override


      forEach(pointers, function (p) {
        p.startX = p.endX;
        p.startY = p.endY;
      });
    }
  };

  var methods = {
    // Show the crop box manually
    crop: function crop() {
      if (this.ready && !this.cropped && !this.disabled) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
        this.setCropBoxData(this.initialCropBoxData);
      }

      return this;
    },
    // Reset the image and crop box to their initial states
    reset: function reset() {
      if (this.ready && !this.disabled) {
        this.imageData = assign({}, this.initialImageData);
        this.canvasData = assign({}, this.initialCanvasData);
        this.cropBoxData = assign({}, this.initialCropBoxData);
        this.renderCanvas();

        if (this.cropped) {
          this.renderCropBox();
        }
      }

      return this;
    },
    // Clear the crop box
    clear: function clear() {
      if (this.cropped && !this.disabled) {
        assign(this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true); // Render canvas after crop box rendered

        this.renderCanvas();
        removeClass(this.dragBox, CLASS_MODAL);
        addClass(this.cropBox, CLASS_HIDDEN);
      }

      return this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     * @param {string} url - The new URL.
     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
     * @returns {Cropper} this
     */
    replace: function replace(url) {
      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.disabled && url) {
        if (this.isImg) {
          this.element.src = url;
        }

        if (hasSameSize) {
          this.url = url;
          this.image.src = url;

          if (this.ready) {
            this.viewBoxImage.src = url;
            forEach(this.previews, function (element) {
              element.getElementsByTagName('img')[0].src = url;
            });
          }
        } else {
          if (this.isImg) {
            this.replaced = true;
          }

          this.options.data = null;
          this.uncreate();
          this.load(url);
        }
      }

      return this;
    },
    // Enable (unfreeze) the cropper
    enable: function enable() {
      if (this.ready && this.disabled) {
        this.disabled = false;
        removeClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },
    // Disable (freeze) the cropper
    disable: function disable() {
      if (this.ready && !this.disabled) {
        this.disabled = true;
        addClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },

    /**
     * Destroy the cropper and remove the instance from the image
     * @returns {Cropper} this
     */
    destroy: function destroy() {
      var element = this.element;

      if (!element[NAMESPACE]) {
        return this;
      }

      element[NAMESPACE] = undefined;

      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.uncreate();
      return this;
    },

    /**
     * Move the canvas with relative offsets
     * @param {number} offsetX - The relative offset distance on the x-axis.
     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
     * @returns {Cropper} this
     */
    move: function move(offsetX) {
      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
      var _this$canvasData = this.canvasData,
          left = _this$canvasData.left,
          top = _this$canvasData.top;
      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
    },

    /**
     * Move the canvas to an absolute point
     * @param {number} x - The x-axis coordinate.
     * @param {number} [y=x] - The y-axis coordinate.
     * @returns {Cropper} this
     */
    moveTo: function moveTo(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var canvasData = this.canvasData;
      var changed = false;
      x = Number(x);
      y = Number(y);

      if (this.ready && !this.disabled && this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          this.renderCanvas(true);
        }
      }

      return this;
    },

    /**
     * Zoom the canvas with a relative ratio
     * @param {number} ratio - The target ratio.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoom: function zoom(ratio, _originalEvent) {
      var canvasData = this.canvasData;
      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     * @param {number} ratio - The target ratio.
     * @param {Object} pivot - The zoom pivot point coordinate.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
      var options = this.options,
          canvasData = this.canvasData;
      var width = canvasData.width,
          height = canvasData.height,
          naturalWidth = canvasData.naturalWidth,
          naturalHeight = canvasData.naturalHeight;
      ratio = Number(ratio);

      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
        var newWidth = naturalWidth * ratio;
        var newHeight = naturalHeight * ratio;

        if (dispatchEvent(this.element, EVENT_ZOOM, {
          ratio: ratio,
          oldRatio: width / naturalWidth,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }

        if (_originalEvent) {
          var pointers = this.pointers;
          var offset = getOffset(this.cropper);
          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          }; // Zoom from the triggering point of the event

          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
        } else {
          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Rotate the canvas with a relative degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotate: function rotate(degree) {
      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotateTo: function rotateTo(degree) {
      degree = Number(degree);

      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
        this.imageData.rotate = degree % 360;
        this.renderCanvas(true, true);
      }

      return this;
    },

    /**
     * Scale the image on the x-axis.
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @returns {Cropper} this
     */
    scaleX: function scaleX(_scaleX) {
      var scaleY = this.imageData.scaleY;
      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the image on the y-axis.
     * @param {number} scaleY - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scaleY: function scaleY(_scaleY) {
      var scaleX = this.imageData.scaleX;
      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
    },

    /**
     * Scale the image
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scale: function scale(scaleX) {
      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
      var imageData = this.imageData;
      var transformed = false;
      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (this.ready && !this.disabled && this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          transformed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          transformed = true;
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }
      }

      return this;
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     * @param {boolean} [rounded=false] - Indicate if round the data values or not.
     * @returns {Object} The result cropped data.
     */
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
        var ratio = imageData.width / imageData.naturalWidth;
        forEach(data, function (n, i) {
          data[i] = n / ratio;
        });

        if (rounded) {
          // In case rounding off leads to extra 1px in right or bottom border
          // we should round the top-left corner and the dimension (#343).
          var bottom = Math.round(data.y + data.height);
          var right = Math.round(data.x + data.width);
          data.x = Math.round(data.x);
          data.y = Math.round(data.y);
          data.width = right - data.x;
          data.height = bottom - data.y;
        }
      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     * @param {Object} data - The new data.
     * @returns {Cropper} this
     */
    setData: function setData(data) {
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData;
      var cropBoxData = {};

      if (this.ready && !this.disabled && isPlainObject(data)) {
        var transformed = false;

        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            transformed = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            transformed = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            transformed = true;
          }
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }

        var ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        this.setCropBoxData(cropBoxData);
      }

      return this;
    },

    /**
     * Get the container size data.
     * @returns {Object} The result container data.
     */
    getContainerData: function getContainerData() {
      return this.ready ? assign({}, this.containerData) : {};
    },

    /**
     * Get the image position and size data.
     * @returns {Object} The result image data.
     */
    getImageData: function getImageData() {
      return this.sized ? assign({}, this.imageData) : {};
    },

    /**
     * Get the canvas position and size data.
     * @returns {Object} The result canvas data.
     */
    getCanvasData: function getCanvasData() {
      var canvasData = this.canvasData;
      var data = {};

      if (this.ready) {
        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data.
     * @param {Object} data - The new canvas data.
     * @returns {Cropper} this
     */
    setCanvasData: function setCanvasData(data) {
      var canvasData = this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (this.ready && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Get the crop box position and size data.
     * @returns {Object} The result crop box data.
     */
    getCropBoxData: function getCropBoxData() {
      var cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data.
     * @param {Object} data - The new crop box data.
     * @returns {Cropper} this
     */
    setCropBoxData: function setCropBoxData(data) {
      var cropBoxData = this.cropBoxData;
      var aspectRatio = this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width) && data.width !== cropBoxData.width) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height) && data.height !== cropBoxData.height) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        this.renderCropBox();
      }

      return this;
    },

    /**
     * Get a canvas drawn the cropped image.
     * @param {Object} [options={}] - The config options.
     * @returns {HTMLCanvasElement} - The result canvas.
     */
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.ready || !window.HTMLCanvasElement) {
        return null;
      }

      var canvasData = this.canvasData;
      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

      if (!this.cropped) {
        return source;
      }

      var _this$getData = this.getData(),
          initialX = _this$getData.x,
          initialY = _this$getData.y,
          initialWidth = _this$getData.width,
          initialHeight = _this$getData.height;

      var ratio = source.width / Math.floor(canvasData.naturalWidth);

      if (ratio !== 1) {
        initialX *= ratio;
        initialY *= ratio;
        initialWidth *= ratio;
        initialHeight *= ratio;
      }

      var aspectRatio = initialWidth / initialHeight;
      var maxSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.maxWidth || Infinity,
        height: options.maxHeight || Infinity
      });
      var minSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.minWidth || 0,
        height: options.minHeight || 0
      }, 'cover');

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.width || (ratio !== 1 ? source.width : initialWidth),
        height: options.height || (ratio !== 1 ? source.height : initialHeight)
      }),
          width = _getAdjustedSizes.width,
          height = _getAdjustedSizes.height;

      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = options.fillColor || 'transparent';
      context.fillRect(0, 0, width, height);
      var _options$imageSmoothi = options.imageSmoothingEnabled,
          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
          imageSmoothingQuality = options.imageSmoothingQuality;
      context.imageSmoothingEnabled = imageSmoothingEnabled;

      if (imageSmoothingQuality) {
        context.imageSmoothingQuality = imageSmoothingQuality;
      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


      var sourceWidth = source.width;
      var sourceHeight = source.height; // Source canvas parameters

      var srcX = initialX;
      var srcY = initialY;
      var srcWidth;
      var srcHeight; // Destination canvas parameters

      var dstX;
      var dstY;
      var dstWidth;
      var dstHeight;

      if (srcX <= -initialWidth || srcX > sourceWidth) {
        srcX = 0;
        srcWidth = 0;
        dstX = 0;
        dstWidth = 0;
      } else if (srcX <= 0) {
        dstX = -srcX;
        srcX = 0;
        srcWidth = Math.min(sourceWidth, initialWidth + srcX);
        dstWidth = srcWidth;
      } else if (srcX <= sourceWidth) {
        dstX = 0;
        srcWidth = Math.min(initialWidth, sourceWidth - srcX);
        dstWidth = srcWidth;
      }

      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
        srcY = 0;
        srcHeight = 0;
        dstY = 0;
        dstHeight = 0;
      } else if (srcY <= 0) {
        dstY = -srcY;
        srcY = 0;
        srcHeight = Math.min(sourceHeight, initialHeight + srcY);
        dstHeight = srcHeight;
      } else if (srcY <= sourceHeight) {
        dstY = 0;
        srcHeight = Math.min(initialHeight, sourceHeight - srcY);
        dstHeight = srcHeight;
      }

      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

      if (dstWidth > 0 && dstHeight > 0) {
        var scale = width / initialWidth;
        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
      } // All the numerical parameters should be integer for `drawImage`
      // https://github.com/fengyuanchen/cropper/issues/476


      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box.
     * @param {number} aspectRatio - The new aspect ratio.
     * @returns {Cropper} this
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      var options = this.options;

      if (!this.disabled && !isUndefined(aspectRatio)) {
        // 0 -> NaN
        options.aspectRatio = Math.max(0, aspectRatio) || NaN;

        if (this.ready) {
          this.initCropBox();

          if (this.cropped) {
            this.renderCropBox();
          }
        }
      }

      return this;
    },

    /**
     * Change the drag mode.
     * @param {string} mode - The new drag mode.
     * @returns {Cropper} this
     */
    setDragMode: function setDragMode(mode) {
      var options = this.options,
          dragBox = this.dragBox,
          face = this.face;

      if (this.ready && !this.disabled) {
        var croppable = mode === DRAG_MODE_CROP;
        var movable = options.movable && mode === DRAG_MODE_MOVE;
        mode = croppable || movable ? mode : DRAG_MODE_NONE;
        options.dragMode = mode;
        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {
          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return this;
    }
  };

  var AnotherCropper = WINDOW.Cropper;

  var Cropper =
  /*#__PURE__*/
  function () {
    /**
     * Create a new Cropper.
     * @param {Element} element - The target element for cropping.
     * @param {Object} [options={}] - The configuration options.
     */
    function Cropper(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Cropper);

      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
        throw new Error('The first argument is required and must be an <img> or <canvas> element.');
      }

      this.element = element;
      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
      this.cropped = false;
      this.disabled = false;
      this.pointers = {};
      this.ready = false;
      this.reloading = false;
      this.replaced = false;
      this.sized = false;
      this.sizing = false;
      this.init();
    }

    _createClass(Cropper, [{
      key: "init",
      value: function init() {
        var element = this.element;
        var tagName = element.tagName.toLowerCase();
        var url;

        if (element[NAMESPACE]) {
          return;
        }

        element[NAMESPACE] = this;

        if (tagName === 'img') {
          this.isImg = true; // e.g.: "img/picture.jpg"

          url = element.getAttribute('src') || '';
          this.originalUrl = url; // Stop when it's a blank image

          if (!url) {
            return;
          } // e.g.: "http://example.com/img/picture.jpg"


          url = element.src;
        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
          url = element.toDataURL();
        }

        this.load(url);
      }
    }, {
      key: "load",
      value: function load(url) {
        var _this = this;

        if (!url) {
          return;
        }

        this.url = url;
        this.imageData = {};
        var element = this.element,
            options = this.options;

        if (!options.rotatable && !options.scalable) {
          options.checkOrientation = false;
        } // Only IE10+ supports Typed Arrays


        if (!options.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        } // Detect the mime type of the image directly if it is a Data URL


        if (REGEXP_DATA_URL.test(url)) {
          // Read ArrayBuffer from Data URL of JPEG images directly for better performance
          if (REGEXP_DATA_URL_JPEG.test(url)) {
            this.read(dataURLToArrayBuffer(url));
          } else {
            // Only a JPEG image may contains Exif Orientation information,
            // the rest types of Data URLs are not necessary to check orientation at all.
            this.clone();
          }

          return;
        } // 1. Detect the mime type of the image by a XMLHttpRequest.
        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


        var xhr = new XMLHttpRequest();
        var clone = this.clone.bind(this);
        this.reloading = true;
        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
        // http, https, data, chrome, chrome-extension.
        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
        // in some browsers as IE11 and Safari.

        xhr.onabort = clone;
        xhr.onerror = clone;
        xhr.ontimeout = clone;

        xhr.onprogress = function () {
          // Abort the request directly if it not a JPEG image for better performance
          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
            xhr.abort();
          }
        };

        xhr.onload = function () {
          _this.read(xhr.response);
        };

        xhr.onloadend = function () {
          _this.reloading = false;
          _this.xhr = null;
        }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
          url = addTimestamp(url);
        }

        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    }, {
      key: "read",
      value: function read(arrayBuffer) {
        var options = this.options,
            imageData = this.imageData; // Reset the orientation value to its default value 1
        // as some iOS browsers will render image with its orientation

        var orientation = resetAndGetOrientation(arrayBuffer);
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;

        if (orientation > 1) {
          // Generate a new URL which has the default orientation value
          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

          var _parseOrientation = parseOrientation(orientation);

          rotate = _parseOrientation.rotate;
          scaleX = _parseOrientation.scaleX;
          scaleY = _parseOrientation.scaleY;
        }

        if (options.rotatable) {
          imageData.rotate = rotate;
        }

        if (options.scalable) {
          imageData.scaleX = scaleX;
          imageData.scaleY = scaleY;
        }

        this.clone();
      }
    }, {
      key: "clone",
      value: function clone() {
        var element = this.element,
            url = this.url;
        var crossOrigin = element.crossOrigin;
        var crossOriginUrl = url;

        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
          if (!crossOrigin) {
            crossOrigin = 'anonymous';
          } // Bust cache when there is not a "crossOrigin" property (#519)


          crossOriginUrl = addTimestamp(url);
        }

        this.crossOrigin = crossOrigin;
        this.crossOriginUrl = crossOriginUrl;
        var image = document.createElement('img');

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = crossOriginUrl || url;
        image.alt = element.alt || 'The image to crop';
        this.image = image;
        image.onload = this.start.bind(this);
        image.onerror = this.stop.bind(this);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        var image = this.image;
        image.onload = null;
        image.onerror = null;
        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
        // such as Safari for iOS, Chrome for iOS, and in-app browsers.

        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

        var done = function done(naturalWidth, naturalHeight) {
          assign(_this2.imageData, {
            naturalWidth: naturalWidth,
            naturalHeight: naturalHeight,
            aspectRatio: naturalWidth / naturalHeight
          });
          _this2.sizing = false;
          _this2.sized = true;

          _this2.build();
        }; // Most modern browsers (excepts iOS WebKit)


        if (image.naturalWidth && !isIOSWebKit) {
          done(image.naturalWidth, image.naturalHeight);
          return;
        }

        var sizingImage = document.createElement('img');
        var body = document.body || document.documentElement;
        this.sizingImage = sizingImage;

        sizingImage.onload = function () {
          done(sizingImage.width, sizingImage.height);

          if (!isIOSWebKit) {
            body.removeChild(sizingImage);
          }
        };

        sizingImage.src = image.src; // iOS WebKit will convert the image automatically
        // with its orientation once append it into DOM (#279)

        if (!isIOSWebKit) {
          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
          body.appendChild(sizingImage);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        var image = this.image;
        image.onload = null;
        image.onerror = null;
        image.parentNode.removeChild(image);
        this.image = null;
      }
    }, {
      key: "build",
      value: function build() {
        if (!this.sized || this.ready) {
          return;
        }

        var element = this.element,
            options = this.options,
            image = this.image; // Create cropper elements

        var container = element.parentNode;
        var template = document.createElement('div');
        template.innerHTML = TEMPLATE;
        var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
        var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
        var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
        var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
        var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = container;
        this.cropper = cropper;
        this.canvas = canvas;
        this.dragBox = dragBox;
        this.cropBox = cropBox;
        this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
        this.face = face;
        canvas.appendChild(image); // Hide the original image

        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

        if (!this.isImg) {
          removeClass(image, CLASS_HIDE);
        }

        this.initPreview();
        this.bind();
        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
        addClass(cropBox, CLASS_HIDDEN);

        if (!options.guides) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
        }

        if (!options.center) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
        }

        if (options.background) {
          addClass(cropper, "".concat(NAMESPACE, "-bg"));
        }

        if (!options.highlight) {
          addClass(face, CLASS_INVISIBLE);
        }

        if (options.cropBoxMovable) {
          addClass(face, CLASS_MOVE);
          setData(face, DATA_ACTION, ACTION_ALL);
        }

        if (!options.cropBoxResizable) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
        }

        this.render();
        this.ready = true;
        this.setDragMode(options.dragMode);

        if (options.autoCrop) {
          this.crop();
        }

        this.setData(options.data);

        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
      }
    }, {
      key: "unbuild",
      value: function unbuild() {
        if (!this.ready) {
          return;
        }

        this.ready = false;
        this.unbind();
        this.resetPreview();
        this.cropper.parentNode.removeChild(this.cropper);
        removeClass(this.element, CLASS_HIDDEN);
      }
    }, {
      key: "uncreate",
      value: function uncreate() {
        if (this.ready) {
          this.unbuild();
          this.ready = false;
          this.cropped = false;
        } else if (this.sizing) {
          this.sizingImage.onload = null;
          this.sizing = false;
          this.sized = false;
        } else if (this.reloading) {
          this.xhr.onabort = null;
          this.xhr.abort();
        } else if (this.image) {
          this.stop();
        }
      }
      /**
       * Get the no conflict cropper class.
       * @returns {Cropper} The cropper class.
       */

    }], [{
      key: "noConflict",
      value: function noConflict() {
        window.Cropper = AnotherCropper;
        return Cropper;
      }
      /**
       * Change the default options.
       * @param {Object} options - The new default options.
       */

    }, {
      key: "setDefaults",
      value: function setDefaults(options) {
        assign(DEFAULTS, isPlainObject(options) && options);
      }
    }]);

    return Cropper;
  }();

  assign(Cropper.prototype, render, preview, events, handlers, change, methods);

  return Cropper;

}));
;

/**********************************************************************
*  Filepath: /web_editor/static/lib/jquery-cropper/jquery-cropper.js  *
*  Lines: 75                                                          *
**********************************************************************/
/*!
 * jQuery Cropper v1.0.0
 * https://github.com/fengyuanchen/jquery-cropper
 *
 * Copyright (c) 2018 Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2018-04-01T06:20:13.168Z
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery'), require('cropperjs')) :
    typeof define === 'function' && define.amd ? define(['jquery', 'cropperjs'], factory) :
    (factory(global.jQuery,global.Cropper));
  }(this, (function ($,Cropper) { 'use strict';

    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
    Cropper = Cropper && Cropper.hasOwnProperty('default') ? Cropper['default'] : Cropper;

    if ($.fn) {
      var AnotherCropper = $.fn.cropper;
      var NAMESPACE = 'cropper';

      $.fn.cropper = function jQueryCropper(option) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var result = void 0;

        this.each(function (i, element) {
          var $element = $(element);
          var isDestroy = option === 'destroy';
          var cropper = $element.data(NAMESPACE);

          if (!cropper) {
            if (isDestroy) {
              return;
            }

            var options = $.extend({}, $element.data(), $.isPlainObject(option) && option);

            cropper = new Cropper(element, options);
            $element.data(NAMESPACE, cropper);
          }

          if (typeof option === 'string') {
            var fn = cropper[option];

            if ($.isFunction(fn)) {
              result = fn.apply(cropper, args);

              if (result === cropper) {
                result = undefined;
              }

              if (isDestroy) {
                $element.removeData(NAMESPACE);
              }
            }
          }
        });

        return result !== undefined ? result : this;
      };

      $.fn.cropper.Constructor = Cropper;
      $.fn.cropper.setDefaults = Cropper.setDefaults;
      $.fn.cropper.noConflict = function noConflict() {
        $.fn.cropper = AnotherCropper;
        return this;
      };
    }

  })));
;

/*******************************************************
*  Filepath: /web_editor/static/lib/jQuery.transfo.js  *
*  Lines: 454                                          *
*******************************************************/
/*
Copyright (c) 2014 Christophe Matthieu,

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

(function($){
    'use strict';
        var rad = Math.PI/180;

        // public methods
        var methods = {
                init : function(settings) {
                    return this.each(function() {
                        var $this = $(this), transfo = $this.data('transfo');
                        if (!transfo) {
                            _init($this, settings);
                        } else {
                            _overwriteOptions($this, transfo, settings);
                            _targetCss($this, transfo);
                        }
                    });
                },

                destroy : function() {
                    return this.each(function() {
                        var $this = $(this);
                        if ($this.data('transfo')) {
                            _destroy($this);
                        }
                    });
                },

                reset : function() {
                    return this.each(function() {
                        var $this = $(this);
                        if ($this.data('transfo')) {
                            _reset($this);
                        }
                    });
                },

                toggle : function() {
                    return this.each(function() {
                        var $this = $(this);
                        var transfo = $this.data('transfo');
                        if (transfo) {
                            transfo.settings.hide = !transfo.settings.hide;
                            _showHide($this, transfo);
                        }
                    });
                },

                hide : function() {
                    return this.each(function() {
                        var $this = $(this);
                        var transfo = $this.data('transfo');
                        if (transfo) {
                            transfo.settings.hide = true;
                            _showHide($this, transfo);
                        }
                    });
                },

                show : function() {
                    return this.each(function() {
                        var $this = $(this);
                        var transfo = $this.data('transfo');
                        if (transfo) {
                            transfo.settings.hide = false;
                            _showHide($this, transfo);
                        }
                    });
                },

                settings :  function() {
                    if(this.length > 1) {
                        this.map(function () {
                            var $this = $(this);
                            return $this.data('transfo') && $this.data('transfo').settings;
                        });
                    }
                    return this.data('transfo') && $this.data('transfo').settings;
                },
                center :  function() {
                    if(this.length > 1) {
                        this.map(function () {
                            var $this = $(this);
                            return $this.data('transfo') && $this.data('transfo').$center.offset();
                        });
                    }
                    return this.data('transfo') && this.data('transfo').$center.offset();
                }
        };

        $.fn.transfo = function( method ) {
            if ( methods[method] ) {
                    return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
            } else if ( typeof method === 'object' || ! method ) {
                    return methods.init.apply( this, arguments );
            } else {
                    $.error( 'Method ' +  method + ' does not exist on jQuery.transfo' );
            }
            return false;
        };

        function _init ($this, settings) {
            var transfo = {};
            $this.data('transfo', transfo);
            transfo.settings = settings;
            transfo.settings.document = transfo.settings.document || document;

            // generate all the controls markup
            var css = "box-sizing: border-box; position: absolute; background-color: #fff; border: 1px solid #ccc; width: 8px; height: 8px; margin-left: -4px; margin-top: -4px;";
            transfo.$markup = $(''
                + '<div class="transfo-container">'
                +  '<div class="transfo-controls">'
                +   '<div style="cursor: crosshair; position: absolute; margin: -30px; top: 0; right: 0; padding: 1px 0 0 1px;" class="transfo-rotator">'
                +    '<span class="fa-stack fa-lg">'
                +    '<i class="fa fa-circle fa-stack-2x"></i>'
                +    '<i class="fa fa-repeat fa-stack-1x fa-inverse"></i>'
                +    '</span>'
                +   '</div>'
                +   '<div style="' + css + 'top: 0%; left: 0%; cursor: nw-resize;" class="transfo-scaler-tl"></div>'
                +   '<div style="' + css + 'top: 0%; left: 100%; cursor: ne-resize;" class="transfo-scaler-tr"></div>'
                +   '<div style="' + css + 'top: 100%; left: 100%; cursor: se-resize;" class="transfo-scaler-br"></div>'
                +   '<div style="' + css + 'top: 100%; left: 0%; cursor: sw-resize;" class="transfo-scaler-bl"></div>'
                +   '<div style="' + css + 'top: 0%; left: 50%; cursor: n-resize;" class="transfo-scaler-tc"></div>'
                +   '<div style="' + css + 'top: 100%; left: 50%; cursor: s-resize;" class="transfo-scaler-bc"></div>'
                +   '<div style="' + css + 'top: 50%; left: 0%; cursor: w-resize;" class="transfo-scaler-ml"></div>'
                +   '<div style="' + css + 'top: 50%; left: 100%; cursor: e-resize;" class="transfo-scaler-mr"></div>'
                +   '<div style="' + css + 'border: 0; width: 0px; height: 0px; top: 50%; left: 50%;" class="transfo-scaler-mc"></div>'
                +  '</div>'
                + '</div>');
            transfo.$center = transfo.$markup.find(".transfo-scaler-mc");

            // init setting and get css to set wrap
            _setOptions($this, transfo);
            _overwriteOptions ($this, transfo, settings);

            // append controls to container
            $(transfo.settings.document.body).append(transfo.$markup);

            // set transfo container and markup
            setTimeout(function () {
                _targetCss($this, transfo);
            },0);

            _bind($this, transfo);
            
            _targetCss($this, transfo);
            _stop_animation($this[0]);
        }

        function _overwriteOptions ($this, transfo, settings) {
            transfo.settings = $.extend(transfo.settings, settings || {});
        }

        function _stop_animation (target) {
            target.style.webkitAnimationPlayState = "paused";
            target.style.animationPlayState = "paused";
            target.style.webkitTransition = "none";
            target.style.transition = "none";
        }

        function _setOptions ($this, transfo) {
            var style = $this.attr("style") || "";
            var transform = style.match(/transform\s*:([^;]+)/) ? style.match(/transform\s*:([^;]+)/)[1] : "";

            transfo.settings = {};

            transfo.settings.angle=      transform.indexOf('rotate') != -1 ? parseFloat(transform.match(/rotate\(([^)]+)deg\)/)[1]) : 0;
            transfo.settings.scalex=     transform.indexOf('scaleX') != -1 ? parseFloat(transform.match(/scaleX\(([^)]+)\)/)[1]) : 1;
            transfo.settings.scaley=     transform.indexOf('scaleY') != -1 ? parseFloat(transform.match(/scaleY\(([^)]+)\)/)[1]) : 1;

            transfo.settings.style = style.replace(/[^;]*transform[^;]+/g, '').replace(/;+/g, ';');

            $this.attr("style", transfo.settings.style);
            _stop_animation($this[0]);
            transfo.settings.pos = $this.offset();

            transfo.settings.height = $this.innerHeight();
            transfo.settings.width = $this.innerWidth();

            var translatex = transform.match(/translateX\(([0-9.-]+)(%|px)\)/);
            var translatey = transform.match(/translateY\(([0-9.-]+)(%|px)\)/);
            transfo.settings.translate = "%";

            if (translatex && translatex[2] === "%") {
                transfo.settings.translatexp = parseFloat(translatex[1]);
                transfo.settings.translatex = transfo.settings.translatexp / 100 * transfo.settings.width;
            } else {
                transfo.settings.translatex = translatex ? parseFloat(translatex[1]) : 0;
            }
            if (translatey && translatey[2] === "%") {
                transfo.settings.translateyp = parseFloat(translatey[1]);
                transfo.settings.translatey = transfo.settings.translateyp / 100 * transfo.settings.height;
            } else {
                transfo.settings.translatey = translatey ? parseFloat(translatey[1]) : 0;
            }

            transfo.settings.css = window.getComputedStyle($this[0], null);

            transfo.settings.rotationStep = 5;
            transfo.settings.hide = false;
            transfo.settings.callback = function () {};
        }

        function _bind ($this, transfo) {
            function mousedown (event) {
                _mouseDown($this, this, transfo, event);
                $(transfo.settings.document).on("mousemove", mousemove).on("mouseup", mouseup);
            }
            function mousemove (event) {
                _mouseMove($this, this, transfo, event);
            }
            function mouseup (event) {
                _mouseUp($this, this, transfo, event);
                $(transfo.settings.document).off("mousemove", mousemove).off("mouseup", mouseup);
            }

            transfo.$markup.off().on("mousedown", mousedown);
            transfo.$markup.find(".transfo-controls >:not(.transfo-scaler-mc)").off().on("mousedown", mousedown);
        }

        function _mouseDown($this, div, transfo, event) {
            event.preventDefault();
            if (transfo.active || event.which !== 1) return;

            var type = "position", $e = $(div);
            if ($e.hasClass("transfo-rotator")) type = "rotator";
            else if ($e.hasClass("transfo-scaler-tl")) type = "tl";
            else if ($e.hasClass("transfo-scaler-tr")) type = "tr";
            else if ($e.hasClass("transfo-scaler-br")) type = "br";
            else if ($e.hasClass("transfo-scaler-bl")) type = "bl";
            else if ($e.hasClass("transfo-scaler-tc")) type = "tc";
            else if ($e.hasClass("transfo-scaler-bc")) type = "bc";
            else if ($e.hasClass("transfo-scaler-ml")) type = "ml";
            else if ($e.hasClass("transfo-scaler-mr")) type = "mr";

            transfo.active = {
                "type": type,
                "scalex": transfo.settings.scalex,
                "scaley": transfo.settings.scaley,
                "pageX": event.pageX,
                "pageY": event.pageY,
                "center": transfo.$center.offset(),
            };
        }
        function _mouseUp($this, div, transfo, event) {
            transfo.active = null;
        }

        function _mouseMove($this, div, transfo, event) {
            event.preventDefault();
            if (!transfo.active) return;
            var settings = transfo.settings;
            var center = transfo.active.center;
            var cdx = center.left - event.pageX;
            var cdy = center.top - event.pageY;

            if (transfo.active.type == "rotator") {
                var ang, dang = Math.atan((settings.width * settings.scalex) / (settings.height * settings.scaley)) / rad;

                if (cdy) ang = Math.atan(- cdx / cdy) / rad;
                else ang = 0;
                if (event.pageY >= center.top && event.pageX >= center.left) ang += 180;
                else if (event.pageY >= center.top && event.pageX < center.left) ang += 180;
                else if (event.pageY < center.top && event.pageX < center.left) ang += 360;
                
                ang -= dang;
                if (settings.scaley < 0 && settings.scalex < 0) ang += 180;

                if (!event.ctrlKey) {
                    settings.angle = Math.round(ang / transfo.settings.rotationStep) * transfo.settings.rotationStep;
                } else {
                    settings.angle = ang;
                }

                // reset position : don't move center
                _targetCss($this, transfo);
                var new_center = transfo.$center.offset();
                var x = center.left - new_center.left;
                var y = center.top - new_center.top;
                var angle = ang * rad;
                settings.translatex += x*Math.cos(angle) - y*Math.sin(-angle);
                settings.translatey += - x*Math.sin(angle) + y*Math.cos(-angle);
            }
            else if (transfo.active.type == "position") {
                var angle = settings.angle * rad;
                var x = event.pageX - transfo.active.pageX;
                var y = event.pageY - transfo.active.pageY;
                transfo.active.pageX = event.pageX;
                transfo.active.pageY = event.pageY;
                var dx = x*Math.cos(angle) - y*Math.sin(-angle);
                var dy = - x*Math.sin(angle) + y*Math.cos(-angle);

                settings.translatex += dx;
                settings.translatey += dy;
            }
            else if (transfo.active.type.length === 2) {
                var angle = settings.angle * rad;
                var dx =   cdx*Math.cos(angle) - cdy*Math.sin(-angle);
                var dy = - cdx*Math.sin(angle) + cdy*Math.cos(-angle);
                if (transfo.active.type.indexOf("t") != -1) {
                    settings.scaley = dy / (settings.height/2);
                }
                if (transfo.active.type.indexOf("b") != -1) {
                    settings.scaley = - dy / (settings.height/2);
                }
                if (transfo.active.type.indexOf("l") != -1) {
                    settings.scalex = dx / (settings.width/2);
                }
                if (transfo.active.type.indexOf("r") != -1) {
                    settings.scalex = - dx / (settings.width/2);
                }
                if (settings.scaley > 0 && settings.scaley < 0.05) settings.scaley = 0.05;
                if (settings.scalex > 0 && settings.scalex < 0.05) settings.scalex = 0.05;
                if (settings.scaley < 0 && settings.scaley > -0.05) settings.scaley = -0.05;
                if (settings.scalex < 0 && settings.scalex > -0.05) settings.scalex = -0.05;

                if (event.shiftKey &&
                    (transfo.active.type === "tl" || transfo.active.type === "bl" ||
                     transfo.active.type === "tr" || transfo.active.type === "br")) {
                    settings.scaley = settings.scalex;
                }
            }

            settings.angle = Math.round(settings.angle);
            settings.translatex = Math.round(settings.translatex);
            settings.translatey = Math.round(settings.translatey);
            settings.scalex = Math.round(settings.scalex*100)/100;
            settings.scaley = Math.round(settings.scaley*100)/100;

            _targetCss($this, transfo);
            _stop_animation($this[0]);
            return false;
        }

        function _setCss($this, css, settings) {
            var transform = "";
            var trans = false;
            if (settings.angle !== 0) {
                trans = true;
                transform += " rotate("+settings.angle+"deg) ";
            }
            if (settings.translatex) {
                trans = true;
                transform += " translateX("+(settings.translate === "%" ? settings.translatexp+"%" : settings.translatex+"px")+") ";
            }
            if (settings.translatey) {
                trans = true;
                transform += " translateY("+(settings.translate === "%" ? settings.translateyp+"%" : settings.translatey+"px")+") ";
            }
            if (settings.scalex != 1) {
                trans = true;
                transform += " scaleX("+settings.scalex+") ";
            }
            if (settings.scaley != 1){
                trans = true;
                transform += " scaleY("+settings.scaley+") ";
            }

            if (trans) {
                css += ";"
                        /* Safari */
                css += "-webkit-transform:" + transform + ";"
                        /* Firefox */
                    + "-moz-transform:" + transform + ";"
                        /* IE */
                    + "-ms-transform:" + transform + ";"
                        /* Opera */
                    + "-o-transform:" + transform + ";"
                        /* Other */
                    + "transform:" + transform + ";";
            }

            css = css.replace(/(\s*;)+/g, ';').replace(/^\s*;|;\s*$/g, '');

            $this.attr("style", css);
        }

        function _targetCss ($this, transfo) {
            var settings = transfo.settings;
            var width = parseFloat(settings.css.width);
            var height = parseFloat(settings.css.height);
            settings.translatexp = Math.round(settings.translatex/width*1000)/10;
            settings.translateyp = Math.round(settings.translatey/height*1000)/10;

            _setCss($this, settings.style, settings);

            transfo.$markup.css({
                "position": "absolute",
                "width": width + "px",
                "height": height + "px",
                "top": settings.pos.top + "px",
                "left": settings.pos.left + "px"
            });

            var $controls = transfo.$markup.find('.transfo-controls');
            _setCss($controls,
                "width:" + width + "px;" +
                "height:" + height + "px;" +
                "cursor: move;",
                settings);

            $controls.children().css("transform", "scaleX("+(1/settings.scalex)+") scaleY("+(1/settings.scaley)+")");

            _showHide($this, transfo);

            transfo.settings.callback.call($this[0], $this);
        }

        function _showHide ($this, transfo) {
            transfo.$markup.css("z-index", transfo.settings.hide ? -1 : 1000);
            if (transfo.settings.hide) {
                transfo.$markup.find(".transfo-controls > *").hide();
                transfo.$markup.find(".transfo-scaler-mc").show();
            } else {
                transfo.$markup.find(".transfo-controls > *").show();
            }
        }

        function _destroy ($this) {
            $this.data('transfo').$markup.remove();
            $this.removeData('transfo');
        }

        function _reset ($this) {
            var transfo = $this.data('transfo');
            _destroy($this);
            $this.transfo(transfo.settings);
        }

})(jQuery);
;

/******************************************************************************
*  Filepath: /web_editor/static/lib/webgl-image-filter/webgl-image-filter.js  *
*  Lines: 640                                                                 *
******************************************************************************/
/* 
WebGLImageFilter - MIT Licensed

2013, Dominic Szablewski - phoboslab.org
*/

(function(window){

var WebGLProgram = function( gl, vertexSource, fragmentSource ) {

	var _collect = function( source, prefix, collection ) {
		var r = new RegExp('\\b' + prefix + ' \\w+ (\\w+)', 'ig');
		source.replace(r, function(match, name) {
			collection[name] = 0;
			return match;
		});
	};

	var _compile = function( gl, source, type ) {
		var shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);

		if( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) {
			console.log(gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	};


	this.uniform = {};
	this.attribute = {};

	var _vsh = _compile(gl, vertexSource, gl.VERTEX_SHADER);
	var _fsh = _compile(gl, fragmentSource, gl.FRAGMENT_SHADER);

	this.id = gl.createProgram();
	gl.attachShader(this.id, _vsh);
	gl.attachShader(this.id, _fsh);
	gl.linkProgram(this.id);

	if( !gl.getProgramParameter(this.id, gl.LINK_STATUS) ) {
		console.log(gl.getProgramInfoLog(this.id));
	}

	gl.useProgram(this.id);

	// Collect attributes
	_collect(vertexSource, 'attribute', this.attribute);
	for( var a in this.attribute ) {
		this.attribute[a] = gl.getAttribLocation(this.id, a);
	}

	// Collect uniforms
	_collect(vertexSource, 'uniform', this.uniform);
	_collect(fragmentSource, 'uniform', this.uniform);
	for( var u in this.uniform ) {
		this.uniform[u] = gl.getUniformLocation(this.id, u);
	}
};

const identityMatrix = [
	1, 0, 0, 0, 0,
	0, 1, 0, 0, 0,
	0, 0, 1, 0, 0,
	0, 0, 0, 1, 0,
];

const weightedAvg = (a, b, w) => a * w + b * (1 - w);

var WebGLImageFilter = window.WebGLImageFilter = function (params) {
	if (!params)
		params = { };

	var 
		gl = null,
		_drawCount = 0,
		_sourceTexture = null,
		_lastInChain = false,
		_currentFramebufferIndex = -1,
		_tempFramebuffers = [null, null],
		_filterChain = [],
		_width = -1, 
		_height = -1,
		_vertexBuffer = null,
		_currentProgram = null,
		_canvas = params.canvas || document.createElement('canvas');

	// key is the shader program source, value is the compiled program
	var _shaderProgramCache = { };

	var gl = _canvas.getContext("webgl") || _canvas.getContext("experimental-webgl");
	if( !gl ) {
		throw "Couldn't get WebGL context";
	}

	
	this.addFilter = function( name ) {
		var args = Array.prototype.slice.call(arguments, 1);
		var filter = _filter[name];

		_filterChain.push({func:filter, args:args});
	};

	this.reset = function() {
		_filterChain = [];
	};
	
	this.apply = function( image ) {
		_resize( image.width, image.height );
		_drawCount = 0;

		// Create the texture for the input image if we haven't yet
		if (!_sourceTexture)
			_sourceTexture = gl.createTexture();

		gl.bindTexture(gl.TEXTURE_2D, _sourceTexture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); 
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

		// No filters? Just draw
		if( _filterChain.length == 0 ) {
			var program = _compileShader(SHADER.FRAGMENT_IDENTITY);
			_draw();
			return _canvas;
		}

		for( var i = 0; i < _filterChain.length; i++ ) {
			_lastInChain = (i == _filterChain.length-1);
			var f = _filterChain[i];

			f.func.apply(this, f.args || []);
		}

		return _canvas;
	};

	var _resize = function( width, height ) {
		// Same width/height? Nothing to do here
		if( width == _width && height == _height ) { return; }


		_canvas.width = _width = width;
		_canvas.height = _height = height;

		// Create the context if we don't have it yet
		if( !_vertexBuffer ) {
			// Create the vertex buffer for the two triangles [x, y, u, v] * 6
			var vertices = new Float32Array([
				-1, -1, 0, 1,  1, -1, 1, 1,  -1, 1, 0, 0,
				-1, 1, 0, 0,  1, -1, 1, 1,  1, 1, 1, 0
			]);
			_vertexBuffer = gl.createBuffer(),
			gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

			// Note sure if this is a good idea; at least it makes texture loading
			// in Ejecta instant.
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
		}

		gl.viewport(0, 0, _width, _height);

		// Delete old temp framebuffers
		_tempFramebuffers = [null, null];
	};

	var _getTempFramebuffer = function( index ) {
		_tempFramebuffers[index] = 
			_tempFramebuffers[index] || 
			_createFramebufferTexture( _width, _height );

		return _tempFramebuffers[index];
	};

	var _createFramebufferTexture = function( width, height ) {
		var fbo = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

		var renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);

		var texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		return {fbo: fbo, texture: texture};
	};

	var _draw = function( flags ) {
		var source = null, 
			target = null,
			flipY = false;

		// Set up the source
		if( _drawCount == 0 ) {
			// First draw call - use the source texture
			source = _sourceTexture;
		}
		else {
			// All following draw calls use the temp buffer last drawn to
			source =  _getTempFramebuffer(_currentFramebufferIndex).texture;
		}
		_drawCount++;


		// Set up the target
		if( _lastInChain && !(flags & DRAW.INTERMEDIATE) ) {
			// Last filter in our chain - draw directly to the WebGL Canvas. We may
			// also have to flip the image vertically now
			target = null;
			flipY = _drawCount % 2 == 0;
		}
		else {
			// Intermediate draw call - get a temp buffer to draw to
			_currentFramebufferIndex = (_currentFramebufferIndex+1) % 2;
			target = _getTempFramebuffer(_currentFramebufferIndex).fbo;
		}

		// Bind the source and target and draw the two triangles
		gl.bindTexture(gl.TEXTURE_2D, source);
		gl.bindFramebuffer(gl.FRAMEBUFFER, target);

		gl.uniform1f(_currentProgram.uniform.flipY, (flipY ? -1 : 1) );
		gl.drawArrays(gl.TRIANGLES, 0, 6);
	};

	var _compileShader = function( fragmentSource ) {
		if (_shaderProgramCache[fragmentSource]) {
			_currentProgram = _shaderProgramCache[fragmentSource];
			gl.useProgram(_currentProgram.id);
			return _currentProgram;
		}

		// Compile shaders
		_currentProgram = new WebGLProgram( gl, SHADER.VERTEX_IDENTITY, fragmentSource );

		var floatSize = Float32Array.BYTES_PER_ELEMENT;
		var vertSize = 4 * floatSize;
		gl.enableVertexAttribArray(_currentProgram.attribute.pos);
		gl.vertexAttribPointer(_currentProgram.attribute.pos, 2, gl.FLOAT, false, vertSize , 0 * floatSize);
		gl.enableVertexAttribArray(_currentProgram.attribute.uv);
		gl.vertexAttribPointer(_currentProgram.attribute.uv, 2, gl.FLOAT, false, vertSize, 2 * floatSize);

		_shaderProgramCache[fragmentSource] = _currentProgram;
		return _currentProgram;
	};


	var DRAW = { INTERMEDIATE: 1 };

	var SHADER = {};
	SHADER.VERTEX_IDENTITY = [
		'precision highp float;',
		'attribute vec2 pos;',
		'attribute vec2 uv;',
		'varying vec2 vUv;',
		'uniform float flipY;',

		'void main(void) {',
			'vUv = uv;',
			'gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);',
		'}'
	].join('\n');

	SHADER.FRAGMENT_IDENTITY = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform sampler2D texture;',

		'void main(void) {',
			'gl_FragColor = texture2D(texture, vUv);',
		'}',
	].join('\n');


	var _filter = {};



	// -------------------------------------------------------------------------
	// Color Matrix Filter

	_filter.colorMatrix = function( matrix , amount = 1 ) {
		matrix = matrix.map((coef, index) => weightedAvg(coef, identityMatrix[index], amount));
		// Create a Float32 Array and normalize the offset component to 0-1
		var m = new Float32Array(matrix);
		m[4] /= 255;
		m[9] /= 255;
		m[14] /= 255;
		m[19] /= 255;

		// Can we ignore the alpha value? Makes things a bit faster.
		var shader = (1==m[18]&&0==m[3]&&0==m[8]&&0==m[13]&&0==m[15]&&0==m[16]&&0==m[17]&&0==m[19])
			? _filter.colorMatrix.SHADER.WITHOUT_ALPHA
			: _filter.colorMatrix.SHADER.WITH_ALPHA;
		
		var program = _compileShader(shader);
		gl.uniform1fv(program.uniform.m, m);
		_draw();
	};

	_filter.colorMatrix.SHADER = {};
	_filter.colorMatrix.SHADER.WITH_ALPHA = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform sampler2D texture;',
		'uniform float m[20];',

		'void main(void) {',
			'vec4 c = texture2D(texture, vUv);',
			'gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];',
			'gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];',
			'gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];',
			'gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];',
		'}',
	].join('\n');
	_filter.colorMatrix.SHADER.WITHOUT_ALPHA = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform sampler2D texture;',
		'uniform float m[20];',

		'void main(void) {',
			'vec4 c = texture2D(texture, vUv);',
			'gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];',
			'gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];',
			'gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];',
			'gl_FragColor.a = c.a;',
		'}',
	].join('\n');

	_filter.brightness = function( brightness ) {
		var b = (brightness || 0) + 1;
		_filter.colorMatrix([
				b, 0, 0, 0, 0,
				0, b, 0, 0, 0,
				0, 0, b, 0, 0,
				0, 0, 0, 1, 0
		]);
	};

	_filter.saturation = function( amount ) {
		var x = (amount || 0) * 2/3 + 1;
		var y = ((x-1) *-0.5);
		_filter.colorMatrix([
			x, y, y, 0, 0,
			y, x, y, 0, 0,
			y, y, x, 0, 0,
			0, 0, 0, 1, 0
		]);
	};

	_filter.desaturate = function() {
		_filter.saturation(-1);
	};

	_filter.contrast = function( amount ) {
		var v = (amount || 0) + 1;
		var o = -128 * (v-1);
		
		_filter.colorMatrix([
			v, 0, 0, 0, o,
			0, v, 0, 0, o,
			0, 0, v, 0, o,
			0, 0, 0, 1, 0
		]);
	};

	_filter.negative = function() {
		_filter.contrast(-2);
	};

	_filter.hue = function( rotation ) {
		rotation = (rotation || 0)/180 * Math.PI;
		var cos = Math.cos(rotation),
			sin = Math.sin(rotation),
			lumR = 0.213,
			lumG = 0.715,
			lumB = 0.072;

		_filter.colorMatrix([
			lumR+cos*(1-lumR)+sin*(-lumR),lumG+cos*(-lumG)+sin*(-lumG),lumB+cos*(-lumB)+sin*(1-lumB),0,0,
			lumR+cos*(-lumR)+sin*(0.143),lumG+cos*(1-lumG)+sin*(0.140),lumB+cos*(-lumB)+sin*(-0.283),0,0,
			lumR+cos*(-lumR)+sin*(-(1-lumR)),lumG+cos*(-lumG)+sin*(lumG),lumB+cos*(1-lumB)+sin*(lumB),0,0,
			0, 0, 0, 1, 0
		]);
	};

	_filter.desaturateLuminance = function( amount ) {
		_filter.colorMatrix([
			0.2764723, 0.9297080, 0.0938197, 0, -37.1,
			0.2764723, 0.9297080, 0.0938197, 0, -37.1,
			0.2764723, 0.9297080, 0.0938197, 0, -37.1,
			0, 0, 0, 1, 0
		], amount);
	};

	_filter.sepia = function( amount ) {
		_filter.colorMatrix([
			0.393, 0.7689999, 0.18899999, 0, 0,
			0.349, 0.6859999, 0.16799999, 0, 0,
			0.272, 0.5339999, 0.13099999, 0, 0,
			0,0,0,1,0
		], amount);
	};

	_filter.brownie = function( amount ) {
		_filter.colorMatrix([
			0.5997023498159715,0.34553243048391263,-0.2708298674538042,0,47.43192855600873,
			-0.037703249837783157,0.8609577587992641,0.15059552388459913,0,-36.96841498319127,
			0.24113635128153335,-0.07441037908422492,0.44972182064877153,0,-7.562075277591283,
			0,0,0,1,0
		], amount);
	};

	_filter.vintagePinhole = function( amount ) {
		_filter.colorMatrix([
			0.6279345635605994,0.3202183420819367,-0.03965408211312453,0,9.651285835294123,
			0.02578397704808868,0.6441188644374771,0.03259127616149294,0,7.462829176470591,
			0.0466055556782719,-0.0851232987247891,0.5241648018700465,0,5.159190588235296,
			0,0,0,1,0
		], amount);
	};

	_filter.kodachrome = function( amount ) {
		_filter.colorMatrix([
			1.1285582396593525,-0.3967382283601348,-0.03992559172921793,0,63.72958762196502,
			-0.16404339962244616,1.0835251566291304,-0.05498805115633132,0,24.732407896706203,
			-0.16786010706155763,-0.5603416277695248,1.6014850761964943,0,35.62982807460946,
			0,0,0,1,0
		], amount);
	};

	_filter.technicolor = function( amount ) {
		_filter.colorMatrix([
			1.9125277891456083,-0.8545344976951645,-0.09155508482755585,0,11.793603434377337,
			-0.3087833385928097,1.7658908555458428,-0.10601743074722245,0,-70.35205161461398,
			-0.231103377548616,-0.7501899197440212,1.847597816108189,0,30.950940869491138,
			0,0,0,1,0
		], amount);
	};

	_filter.polaroid = function( amount ) {
		_filter.colorMatrix([
			1.438,-0.062,-0.062,0,0,
			-0.122,1.378,-0.122,0,0,
			-0.016,-0.016,1.483,0,0,
			0,0,0,1,0
		], amount);
	};

	_filter.shiftToBGR = function(amount) {
		_filter.colorMatrix([
			0,0,1,0,0,
			0,1,0,0,0,
			1,0,0,0,0,
			0,0,0,1,0
		], amount);
	};


	// -------------------------------------------------------------------------
	// Convolution Filter

	_filter.convolution = function( matrix ) {
		var m = new Float32Array(matrix);
		var pixelSizeX = 1 / _width;
		var pixelSizeY = 1 / _height;

		var program = _compileShader(_filter.convolution.SHADER);
		gl.uniform1fv(program.uniform.m, m);
		gl.uniform2f(program.uniform.px, pixelSizeX, pixelSizeY);
		_draw();
	};

	_filter.convolution.SHADER = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform sampler2D texture;',
		'uniform vec2 px;',
		'uniform float m[9];',

		'void main(void) {',
			'vec4 c11 = texture2D(texture, vUv - px);', // top left
			'vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y));', // top center
			'vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y));', // top right

			'vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) );', // mid left
			'vec4 c22 = texture2D(texture, vUv);', // mid center
			'vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) );', // mid right

			'vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) );', // bottom left
			'vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) );', // bottom center
			'vec4 c33 = texture2D(texture, vUv + px );', // bottom right

			'gl_FragColor = ',
				'c11 * m[0] + c12 * m[1] + c22 * m[2] +',
				'c21 * m[3] + c22 * m[4] + c23 * m[5] +',
				'c31 * m[6] + c32 * m[7] + c33 * m[8];',
			'gl_FragColor.a = c22.a;',
		'}',
	].join('\n');


	_filter.detectEdges = function() {
		_filter.convolution.call(this, [
			0, 1, 0,
			1, -4, 1,
			0, 1, 0
		]);
	};

	_filter.sobelX = function() {
		_filter.convolution.call(this, [
			-1, 0, 1,
			-2, 0, 2,
			-1, 0, 1
		]);
	};

	_filter.sobelY = function() {
		_filter.convolution.call(this, [
			-1, -2, -1,
			 0,  0,  0,
			 1,  2,  1
		]);
	};

	_filter.sharpen = function( amount ) {
		var a = amount || 1;
		_filter.convolution.call(this, [
			0, -1*a, 0,
			-1*a, 1 + 4*a, -1*a,
			0, -1*a, 0
		]);
	};

	_filter.emboss = function( size ) {
		var s = size || 1;
		_filter.convolution.call(this, [
			-2*s, -1*s, 0,
			-1*s, 1, 1*s,
			0, 1*s, 2*s
		]);
	};


	// -------------------------------------------------------------------------
	// Blur Filter

	_filter.blur = function( size ) {
		var blurSizeX = (size/7) / _width;
		var blurSizeY = (size/7) / _height;

		var program = _compileShader(_filter.blur.SHADER);

		// Vertical
		gl.uniform2f(program.uniform.px, 0, blurSizeY);
		_draw(DRAW.INTERMEDIATE);

		// Horizontal
		gl.uniform2f(program.uniform.px, blurSizeX, 0);
		_draw();
	};

	_filter.blur.SHADER = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform sampler2D texture;',
		'uniform vec2 px;',

		'void main(void) {',
			'gl_FragColor = vec4(0.0);',
			'gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;',
			'gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;',
			'gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;',
			'gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;',
		'}',
	].join('\n');


	// -------------------------------------------------------------------------
	// Pixelate Filter

	_filter.pixelate = function( size ) {
		var blurSizeX = (size) / _width;
		var blurSizeY = (size) / _height;

		var program = _compileShader(_filter.pixelate.SHADER);

		// Horizontal
		gl.uniform2f(program.uniform.size, blurSizeX, blurSizeY);
		_draw();
	};

	_filter.pixelate.SHADER = [
		'precision highp float;',
		'varying vec2 vUv;',
		'uniform vec2 size;',
		'uniform sampler2D texture;',

		'vec2 pixelate(vec2 coord, vec2 size) {',
			'return floor( coord / size ) * size;',
		'}',

		'void main(void) {',
			'gl_FragColor = vec4(0.0);',
			'vec2 coord = pixelate(vUv, size);',
			'gl_FragColor += texture2D(texture, coord);',
		'}',
	].join('\n');
};

})(window);
;

/**************************************************
*  Filepath: /web_editor/static/lib/DOMPurify.js  *
*  Lines: 1376                                    *
**************************************************/
/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.DOMPurify = factory());
}(this, function () { 'use strict';

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'contenteditable', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.1';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify.
     *
     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
     * might cause XSS from attacks hidden in closed shadowroots in case the browser
     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
     */
    var RETURN_DOM_IMPORT = true;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = stringToLowerCase(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Mitigate a problem with templates inside select */
      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = stringToLowerCase(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = currentNode.nodeName.toLowerCase();
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = stringToLowerCase(tag);
      var lcName = stringToLowerCase(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
;

/*****************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/OdooEditor.js  *
*  Lines: 5367                                                               *
*****************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/OdooEditor', ['@web_editor/js/editor/odoo-editor/src/commands/deleteBackward', '@web_editor/js/editor/odoo-editor/src/commands/deleteForward', '@web_editor/js/editor/odoo-editor/src/commands/enter', '@web_editor/js/editor/odoo-editor/src/commands/shiftEnter', '@web_editor/js/editor/odoo-editor/src/commands/shiftTab', '@web_editor/js/editor/odoo-editor/src/commands/tab', '@web_editor/js/editor/odoo-editor/src/commands/toggleList', '@web_editor/js/editor/odoo-editor/src/commands/align', '@web_editor/js/editor/odoo-editor/src/utils/sanitize', '@web_editor/js/editor/odoo-editor/src/utils/serialize', '@web_editor/js/editor/odoo-editor/src/utils/utils', '@web_editor/js/editor/odoo-editor/src/commands/commands', '@web_editor/js/editor/odoo-editor/src/powerbox/Powerbox', '@web_editor/js/editor/odoo-editor/src/tablepicker/TablePicker', '@web_editor/js/editor/odoo-editor/src/utils/constants'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
require("@web_editor/js/editor/odoo-editor/src/commands/deleteBackward");
require("@web_editor/js/editor/odoo-editor/src/commands/deleteForward");
require("@web_editor/js/editor/odoo-editor/src/commands/enter");
require("@web_editor/js/editor/odoo-editor/src/commands/shiftEnter");
require("@web_editor/js/editor/odoo-editor/src/commands/shiftTab");
require("@web_editor/js/editor/odoo-editor/src/commands/tab");
require("@web_editor/js/editor/odoo-editor/src/commands/toggleList");
require("@web_editor/js/editor/odoo-editor/src/commands/align");

const { sanitize } = require("@web_editor/js/editor/odoo-editor/src/utils/sanitize");
const { serializeNode, unserializeNode, serializeSelection } = require("@web_editor/js/editor/odoo-editor/src/utils/serialize");
const {
    closestBlock,
    commonParentGet,
    containsUnremovable,
    DIRECTIONS,
    ensureFocus,
    getCursorDirection,
    getFurthestUneditableParent,
    getListMode,
    getOuid,
    insertText,
    isColorGradient,
    nodeSize,
    preserveCursor,
    setCursorStart,
    setSelection,
    toggleClass,
    closestElement,
    isVisible,
    isHtmlContentSupported,
    rgbToHex,
    isFontAwesome,
    ICON_SELECTOR,
    getInSelection,
    getDeepRange,
    getRowIndex,
    getColumnIndex,
    ancestors,
    firstLeaf,
    previousLeaf,
    nextLeaf,
    isUnremovable,
    fillEmpty,
    isEmptyBlock,
    URL_REGEX,
    isSelectionFormat,
    YOUTUBE_URL_GET_VIDEO_ID,
    unwrapContents,
    peek,
    getAdjacentPreviousSiblings,
    getAdjacentNextSiblings,
    isBlock,
    getTraversedNodes,
    getSelectedNodes,
    descendants,
    hasValidSelection,
    hasTableSelection,
    pxToFloat,
    parseHTML,
    splitTextNode,
    isEditorTab,
    isMacOS,
    isProtected,
    isArtificialVoidElement,
    cleanZWS,
    isZWS,
    setCursorEnd,
    paragraphRelatedElements,
    getDeepestPosition,
    leftPos,
    isNotAllowedContent,
    EMAIL_REGEX,
    prepareUpdate,
    boundariesOut,
    getFontSizeDisplayValue,
    rightLeafOnlyNotBlockPath,
    lastLeaf,
    isUnbreakable,
    splitAroundUntil,
    ZERO_WIDTH_CHARS,
    ZERO_WIDTH_CHARS_REGEX,
    getAdjacentCharacter,
    isLinkEligibleForZwnbsp,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");
const { editorCommands } = require("@web_editor/js/editor/odoo-editor/src/commands/commands");
const { Powerbox } = require("@web_editor/js/editor/odoo-editor/src/powerbox/Powerbox");
const { TablePicker } = require("@web_editor/js/editor/odoo-editor/src/tablepicker/TablePicker");

Object.assign(__exports, require("@web_editor/js/editor/odoo-editor/src/utils/utils"));
const { UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE } = require("@web_editor/js/editor/odoo-editor/src/utils/constants");
/* global DOMPurify */

const BACKSPACE_ONLY_COMMANDS = ['oDeleteBackward', 'oDeleteForward'];
const BACKSPACE_FIRST_COMMANDS = BACKSPACE_ONLY_COMMANDS.concat(['oEnter', 'oShiftEnter']);

// 60 seconds
const HISTORY_SNAPSHOT_INTERVAL = 1000 * 60;
// 10 seconds
const HISTORY_SNAPSHOT_BUFFER_TIME = 1000 * 10;

const KEYBOARD_TYPES = { VIRTUAL: 'VIRTUAL', PHYSICAL: 'PHYSICAL', UNKNOWN: 'UKNOWN' };

const AVATAR_SIZE = __exports.AVATAR_SIZE = 25;

const IS_KEYBOARD_EVENT_UNDO = ev => ev.key === 'z' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_REDO = ev => ev.key === 'y' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_BOLD = ev => ev.key === 'b' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_ITALIC = ev => ev.key === 'i' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_UNDERLINE = ev => ev.key === 'u' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_STRIKETHROUGH = ev => ev.key === '5' && (ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_LEFT_ARROW = ev => ev.key === 'ArrowLeft' && !(ev.ctrlKey || ev.metaKey);
const IS_KEYBOARD_EVENT_RIGHT_ARROW = ev => ev.key === 'ArrowRight' && !(ev.ctrlKey || ev.metaKey);

const CLIPBOARD_BLACKLISTS = {
    unwrap: ['.Apple-interchange-newline', 'DIV'], // These elements' children will be unwrapped.
    remove: ['META', 'STYLE', 'SCRIPT'], // These elements will be removed along with their children.
};
const CLIPBOARD_WHITELISTS = __exports.CLIPBOARD_WHITELISTS = {
    nodes: [
        // Style
        'P',
        'H1',
        'H2',
        'H3',
        'H4',
        'H5',
        'H6',
        'BLOCKQUOTE',
        'PRE',
        // List
        'UL',
        'OL',
        'LI',
        // Inline style
        'I',
        'B',
        'U',
        'S',
        'EM',
        'FONT',
        'STRONG',
        // Table
        'TABLE',
        'THEAD',
        'TH',
        'TBODY',
        'TR',
        'TD',
        // Miscellaneous
        'IMG',
        'BR',
        'A',
        '.fa',
    ],
    classes: [
        // Media
        /^float-/,
        'd-block',
        'mx-auto',
        'img-fluid',
        'img-thumbnail',
        'rounded',
        'rounded-circle',
        'table',
        'table-bordered',
        /^padding-/,
        /^shadow/,
        // Odoo colors
        /^text-o-/,
        /^bg-o-/,
        // Odoo lists
        'o_checked',
        'o_checklist',
        'oe-nested',
        // Miscellaneous
        /^btn/,
        /^fa/,
    ],
    attributes: ['class', 'href', 'src', 'target'],
    styledTags: ['SPAN', 'B', 'STRONG', 'I', 'S', 'U', 'FONT', 'TD'],
};

// Commands that don't require a DOM selection but take an argument instead.
const SELECTIONLESS_COMMANDS = ['addRow', 'addColumn', 'removeRow', 'removeColumn', 'resetSize'];

const FORMATTING_COMMANDS = ['applyColor', 'bold', 'italic', 'underline', 'strikeThrough', 'setFontSize']

function defaultOptions(defaultObject, object) {
    const newObject = Object.assign({}, defaultObject, object);
    for (const [key, value] of Object.entries(object)) {
        if (typeof value === 'undefined') {
            newObject[key] = defaultObject[key];
        }
    }
    return newObject;
}
function getImageFiles(dataTransfer) {
    return [...dataTransfer.items]
        .filter(item => item.kind === 'file' && item.type.includes('image/'))
        .map((item) => item.getAsFile());
}
function getImageUrl (file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.readAsDataURL(file);
        reader.onloadend = (e) => {
            if (reader.error) {
                return reject(reader.error);
            }
            resolve(e.target.result);
        };
    });
}
const OdooEditor = __exports.OdooEditor = class OdooEditor extends EventTarget {
    constructor(editable, options = {}) {
        super();

        this.options = defaultOptions(
            {
                controlHistoryFromDocument: false,
                getContextFromParentRect: () => {
                    return { top: 0, left: 0 };
                },
                getScrollContainerRect: () => document.body.getBoundingClientRect(),
                toSanitize: true,
                isRootEditable: true,
                placeholder: false,
                showEmptyElementHint: true,
                defaultLinkAttributes: {},
                plugins: [],
                getUnremovableElements: () => [],
                getReadOnlyAreas: () => [],
                getContentEditableAreas: () => [],
                getPowerboxElement: () => {
                    const selection = document.getSelection();
                    if (selection.isCollapsed && selection.rangeCount) {
                        return closestElement(selection.anchorNode, 'P, DIV');
                    }
                },
                preHistoryUndo: () => {},
                beforeAnyCommand: () => {},
                isHintBlacklisted: () => false,
                filterMutationRecords: (records) => records,
                /**
                 * In case an external asynchronous post processing has to be
                 * applied on some nodes after an external step (i.e. render
                 * an OWL Component), the owner of the post-processing will
                 * return a Promise through this hook resolved when it is done.
                 * Further collaborative external steps will be buffered as
                 * long as that promise is not resolved, to avoid a situation
                 * where the editor tries to apply mutations inside a node that
                 * is currently being rendered (not ready).
                 *
                 * @param {Element} editable
                 * @returns {Promise|null} Promise that will be resolved when
                 *          the rendering is done, or null if there is no
                 *          rendering to do. The editor will buffer new external
                 *          steps (collaborative) until the promise is resolved.
                 */
                postProcessExternalSteps: () => null,
                onPostSanitize: () => {},
                direction: 'ltr',
                _t: string => string,
                allowCommandVideo: true,
                renderingClasses: [],
                allowInlineAtRoot: false,
                useResponsiveFontSizes: true,
                showResponsiveFontSizesBadges: false,
                showExtendedTextStylesOptions: false,
                autoActivateContentEditable: true,
                // TODO probably move `getCSSVariableValue` and
                // `convertNumericToUnit` as odoo-editor utils to avoid this
                getCSSVariableValue: () => null,
                convertNumericToUnit: x => x,
            },
            options,
        );

        // --------------
        // Set properties
        // --------------

        this.document = options.document || document;
        this.isDestroyed = false;

        this.isMobile = matchMedia('(max-width: 767px)').matches;
        this.isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

        this.isPrepareUpdateLocked = false;

        // Keyboard type detection, happens only at the first keydown event.
        this.keyboardType = KEYBOARD_TYPES.UNKNOWN;

        // Wether we should check for unbreakable the next history step.
        this._checkStepUnbreakable = true;

        // All dom listeners currently active.
        this._domListeners = [];

        // Set of labels that which prevent the automatic step mechanism if
        // it contains at least one element.
        this._observerTimeoutUnactive = new Set();
        // Set of labels that which prevent the observer to be active if
        // it contains at least one element.
        this._observerUnactiveLabels = new Set();

        // The state of the dom.
        this._currentMouseState = 'mouseup';

        this._onKeyupResetContenteditableNodes = [];

        // Track if we need to rollback mutations in case unbreakable or unremovable are being added or removed.
        this._toRollback = false;

        // Map that from an node id to the dom node.
        this._idToNodeMap = new Map();

        // Instanciate plugins.
        this._plugins = [];
        for (const plugin of this.options.plugins) {
            this._pluginAdd(plugin);
        }

        // -------------------
        // Alter the editable
        // -------------------

        if (editable.innerHTML.trim() === '') {
            editable.innerHTML = '<p><br></p>';
        }
        this.initElementForEdition(editable);

        // Convention: root node is ID root.
        editable.oid = 'root';
        this._idToNodeMap.set(1, editable);
        this.editable = editable;
        this.editable.classList.add("odoo-editor-editable");
        if (this.options.toSanitize) {
            sanitize(editable);
            this.options.onPostSanitize(editable);
        }
        this.editable.setAttribute('dir', this.options.direction);

        // Set contenteditable before clone as FF updates the content at this point.
        this.canActivateContentEditable = this.options.autoActivateContentEditable;
        if (this.canActivateContentEditable) {
            this._activateContenteditable();
        }
        this._collabClientId = this.options.collaborationClientId;
        this._collabClientAvatarUrl = this.options.collaborationClientAvatarUrl;

        // Collaborator selection and caret display.
        this._collabSelectionInfos = new Map();
        this._collabSelectionColor = `hsl(${(Math.random() * 360).toFixed(0)}, 75%, 50%)`;
        this._avatarsOverlaps = {}

        // This main container is used to contain a tree of sub containers.
        // By having one parent that contains a tree of containers, it is easy
        // to change the z-index of any container by changing their place in the
        // tree rather than tweaking a z-index number.
        this.mainAbsoluteContainer = this.document.createElement('div');
        this.mainAbsoluteContainer.classList.add('oe-absolute-container');
        this.editable.before(this.mainAbsoluteContainer);

        // This container contains the users selections.
        this._selectionsContainer = this.makeAbsoluteContainer('oe-selections-container');
        // This container contains the users avatars.
        this._avatarsContainer = this.makeAbsoluteContainer('oe-avatars-container');
        // This container contains the users counter that overlap the users avatars.
        this._avatarsCountersContainer = this.makeAbsoluteContainer('oe-avatars-counters-container');

        // Promise for extra rendering, collaborative external steps will be
        // buffered (delayed) until it is resolved.
        this._postProcessExternalStepsPromise = null;
        this._externalStepsBuffer = [];

        this.idSet(editable);
        this._historyStepsActive = true;
        this.historyReset();
        if (this.options.initialHistoryId) {
            this.historySetInitialId(this.options.initialHistoryId);
        }

        this._pluginCall('start', [editable]);
        this._pluginCall('sanitizeElement', [editable]);

        // ------
        // Tables
        // ------

        // Create the table picker for the Powerbox.
        this.powerboxTablePicker = new TablePicker({
            document: this.document,
            floating: true,
            getContextFromParentRect: this.options.getContextFromParentRect,
            direction: this.options.direction,
        });
        document.body.appendChild(this.powerboxTablePicker.el);
        this.powerboxTablePicker.addEventListener('cell-selected', ev => {
            this.execCommand('insertTable', {
                rowNumber: ev.detail.rowNumber,
                colNumber: ev.detail.colNumber,
            });
        });
        // Create the table UI.
        this._tableUiContainer = this.document.createElement('div');
        this._tableUiContainer.classList.add('o_table_ui_container');
        const parser = new DOMParser();
        const isRTL = this.options.direction === "rtl";
        for (const direction of ['row', 'column']) {
            // Create the containers and the menu toggler.
            const iconClass = (direction === 'row') ? 'fa-ellipsis-v' : 'fa-ellipsis-h';
            const ui = parser.parseFromString(`<div class="o_table_ui o_${direction}_ui" style="visibility: hidden;">
                <div>
                    <span class="o_table_ui_menu_toggler fa ${iconClass}"></span>
                    <div class="o_table_ui_menu"></div>
                </div>
            </div>`, 'text/html').body.firstElementChild;
            const uiMenu = ui.querySelector('.o_table_ui_menu');
            // Create the move buttons.
            if (direction === 'column') {
                if (isRTL) {
                    uiMenu.append(...parser.parseFromString(`
                        <div class="o_move_right"><span class="fa fa-chevron-right"></span>` + this.options._t('Move left') + `</div>
                        <div class="o_move_left"><span class="fa fa-chevron-left"></span>` + this.options._t('Move right') + `</div>
                    `, 'text/html').body.children);
                } else {
                    uiMenu.append(...parser.parseFromString(`
                        <div class="o_move_left"><span class="fa fa-chevron-left"></span>` + this.options._t('Move left') + `</div>
                        <div class="o_move_right"><span class="fa fa-chevron-right"></span>` + this.options._t('Move right') + `</div>
                    `, 'text/html').body.children);
                }
                this.addDomListener(uiMenu.querySelector('.o_move_left'), 'click', this._onTableMoveLeftClick);
                this.addDomListener(uiMenu.querySelector('.o_move_right'), 'click', this._onTableMoveRightClick);
            } else {
                uiMenu.append(...parser.parseFromString(`
                    <div class="o_move_up"><span class="fa fa-chevron-left" style="transform: rotate(90deg);"></span>` + this.options._t('Move up') + `</div>
                    <div class="o_move_down"><span class="fa fa-chevron-right" style="transform: rotate(90deg);"></span>` + this.options._t('Move down') + `</div>
                `, 'text/html').body.children);
                this.addDomListener(uiMenu.querySelector('.o_move_up'), 'click', this._onTableMoveUpClick);
                this.addDomListener(uiMenu.querySelector('.o_move_down'), 'click', this._onTableMoveDownClick);
            }

            // Create the add buttons.
            if (direction === 'column') {
                if (isRTL) {
                    uiMenu.append(...parser.parseFromString(`
                        <div class="o_insert_right"><span class="fa fa-plus"></span>` + this.options._t('Insert left') + `</div>
                        <div class="o_insert_left"><span class="fa fa-plus"></span>` + this.options._t('Insert right') + `</div>
                    `, 'text/html').body.children);
                } else {
                    uiMenu.append(...parser.parseFromString(`
                        <div class="o_insert_left"><span class="fa fa-plus"></span>` + this.options._t('Insert left') + `</div>
                        <div class="o_insert_right"><span class="fa fa-plus"></span>` + this.options._t('Insert right') + `</div>
                    `, 'text/html').body.children);
                }
                this.addDomListener(uiMenu.querySelector('.o_insert_left'), 'click', () => this.execCommand('addColumn', 'before', this._columnUiTarget));
                this.addDomListener(uiMenu.querySelector('.o_insert_right'), 'click', () => this.execCommand('addColumn', 'after', this._columnUiTarget));
            } else {
                uiMenu.append(...parser.parseFromString(`
                    <div class="o_insert_above"><span class="fa fa-plus"></span>` + this.options._t('Insert above') + `</div>
                    <div class="o_insert_below"><span class="fa fa-plus"></span>` + this.options._t('Insert below') + `</div>
                `, 'text/html').body.children);
                this.addDomListener(uiMenu.querySelector('.o_insert_above'), 'click', () => this.execCommand('addRow', 'before', this._rowUiTarget));
                this.addDomListener(uiMenu.querySelector('.o_insert_below'), 'click', () => this.execCommand('addRow', 'after', this._rowUiTarget));
            }

            // Add the delete button.
            if (direction === 'column') {
                uiMenu.append(parser.parseFromString(`<div class="o_delete_column"><span class="fa fa-trash"></span>` + this.options._t('Delete') + `</div>
                `, 'text/html').body.firstChild)
                this.addDomListener(uiMenu.querySelector('.o_delete_column'), 'click', this._onTableDeleteColumnClick);
            } else {
                uiMenu.append(parser.parseFromString(`<div class="o_delete_row"><span class="fa fa-trash"></span>` + this.options._t('Delete') + `</div>
                `, 'text/html').body.firstChild)
                this.addDomListener(uiMenu.querySelector('.o_delete_row'), 'click', this._onTableDeleteRowClick);
            }

            // Reset the size of the table
            uiMenu.append(parser.parseFromString(`<div class="o_reset_table_size"><span class="fa fa-table"></span>` + this.options._t('Reset Size') + `</div>
                `, 'text/html').body.firstChild)
            this.addDomListener(uiMenu.querySelector('.o_reset_table_size'), 'click', () => this.execCommand('resetSize', this._tableUiTarget));

            this[`_${direction}Ui`] = ui;
            this._tableUiContainer.append(ui);
            this.addDomListener(ui.querySelector('.o_table_ui_menu_toggler'), 'click', this._onTableMenuTogglerClick);
            this.editable.before(this._tableUiContainer);
        }

        // --------
        // Powerbox
        // --------

        this.powerbox = new Powerbox({
            editable: this.editable,
            getContextFromParentRect: this.options.getContextFromParentRect,
            commandFilters: this.options.powerboxFilters,
            onShow: () => {
                this.powerboxTablePicker.hide();
            },
            beforeCommand: () => {
                if (this._isPowerboxOpenOnInput) {
                    this.historyRevertUntil(this._powerboxBeforeStepIndex);
                    this.historyStep(true);
                    this._historyStepsStates.set(peek(this._historySteps).id, 'consumed');
                    ensureFocus(this.editable);
                    getDeepRange(this.editable, { select: true });
                }
            },
            afterCommand: () => {
                this.historyStep(true);
                this._isPowerboxOpenOnInput = false;
            },
            categories: [
                { name: this.options._t('Structure'), priority: 70 },
                { name: this.options._t('Format'), priority: 60 },
                { name: this.options._t('Widgets'), priority: 30 },
                ...(this.options.categories || []),
            ],
            commands: [
                {
                    category: this.options._t('Structure'),
                    name: this.options._t('Bulleted list'),
                    priority: 110,
                    description: this.options._t('Create a simple bulleted list'),
                    fontawesome: 'fa-list-ul',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('toggleList', 'UL');
                    },
                },
                {
                    category: this.options._t('Structure'),
                    name: this.options._t('Numbered list'),
                    priority: 100,
                    description: this.options._t('Create a list with numbering'),
                    fontawesome: 'fa-list-ol',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('toggleList', 'OL');
                    },
                },
                {
                    category: this.options._t('Structure'),
                    name: this.options._t('Checklist'),
                    priority: 90,
                    description: this.options._t('Track tasks with a checklist'),
                    fontawesome: 'fa-check-square-o',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('toggleList', 'CL');
                    },
                },
                {
                    category: this.options._t('Structure'),
                    name: this.options._t('Table'),
                    priority: 80,
                    description: this.options._t('Insert a table'),
                    fontawesome: 'fa-table',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        if(this.isMobile){
                            this.execCommand('insertTable', {
                                rowNumber: this.powerboxTablePicker.rowNumber,
                                colNumber: this.powerboxTablePicker.colNumber,
                            });
                        } else {
                            this.powerboxTablePicker.show();
                        }
                    },
                },
                {
                    category: this.options._t('Format'),
                    name: this.options._t('Heading 1'),
                    priority: 50,
                    description: this.options._t('Big section heading'),
                    fontawesome: 'fa-header',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('setTag', 'H1');
                    },
                },
                {
                    category: this.options._t('Format'),
                    name: this.options._t('Heading 2'),
                    priority: 40,
                    description: this.options._t('Medium section heading'),
                    fontawesome: 'fa-header',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('setTag', 'H2');
                    },
                },
                {
                    category: this.options._t('Format'),
                    name: this.options._t('Heading 3'),
                    priority: 30,
                    description: this.options._t('Small section heading'),
                    fontawesome: 'fa-header',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('setTag', 'H3');
                    },
                },
                {
                    category: this.options._t('Format'),
                    name: this.options._t('Switch direction'),
                    priority: 20,
                    description: this.options._t('Switch the text\'s direction'),
                    fontawesome: 'fa-exchange',
                    callback: () => {
                        this.execCommand('switchDirection');
                    },
                },
                {
                    category: this.options._t('Format'),
                    name: this.options._t('Text'),
                    priority: 10,
                    description: this.options._t('Paragraph block'),
                    fontawesome: 'fa-paragraph',
                    isDisabled: () => !this.isSelectionInBlockRoot(),
                    callback: () => {
                        this.execCommand('setTag', 'P');
                    },
                },
                {
                    category: this.options._t('Widgets'),
                    name: this.options._t('3 Stars'),
                    priority: 20,
                    description: this.options._t('Insert a rating over 3 stars'),
                    fontawesome: 'fa-star-o',
                    callback: () => {
                        let html = '\u200B<span contenteditable="false" class="o_stars o_three_stars">';
                        html += Array(3).fill().map(() => '<i class="fa fa-star-o"></i>').join('');
                        html += '</span>\u200B';
                        this.execCommand('insert', parseHTML(this.document, html));
                    },
                },
                {
                    category: this.options._t('Widgets'),
                    name: this.options._t('5 Stars'),
                    priority: 10,
                    description: this.options._t('Insert a rating over 5 stars'),
                    fontawesome: 'fa-star',
                    callback: () => {
                        let html = '\u200B<span contenteditable="false" class="o_stars o_five_stars">';
                        html += Array(5).fill().map(() => '<i class="fa fa-star-o"></i>').join('');
                        html += '</span>\u200B';
                        this.execCommand('insert', parseHTML(this.document, html));
                    },
                },
                ...(this.options.commands || []),
                ...(!this.options.commands || !this.options.commands.find(c =>  c.name === this.options._t('Separator')) ? [
                    {
                        category: this.options._t('Structure'),
                        name: this.options._t('Separator'),
                        priority: 40,
                        description: this.options._t('Insert a horizontal rule separator'),
                        fontawesome: 'fa-minus',
                        isDisabled: () => !this.isSelectionInBlockRoot(),
                        callback: () => {
                            this.execCommand('insertHorizontalRule');
                        },
                    }] : []),
            ],
        });

        // -----------
        // Bind events
        // -----------

        this.observerActive();

        this.addDomListener(this.editable, 'keydown', this._onKeyDown);
        this.addDomListener(this.editable, 'input', this._onInput);
        this.addDomListener(this.editable, 'beforeinput', this._onBeforeInput);
        this.addDomListener(this.editable, 'mousedown', this._onMouseDown);
        this.addDomListener(this.editable, 'mouseup', this._onMouseup);
        this.addDomListener(this.editable, 'mousemove', this._onMousemove);
        this.addDomListener(this.editable, 'mouseleave', this._onMouseLeave);
        this.addDomListener(this.editable, 'paste', this._onPaste);
        this.addDomListener(this.editable, 'dragstart', this._onDragStart);
        this.addDomListener(this.editable, 'drop', this._onDrop);
        this.addDomListener(this.editable, 'copy', this._onClipboardCopy);
        this.addDomListener(this.editable, 'cut', this._onClipboardCut);

        this.addDomListener(this.document, 'selectionchange', this._onSelectionChange);
        this.addDomListener(this.document, 'selectionchange', this._handleCommandHint);
        this.addDomListener(this.document, 'keydown', this._onDocumentKeydown);
        this.addDomListener(this.document, 'keyup', this._onDocumentKeyup);
        this.addDomListener(this.document, 'mouseup', this._onDocumentMouseup);
        this.addDomListener(this.document, 'click', this._onDocumentClick);
        this.addDomListener(this.document, 'scroll', this._onScroll, true);

        this.multiselectionRefresh = this.multiselectionRefresh.bind(this);
        this._resizeObserver = new ResizeObserver(this.multiselectionRefresh);
        this._resizeObserver.observe(this.document.body);
        this._resizeObserver.observe(this.editable);
        this.addDomListener(this.editable, 'scroll', this.multiselectionRefresh);

        if (this._collabClientId) {
            this._snapshotInterval = setInterval(() => {
                this._historyMakeSnapshot();
            }, HISTORY_SNAPSHOT_INTERVAL);
        }

        // -------
        // Toolbar
        // -------

        if (this.options.toolbar) {
            this.setupToolbar(this.options.toolbar);
        }
        // placeholder hint
        if (editable.textContent === '' && this.options.placeholder) {
            this._makeHint(editable.firstChild, this.options.placeholder, true);
        }
    }
    /**
     * Releases anything that was initialized.
     *
     * TODO: properly implement this.
     */
    destroy() {
        this.observerUnactive();
        this._removeDomListener();
        this.powerbox.destroy();
        this.powerboxTablePicker.el.remove();
        this.mainAbsoluteContainer.remove();
        this._resizeObserver.disconnect();
        clearInterval(this._snapshotInterval);
        this._pluginCall('destroy', []);
        this.isDestroyed = true;
        // Remove table UI
        this._rowUi.remove();
        this._columnUi.remove();
    }

    setupToolbar(toolbar) {
        this.toolbar = toolbar;
        this.autohideToolbar = this.options.autohideToolbar;
        if (!this.options.showExtendedTextStylesOptions) {
            this.toolbar.querySelectorAll("[data-extended-text-style]")
                .forEach(el => el.classList.add("d-none"));
        }
        this.bindExecCommand(this.toolbar);
        // Ensure anchors in the toolbar don't trigger a hash change.
        const toolbarAnchors = this.toolbar.querySelectorAll('a');
        toolbarAnchors.forEach(a => a.addEventListener('click', e => e.preventDefault()));
        for (const colorLabel of this.toolbar.querySelectorAll('label')) {
            colorLabel.addEventListener('mousedown', ev => {
                // Hack to prevent loss of focus (done by preventDefault) while still opening
                // color picker dialog (which is also prevented by preventDefault on chrome,
                // except when click detail is 2, which happens on a double-click but isn't
                // triggered by a dblclick event)
                if (ev.detail < 2) {
                    ev.preventDefault();
                    ev.currentTarget.dispatchEvent(new MouseEvent('click', { detail: 2 }));
                }
            });
            colorLabel.addEventListener('input', ev => {
                this.document.execCommand(ev.target.name, false, ev.target.value);
                this.updateColorpickerLabels();
            });
        }
        const fontSizeInput = this.toolbar.querySelector('input#fontSizeCurrentValue');
        this.addDomListener(this.toolbar, 'click', ev => {
            if (fontSizeInput && !fontSizeInput.readOnly && ev.target.closest('#font-size .dropdown-toggle')) {
                // If the click opened the font size dropdown, select the input content.
                fontSizeInput.select();
            } else if (
                !this.isSelectionInEditable() &&
                ev.target.nodeName !== 'INPUT' &&
                ev.target.id !== 'image-transform'
            ) {
                // Otherwise, if we lost the selection in the editable, restore it.
                this.historyResetLatestComputedSelection(true);
            }
        });

        const applyFontSizeREM = pxStrValue => {
            const pxValue = parseFloat(pxStrValue);
            const remValue = this.options.convertNumericToUnit(pxValue, "px", "rem");
            this.execCommand("setFontSize", `${remValue}rem`);
        };

        // Handle the font size input.
        if (fontSizeInput) {
            const debouncedOnInputChange = (() => {
                let handle;
                return () => new Promise(resolve => {
                    clearTimeout(handle);
                    handle = setTimeout(() => {
                        handle = null;
                        const fontSize = parseInt(fontSizeInput.value);
                        if (fontSize > 0) {
                            if (!this.isSelectionInEditable()) {
                                this.historyResetLatestComputedSelection(true);
                            }
                            applyFontSizeREM(fontSize);
                            fontSizeInput.blur();
                        }
                        resolve();
                    }, 50);
                });
            })();
            this.addDomListener(fontSizeInput, 'change', debouncedOnInputChange);
        }

        // Handle the font size dropdown.
        const fontSizeDropdown = this.toolbar.querySelector('#font-size');
        if (fontSizeDropdown) {
            this.computeFontSizeSelectorValues(fontSizeDropdown);

            const applyFontSizeChoice = optionEl => {
                if (!this.isSelectionInEditable()) {
                    this.historyResetLatestComputedSelection(true);
                }
                if (this.options.useResponsiveFontSizes) {
                    const fontSizeClassName = optionEl.dataset.applyClass;
                    this.execCommand("setFontSize", undefined);
                    this.execCommand("setFontSizeClassName", fontSizeClassName);
                } else {
                    applyFontSizeREM(optionEl.dataset.value);
                }
            };
            fontSizeDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                this.addDomListener(item, 'mousedown', ev => {
                    applyFontSizeChoice(ev.currentTarget);
                });
                this.addDomListener(item, 'keydown', ev => {
                    if (ev.key !== 'Enter') {
                        return;
                    }
                    applyFontSizeChoice(ev.currentTarget);
                });
            });
        }

        this._updateToolbar();
    }

    /**
     * Sets the px value for every font size dropdown item.
     */
    computeFontSizeSelectorValues(fontSizeDropdownEl) {
        fontSizeDropdownEl = fontSizeDropdownEl || this.toolbar.querySelector("#font-size");

        let previousItem = null;
        let previousValue = -1;
        const style = this.document.defaultView.getComputedStyle(this.document.body);
        for (const itemEl of fontSizeDropdownEl.querySelectorAll("[data-dynamic-value]")) {
            const variableName = itemEl.dataset.dynamicValue;
            const strValue = this.options.getCSSVariableValue(variableName, style);
            const remValue = parseFloat(strValue);
            const pxValue = this.options.convertNumericToUnit(remValue, "rem", "px");
            // Change the text node value only to preserve the badge element
            const roundedValue = Math.round(pxValue);
            itemEl.dataset.value = roundedValue;
            itemEl.firstChild.textContent = roundedValue;

            // If same value as the previous one, hide the previous one
            if (previousItem) {
                previousItem.parentElement.classList.toggle('d-none', Math.abs(pxValue - previousValue) < 0.001);
            }
            previousItem = itemEl;
            previousValue = pxValue;
        }

        for (const badgeEl of fontSizeDropdownEl.querySelectorAll(".o_we_font_size_badge")) {
            badgeEl.classList.toggle("d-none", !this.options.showResponsiveFontSizesBadges);
        }
    }

    resetContent(value) {
        value = value || '<p><br></p>';
        this.editable.innerHTML = value;
        this.sanitize(this.editable);
        this.historyStep(true);
        // The unbreakable protection mechanism detects an anomaly and attempts
        // to trigger a rollback when the content is reset using `innerHTML`.
        // Prevent this rollback as it would otherwise revert the new content.
        this._toRollback = false;
        // Placeholder hint.
        if (this.editable.textContent === '' && this.options.placeholder) {
            this._makeHint(this.editable.firstChild, this.options.placeholder, true);
        }
        this.multiselectionRefresh();
    }

    sanitize(target) {
        this.observerFlush();
        let record;
        if (!target) {
            // If the target is not given,
            // find the closest common ancestor to all the nodes referenced
            // in the mutations from the last step.
            for (record of this._currentStep.mutations) {
                const node = this.idFind(record.parentId || record.id) || this.editable;
                if (!this.editable.contains(node)) {
                    continue;
                }
                target = target
                    ? commonParentGet(target, node, this.editable)
                    : node;
            }
        }
        if (!target) {
            return false;
        }

        // If the common ancestor is in a nested list, make sure to sanitize
        // that list's parent <li> instead, so there is enough context to
        // potentially merge sibling nested lists
        // (eg, <ol>
        //          <li class="oe-nested"><ul>...</ul></li>
        //          <li class="oe-nested"><ul>...</ul></li>
        //      </ol>: these two lists should be merged together so the common
        // ancestor should be the <ol> element).
        const nestedListAncestor = closestElement(target, '.oe-nested');
        if (nestedListAncestor && nestedListAncestor.parentElement) {
            target = nestedListAncestor.parentElement;
        }

        // sanitize and mark current position as sanitized
        sanitize(target, this.editable);
        this._resetLinkInSelection();
        this._pluginCall('sanitizeElement',
                         [target.parentElement || target]);
        this.options.onPostSanitize(target);
    }

    addDomListener(element, eventName, callback, useCapture) {
        const boundCallback = callback.bind(this);
        this._domListeners.push([element, eventName, boundCallback]);
        element.addEventListener(eventName, boundCallback, useCapture);
    }

    /**
     * Make an absolute container to organise floating elements inside it's own
     * box and z-index isolation.
     *
     * @param {string} containerId An id to add to the container in order to make
     *              the container more visible in the devtool and potentially
     *              add css rules for the container and it's children.
     */
    makeAbsoluteContainer(containerId) {
        const container = this.document.createElement('div');
        container.className = `oe-absolute-container`;
        container.setAttribute('data-oe-absolute-container-id', containerId);
        this.mainAbsoluteContainer.append(container);
        return container;
    }

    _generateId() {
        // No need for secure random number.
        return Math.floor(Math.random() * Math.pow(2,52)).toString();
    }

    // Assign IDs to src, and dest if defined
    idSet(node, testunbreak = false) {
        if (!node.oid) {
            node.oid = this._generateId();
        }
        // In case the id was created by another collaboration client.
        this._idToNodeMap.set(node.oid, node);
        // Rollback if node.ouid changed. This ensures that nodes never change
        // unbreakable ancestors.
        node.ouid = node.ouid || getOuid(node, true);
        if (testunbreak && !(node.nodeType === Node.TEXT_NODE && !node.length)) {
            const ouid = getOuid(node);
            if (!this._toRollback && ouid && ouid !== node.ouid) {
                this._toRollback = UNBREAKABLE_ROLLBACK_CODE;
            }
        }

        let childNode = node.firstChild;
        while (childNode) {
            this.idSet(childNode, testunbreak);
            childNode = childNode.nextSibling;
        }
    }

    idFind(id) {
        return this._idToNodeMap.get(id);
    }

    serializeNode(node, mutatedNodes) {
        return this._collabClientId ? serializeNode(node, mutatedNodes) : node;
    }

    unserializeNode(node) {
        return this._collabClientId ? unserializeNode(node) : node;
    }

    automaticStepActive(label) {
        this._observerTimeoutUnactive.delete(label);
    }
    automaticStepUnactive(label) {
        this._observerTimeoutUnactive.add(label);
    }
    automaticStepSkipStack() {
        this.automaticStepUnactive('skipStack');
        setTimeout(() => this.automaticStepActive('skipStack'));
    }
    observerUnactive(label) {
        this._observerUnactiveLabels.add(label);
        if (this.observer) {
            clearTimeout(this.observerTimeout);
            this.observerFlush();
            this.dispatchEvent(new Event('observerUnactive'));
            this.observer.disconnect();
        }
    }
    observerFlush() {
        const records = this.observer.takeRecords();
        this.observerIdSet(records);
        this.observerApply(this.filterMutationRecords(records));
    }
    observerActive(label) {
        this._observerUnactiveLabels.delete(label);
        if (this._observerUnactiveLabels.size !== 0) return;

        if (!this.observer) {
            this.observer = new MutationObserver(records => {
                this.observerIdSet(records);
                records = this.filterMutationRecords(records);
                if (!records.length) return;
                this.dispatchEvent(new Event('contentChanged'));
                clearTimeout(this.observerTimeout);
                if (this._observerTimeoutUnactive.size === 0) {
                    this.observerTimeout = setTimeout(() => {
                        this.historyStep();
                    }, 100);
                }
                this.observerApply(records);
            });
        }
        this.dispatchEvent(new Event('preObserverActive'));
        this.observer.observe(this.editable, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeOldValue: true,
            characterData: true,
            characterDataOldValue: true,
        });
        this.dispatchEvent(new Event('observerActive'));
    }

    observerIdSet(records) {
        for (const record of records) {
            if (record.type === 'childList') {
                this.idSet(record.target);
            }
        }
    }

    observerApply(records) {
        // There is a case where node A is added and node B is a descendant of
        // node A where node B was not in the observed tree) then node B is
        // added into another node. In that case, we need to keep track of node
        // B so when serializing node A, we strip node B from the node A tree to
        // avoid the duplication of node A.
        const mutatedNodes = new Set();
        for (const record of records) {
            if (record.type === 'childList') {
                for (const node of record.addedNodes) {
                    this.idSet(node, this._checkStepUnbreakable);
                    mutatedNodes.add(node.oid);
                }
                for (const node of record.removedNodes) {
                    this.idSet(node, this._checkStepUnbreakable);
                    mutatedNodes.delete(node.oid);
                }
            }
        }
        for (const record of records) {
            switch (record.type) {
                case 'characterData': {
                    this._currentStep.mutations.push({
                        'type': 'characterData',
                        'id': record.target.oid,
                        'text': record.target.textContent,
                        'oldValue': record.oldValue,
                    });
                    break;
                }
                case 'attributes': {
                    this._currentStep.mutations.push({
                        'type': 'attributes',
                        'id': record.target.oid,
                        'attributeName': record.attributeName,
                        'value': record.target.getAttribute(record.attributeName),
                        'oldValue': record.oldValue,
                    });
                    break;
                }
                case 'childList': {
                    record.addedNodes.forEach(added => {
                        if (!this._toRollback && containsUnremovable(added)) {
                            this._toRollback = UNREMOVABLE_ROLLBACK_CODE;
                        }
                        const mutation = {
                            'type': 'add',
                        };
                        if (!record.nextSibling && record.target.oid) {
                            mutation.append = record.target.oid;
                        } else if (record.nextSibling && record.nextSibling.oid) {
                            mutation.before = record.nextSibling.oid;
                        } else if (!record.previousSibling && record.target.oid) {
                            mutation.prepend = record.target.oid;
                        } else if (record.previousSibling && record.previousSibling.oid) {
                            mutation.after = record.previousSibling.oid;
                        } else {
                            return false;
                        }
                        mutation.id = added.oid;
                        mutation.node = this.serializeNode(added, mutatedNodes);
                        this._currentStep.mutations.push(mutation);
                    });
                    record.removedNodes.forEach(removed => {
                        if (!this._toRollback && containsUnremovable(removed)) {
                            this._toRollback = UNREMOVABLE_ROLLBACK_CODE;
                        }
                        this._currentStep.mutations.push({
                            'type': 'remove',
                            'id': removed.oid,
                            'parentId': record.target.oid,
                            'node': this.serializeNode(removed),
                            'nextId': record.nextSibling ? record.nextSibling.oid : undefined,
                            'previousId': record.previousSibling
                                ? record.previousSibling.oid
                                : undefined,
                        });
                    });
                    break;
                }
            }
        }
        if (records.length) {
            this.dispatchEvent(new Event('observerApply'));
        }
    }
    filterMutationRecords(records) {
        // Save the first attribute in a cache to compare only the first
        // attribute record of node to its latest state.
        const attributeCache = new Map();
        const filteredRecords = [];

        for (const record of records) {
            if (record.type === 'attributes') {
                // Skip the attributes change on the dom.
                if (record.target === this.editable) continue;
                if (record.attributeName === 'contenteditable') {
                    continue;
                }

                attributeCache.set(record.target, attributeCache.get(record.target) || {});
                if (record.attributeName === 'class') {
                    const classBefore = (record.oldValue && record.oldValue.split(' ')) || [];
                    const classAfter = (record.target.className && record.target.className.split && record.target.className.split(' ')) || [];
                    const excludedClasses = [];
                    for (const klass of classBefore) {
                        if (!classAfter.includes(klass)) {
                            excludedClasses.push(klass);
                        }
                    }
                    for (const klass of classAfter) {
                        if (!classBefore.includes(klass)) {
                            excludedClasses.push(klass);
                        }
                    }
                    if (excludedClasses.length && excludedClasses.every(c => this.options.renderingClasses.includes(c))) {
                        continue;
                    }
                }
                if (
                    typeof attributeCache.get(record.target)[record.attributeName] === 'undefined'
                ) {
                    const oldValue = record.oldValue === undefined ? null : record.oldValue;
                    attributeCache.get(record.target)[record.attributeName] =
                        oldValue !== record.target.getAttribute(record.attributeName);
                }
                if (!attributeCache.get(record.target)[record.attributeName]) {
                    continue;
                }
            }
            const closestProtectedCandidate = closestElement(record.target, '[data-oe-protected]');
            if (closestProtectedCandidate) {
                const protectedValue = closestProtectedCandidate.dataset.oeProtected;
                switch (protectedValue) {
                    case "true":
                    case "":
                        if (
                            record.type !== "attributes" ||
                            record.target !== closestProtectedCandidate ||
                            isProtected(closestProtectedCandidate.parentElement)
                        ) {
                            continue;
                        }
                        break;
                    case "false":
                        if (
                            record.type === "attributes" &&
                            record.target === closestProtectedCandidate &&
                            isProtected(closestProtectedCandidate.parentElement)
                        ) {
                            continue;
                        }
                        break;
                }
            }
            filteredRecords.push(record);
        }
        return this.options.filterMutationRecords(filteredRecords);
    }

    // History
    // -------------------------------------------------------------------------

    historyReset() {
        this._historyClean();
        const firstStep = this._historyGetSnapshotStep();
        this._firstStepId = firstStep.id;
        this._historySnapshots = [{ step: firstStep }];
        this._historySteps.push(firstStep);
        // The historyIds carry the ids of the steps that were dropped when
        // doing a snapshot.
        // Those historyIds are used to compare if the last step saved in the
        // server is present in the current historySteps or historyIds to
        // ensure it is the same history branch.
        this._historyIds = [];
    }
    /**
     * Set the initial document history id.
     *
     * To prevent a saving a document with a diverging history, we store the
     * last history id in the first node of the document to the database.
     * This method provide the initial document history id to the editor.
     */
    historySetInitialId(id) {
        this._historyIds.unshift(id);
    }
    /**
     * Get all the history ids for the current history branch.
     *
     * See `_historyIds` in `historyReset`.
     */
    historyGetBranchIds() {
        return this._historyIds.concat(this._historySteps.map(s => s.id));
    }
    historyGetSnapshotSteps() {
        // If the current snapshot has no time, it means that there is the no
        // other snapshot that have been made (either it is the one created upon
        // initialization or reseted by historyResetFromSteps).
        if (!this._historySnapshots[0].time) {
            return { steps: this._historySteps, historyIds: this.historyGetBranchIds() };
        }
        const steps = [];
        let snapshot;
        if (this._historySnapshots[0].time + HISTORY_SNAPSHOT_BUFFER_TIME < Date.now()) {
            snapshot = this._historySnapshots[0];
        } else {
            // this._historySnapshots[1] has being created at least 1 minute ago
            // (HISTORY_SNAPSHOT_INTERVAL) or it is the first step.
            snapshot = this._historySnapshots[1];
        }
        let index = this._historySteps.length - 1;
        while (this._historySteps[index].id !== snapshot.step.id) {
            steps.push(this._historySteps[index]);
            index--;
        }
        steps.push(snapshot.step);
        steps.reverse();

        return { steps, historyIds: this.historyGetBranchIds() };
    }
    historyResetFromSteps(steps, historyIds) {
        this._historyIds = historyIds;
        this.observerUnactive();
        for (const node of [...this.editable.childNodes]) {
            node.remove();
        }
        this._historyClean();
        for (const step of steps) {
            this.historyApply(step.mutations);
        }
        this._historySnapshots = [{ step: steps[0] }];
        this._historySteps = steps;

        this._postProcessExternalStepsPromise = this.options.postProcessExternalSteps(this.editable);

        this._handleCommandHint();
        this.multiselectionRefresh();
        this.observerActive();
        this.dispatchEvent(new Event('historyResetFromSteps'));
    }
    historyGetSteps() {
        return this._historySteps;
    }
    historyGetMissingSteps({fromStepId, toStepId}) {
        const fromIndex = this._historySteps.findIndex(x => x.id === fromStepId);
        const toIndex = toStepId ? this._historySteps.findIndex(x => x.id === toStepId) : this._historySteps.length;
        if (fromIndex === -1 || toIndex === -1) {
            return -1;
        }
        return this._historySteps.slice(fromIndex + 1, toIndex);
    }

    // One step completed: apply to vDOM, setup next history step
    historyStep(skipRollback = false, { stepId } = {}) {
        if (!this._historyStepsActive) {
            return;
        }
        this.sanitize();
        // check that not two unBreakables modified
        if (this._toRollback) {
            if (!skipRollback) this.historyRollback();
            this._toRollback = false;
        }

        // push history
        const currentStep = this._currentStep;
        if (!currentStep.mutations.length) {
            return false;
        }

        currentStep.id = stepId || this._generateId();
        const previousStep = peek(this._historySteps);
        currentStep.clientId = this._collabClientId;
        currentStep.previousStepId = previousStep.id;

        this._historySteps.push(currentStep);
        if (this.options.onHistoryStep) {
            this.options.onHistoryStep(currentStep);
        }
        this._currentStep = {
            selection: {},
            mutations: [],
        };
        this._checkStepUnbreakable = true;
        this._recordHistorySelection();
        this.dispatchEvent(new Event('historyStep'));
        this.multiselectionRefresh();
    }
    // apply changes according to some records
    historyApply(records) {
        for (const record of records) {
            if (record.type === 'characterData') {
                const node = this.idFind(record.id);
                if (node) {
                    node.textContent = record.text;
                }
            } else if (record.type === 'attributes') {
                const node = this.idFind(record.id);
                if (node) {
                    let value = record.value;
                    if (typeof value === 'string' && record.attributeName === 'class') {
                        value = value.split(' ').filter(c => !this.options.renderingClasses.includes(c)).join(' ');
                    }
                    if (this._collabClientId) {
                        this._safeSetAttribute(node, record.attributeName, value);
                    } else {
                        node.setAttribute(record.attributeName, value);
                    }
                }
            } else if (record.type === 'remove') {
                const toremove = this.idFind(record.id);
                if (toremove) {
                    toremove.remove();
                }
            } else if (record.type === 'add') {
                let node = this.idFind(record.oid) || (record.node && this.unserializeNode(record.node));
                if (!node) {
                    continue;
                }
                if (this._collabClientId) {
                    const fakeNode = document.createElement('fake-el');
                    fakeNode.appendChild(node);
                    DOMPurify.sanitize(fakeNode, { IN_PLACE: true });
                    node = fakeNode.childNodes[0];
                    if (!node) {
                        continue;
                    }
                }

                this.idSet(node, true);

                if (record.append && this.idFind(record.append)) {
                    this.idFind(record.append).append(node);
                } else if (record.before && this.idFind(record.before)) {
                    this.idFind(record.before).before(node);
                } else if (record.after && this.idFind(record.after)) {
                    this.idFind(record.after).after(node);
                } else {
                    continue;
                }
            }
        }
    }
    historyRollback(until = 0) {
        const step = this._currentStep;
        this.observerFlush();
        this.historyRevert(step, { until });
        this.observerFlush();
        step.mutations = step.mutations.slice(0, until);
        this._toRollback = false;
    }
    /**
     * Undo the current non-recorded draft step.
     */
    historyRevertCurrentStep() {
        this.observerFlush();
        this.historyRevert(this._currentStep, {sideEffect: false});
        this.observerFlush();
        // Clear current step from all previous changes.
        this._currentStep.mutations = [];

        this._activateContenteditable();
        this.historySetSelection(this._currentStep);
    }
    /**
     * Undo a step of the history.
     *
     * this._historyStepsState is a map from it's location (index) in this.history to a state.
     * The state can be on of:
     * undefined: the position has never been undo or redo.
     * "redo": The position is considered as a redo of another.
     * "undo": The position is considered as a undo of another.
     * "consumed": The position has been undone and is considered consumed.
     */
    historyUndo() {
        this.options.preHistoryUndo();
        // The last step is considered an uncommited draft so always revert it.
        const lastStep = this._currentStep;
        this.historyRevert(lastStep);
        // Clean the last step otherwise if no other step is created after, the
        // mutations of the revert itself will be added to the same step and
        // grow exponentially at each undo.
        lastStep.mutations = [];

        const pos = this._getNextUndoIndex();
        if (pos > 0) {
            // Consider the position consumed.
            this._historyStepsStates.set(this._historySteps[pos].id, 'consumed');
            this.historyRevert(this._historySteps[pos]);
            // Consider the last position of the history as an undo.
            const stepId = this._generateId();
            this._historyStepsStates.set(stepId, 'undo');
            this.historyStep(true, { stepId });
            this.dispatchEvent(new Event('historyUndo'));
        }
    }
    /**
     * Redo a step of the history.
     *
     * @see historyUndo
     */
    historyRedo() {
        // Current step is considered an uncommitted draft, so revert it,
        // otherwise a redo would not be possible.
        this.historyRevert(this._currentStep);
        // At this point, _currentStep.mutations contains the current step's
        // mutations plus the ones that revert it, with net effect zero.
        this._currentStep.mutations = [];

        const pos = this._getNextRedoIndex();
        if (pos > 0) {
            this._historyStepsStates.set(this._historySteps[pos].id, 'consumed');
            this.historyRevert(this._historySteps[pos]);
            this.historySetSelection(this._historySteps[pos]);
            const stepId = this._generateId();
            this._historyStepsStates.set(stepId, 'redo');
            this.historyStep(true, { stepId });
            this.dispatchEvent(new Event('historyRedo'));
        }
    }
    /**
     * Check wether undoing is possible.
     */
    historyCanUndo() {
        return this._getNextUndoIndex() > 0;
    }
    /**
     * Check wether redoing is possible.
     */
    historyCanRedo() {
        return this._getNextRedoIndex() > 0;
    }
    historySize() {
        return this._historySteps.length;
    }

    historyRevert(step, { until = 0, sideEffect = true } = {} ) {
        // apply dom changes by reverting history steps
        for (let i = step.mutations.length - 1; i >= until; i--) {
            const mutation = step.mutations[i];
            if (!mutation) {
                break;
            }
            switch (mutation.type) {
                case 'characterData': {
                    const node = this.idFind(mutation.id);
                    if (node) node.textContent = mutation.oldValue;
                    break;
                }
                case 'attributes': {
                    const node = this.idFind(mutation.id);
                    if (node) {
                        if (mutation.oldValue) {
                            let value = mutation.oldValue;
                            if (typeof value === 'string' && mutation.attributeName === 'class') {
                                value = value.split(' ').filter(c => !this.options.renderingClasses.includes(c)).join(' ');
                            }
                            if (this._collabClientId) {
                                this._safeSetAttribute(node, mutation.attributeName, value);
                            } else {
                                node.setAttribute(mutation.attributeName, value);
                            }
                        } else {
                            node.removeAttribute(mutation.attributeName);
                        }
                    }
                    break;
                }
                case 'remove': {
                    let nodeToRemove = this.idFind(mutation.id);
                    if (!nodeToRemove) {
                        if (!mutation.node) {
                            continue;
                        }
                        nodeToRemove = this.unserializeNode(mutation.node);
                        const fakeNode = document.createElement('fake-el');
                        fakeNode.appendChild(nodeToRemove);
                        DOMPurify.sanitize(fakeNode, { IN_PLACE: true });
                        nodeToRemove = fakeNode.childNodes[0];
                        if (!nodeToRemove) {
                            continue;
                        }
                        this.idSet(nodeToRemove);
                    }
                    if (mutation.nextId && this.idFind(mutation.nextId)?.isConnected) {
                        const node = this.idFind(mutation.nextId);
                        node && node.before(nodeToRemove);
                    } else if (mutation.previousId && this.idFind(mutation.previousId)?.isConnected) {
                        const node = this.idFind(mutation.previousId);
                        node && node.after(nodeToRemove);
                    } else {
                        const node = this.idFind(mutation.parentId);
                        node && node.append(nodeToRemove);
                    }
                    break;
                }
                case 'add': {
                    const node = this.idFind(mutation.id);
                    if (node) {
                        node.remove();
                        node.ouid = undefined;
                    }
                }
            }
        }
        if (sideEffect) {
            this.historySetSelection(step);
        }
    }
    /**
     * Ensure that a callback is called without triggering a rollback.
     *
     * If a rollback was set before the callback, do not reset it.
     */
    withoutRollback(callback) {
        const priorRollback = this._toRollback;
        callback();
        this.observerFlush();
        if (!priorRollback) {
            this._toRollback = false;
        }
    }
    /**
     * Place the selection on the last known selection position from the history
     * steps.
     *
     * @param {boolean} [limitToEditable=false] When true returns the latest selection that
     *     happened within the editable.
     * @returns {boolean}
     */
    historyResetLatestComputedSelection(limitToEditable) {
        const computedSelection = limitToEditable
            ? this._latestComputedSelectionInEditable
            : this._latestComputedSelection;
        if (computedSelection && computedSelection.anchorNode) {
            const anchorNode = this.idFind(computedSelection.anchorNode.oid);
            const focusNode = this.idFind(computedSelection.focusNode.oid) || anchorNode;
            if (anchorNode) {
                setSelection(
                    anchorNode,
                    computedSelection.anchorOffset,
                    focusNode,
                    computedSelection.focusOffset,
                );
                return true;
            }
        }
        return false;
    }
    historySetSelection(step) {
        if (step.selection && step.selection.anchorNodeOid) {
            const anchorNode = this.idFind(step.selection.anchorNodeOid);
            const focusNode = this.idFind(step.selection.focusNodeOid) || anchorNode;
            if (anchorNode) {
                setSelection(
                    anchorNode,
                    step.selection.anchorOffset,
                    focusNode,
                    step.selection.focusOffset !== undefined
                        ? step.selection.focusOffset
                        : step.selection.anchorOffset,
                    false,
                );
                // If a table must be selected, ensure it's in the same tick.
                this._handleSelectionInTable();
            }
        }
    }
    unbreakableStepUnactive() {
        if (this._toRollback === UNBREAKABLE_ROLLBACK_CODE) {
            this._toRollback = false;
        }
        this._checkStepUnbreakable = false;
    }
    historyPauseSteps() {
        this._historyStepsActive = false;
    }
    historyUnpauseSteps() {
        this._historyStepsActive = true;
    }
    /**
     * Stash the mutations of the current step to re-apply them later.
     */
    historyStash() {
        if (!this._historyStashedMutations) {
            this._historyStashedMutations = [];
        }
        this._historyStashedMutations.push(...this._currentStep.mutations);
        this._currentStep.mutations = [];
    }
    /**
     * Unstash the previously stashed mutations into the current step.
     */
    historyUnstash() {
        if (!this._currentStep.mutations) {
            this._currentStep.mutations = [];
        }
        this._currentStep.mutations.unshift(...this._historyStashedMutations);
        this._historyStashedMutations = [];
    }
    _historyClean() {
        this._historySteps = [];
        this._currentStep = {
            selection: {
                anchorNodeOid: undefined,
                anchorOffset: undefined,
                focusNodeOid: undefined,
                focusOffset: undefined,
            },
            mutations: [],
            id: undefined,
            clientId: undefined,
        };
        this._historyStepsStates = new Map();
    }
    _historyGetSnapshotStep() {
        return {
            selection: {
                anchorNode: undefined,
                anchorOffset: undefined,
                focusNode: undefined,
                focusOffset: undefined,
            },
            mutations: Array.from(this.editable.childNodes).map(node => ({
                type: 'add',
                append: 1,
                id: node.oid,
                node: this.serializeNode(node),
            })),
            id: this._generateId(),
            clientId: this.clientId,
            previousStepId: undefined,
        };
    }
    _historyMakeSnapshot() {
        if (
            !this._lastSnapshotHistoryLength ||
            this._lastSnapshotHistoryLength < this._historySteps.length
        ) {
            this._lastSnapshotHistoryLength = this._historySteps.length;
            const step = this._historyGetSnapshotStep();
            step.id = this._historySteps[this._historySteps.length - 1].id;
            const snapshot = {
                time: Date.now(),
                step: step,
            };
            this._historySnapshots = [snapshot, this._historySnapshots[0]];
        }
    }
    /**
     * Insert a step from another collaborator.
     */
    _historyAddExternalStep(newStep) {
        let index = this._historySteps.length - 1;
        while (index >= 0 && this._historySteps[index].id !== newStep.previousStepId) {
            // Skip steps that are already in the list.
            if (this._historySteps[index].id === newStep.id) {
                return;
            }
            index--;
        }

        // When the previousStepId is not present in the this._historySteps it
        // could be either:
        // - the previousStepId is before a snapshot of the same history
        // - the previousStepId has not been received because clients were
        //   disconnected at that time
        // - the previousStepId is in another history (in case two totally
        //   differents this._historySteps (but it should not arise)).
        if (index < 0) {
            if (this.options.onHistoryMissingParentSteps) {
                const historySteps = this._historySteps;
                let index = historySteps.length - 1;
                // Get the last known step that we are sure the missing step
                // client has. It could either be a step that has the same
                // clientId or the first step.
                while(index !== 0) {
                    if (historySteps[index].clientId === newStep.clientId) {
                        break;
                    }
                    index--;
                }
                const fromStepId = historySteps[index].id;
                this.options.onHistoryMissingParentSteps({
                    step: newStep,
                    fromStepId: fromStepId,
                });
            }
            return;
        }

        let concurentSteps = [];
        index++;
        while (index < this._historySteps.length) {
            if (this._historySteps[index].previousStepId === newStep.previousStepId) {
                if (this._historySteps[index].id.localeCompare(newStep.id) === 1) {
                    break;
                } else {
                    concurentSteps = [this._historySteps[index].id];
                }
            } else {
                if (concurentSteps.includes(this._historySteps[index].previousStepId)) {
                    concurentSteps.push(this._historySteps[index].id);
                } else {
                    break;
                }
            }
            index++;
        }

        const stepsAfterNewStep = this._historySteps.slice(index);

        for (const stepToRevert of stepsAfterNewStep.slice().reverse()) {
            this.historyRevert(stepToRevert, { sideEffect: false });
        }
        this.historyApply(newStep.mutations);
        this._historySteps.splice(index, 0, newStep);
        for (const stepToApply of stepsAfterNewStep) {
            this.historyApply(stepToApply.mutations);
        }
    }
    collaborationSetClientId(id) {
        this._collabClientId = id;
    }

    /**
     * Apply external steps coming from the collaboration. Buffer them if
     * _postProcessExternalStepsPromise is not null until it is resolved (since
     * steps could potentially concern elements currently being rendered
     * asynchronously).
     *
     * @param {Object} newSteps External steps to be applied
     */
    onExternalHistorySteps(newSteps) {
        if (this._postProcessExternalStepsPromise) {
            this._externalStepsBuffer.push(...newSteps);
        }
        this.observerUnactive();
        this._computeHistorySelection();

        let stepIndex = 0;
        for (const newStep of newSteps) {
            this._historyAddExternalStep(newStep);
            stepIndex++;
            this._postProcessExternalStepsPromise = this.options.postProcessExternalSteps(this.editable);
            if (this._postProcessExternalStepsPromise) {
                this._postProcessExternalStepsPromise.then(() => {
                    this._postProcessExternalStepsPromise = undefined;
                    this.onExternalHistorySteps(this._externalStepsBuffer);
                });
                this._externalStepsBuffer = newSteps.slice(stepIndex);
                break;
            }
        }

        this.observerActive();
        this.historyResetLatestComputedSelection();
        this._handleCommandHint();
        this.multiselectionRefresh();
        this.dispatchEvent(new Event('onExternalHistorySteps'));
    }

    // Multi selection
    // -------------------------------------------------------------------------

    onExternalMultiselectionUpdate(selection) {
        const { clientId } = selection;
        const currentInfo = this._collabSelectionInfos.get(clientId);
        if (currentInfo) {
            currentInfo.selection = selection;
        } else {
            this._collabSelectionInfos.set(clientId, { selection });
        }
        this._drawClientSelection(selection);
        this._drawClientAvatar(selection);
        this._updateAvatarCounters();
    }

    multiselectionRefresh() {
        for (const { selection } of this._collabSelectionInfos.values()) {
            this._drawClientSelection(selection);
            this._drawClientAvatar(selection);
        }
        this._updateAvatarCounters();
    }

    _drawClientSelection({ selection, color, clientId, clientName = this.options._t('Anonymous') }) {
        this._multiselectionRemoveClient(clientId);
        let clientRects;

        let anchorNode = this.idFind(selection.anchorNodeOid);
        let focusNode = this.idFind(selection.focusNodeOid);
        let anchorOffset = selection.anchorOffset;
        let focusOffset = selection.focusOffset;
        if (!anchorNode || !focusNode) {
            anchorNode = this.editable.children[0];
            focusNode = this.editable.children[0];
            anchorOffset = 0;
            focusOffset = 0;
        }

        [anchorNode, anchorOffset] = getDeepestPosition(anchorNode, anchorOffset);
        [focusNode, focusOffset] = getDeepestPosition(focusNode, focusOffset);

        const direction = getCursorDirection(
            anchorNode,
            anchorOffset,
            focusNode,
            focusOffset,
        );
        const range = new Range();
        try {
            if (direction === DIRECTIONS.RIGHT) {
                range.setStart(anchorNode, anchorOffset);
                range.setEnd(focusNode, focusOffset);
            } else {
                range.setStart(focusNode, focusOffset);
                range.setEnd(anchorNode, anchorOffset);
            }

            clientRects = Array.from(range.getClientRects());
        } catch {
            // Changes in the dom might prevent the range to be instantiated
            // (because of a removed node for example), in which case we ignore
            // the range.
            clientRects = [];
        }
        if (!clientRects.length) {
            return;
        }

        // Draw rects (in case the selection is not collapsed).
        const containerRect = this._selectionsContainer.getBoundingClientRect();
        const indicators = clientRects.map(({ x, y, width, height }) => {
            const rectElement = this.document.createElement('div');
            rectElement.style = `
                position: absolute;
                top: ${y - containerRect.y}px;
                left: ${x - containerRect.x}px;
                width: ${width}px;
                height: ${height}px;
                background-color: ${color};
                opacity: 0.25;
                pointer-events: none;
            `;
            rectElement.setAttribute('data-selection-client-id', clientId);
            return rectElement;
        });

        // Draw carret.
        const caretElement = this.document.createElement('div');
        caretElement.style = `border-left: 2px solid ${color}; position: absolute;`;
        caretElement.setAttribute('data-selection-client-id', clientId);
        caretElement.className = 'oe-collaboration-caret';

        // Draw carret top square.
        const caretTopSquare = this.document.createElement('div');
        caretTopSquare.className = 'oe-collaboration-caret-top-square';
        caretTopSquare.style['background-color'] = color;
        caretTopSquare.setAttribute('data-client-name', clientName);
        caretElement.append(caretTopSquare);

        if (direction === DIRECTIONS.LEFT) {
            const rect = clientRects[0];
            caretElement.style.height = `${rect.height * 1.2}px`;
            caretElement.style.top = `${rect.y - containerRect.y}px`;
            caretElement.style.left = `${rect.x - containerRect.x}px`;
        } else {
            const rect = peek(clientRects);
            caretElement.style.height = `${rect.height * 1.2}px`;
            caretElement.style.top = `${rect.y - containerRect.y}px`;
            caretElement.style.left = `${rect.right - containerRect.x}px`;
        }
        this._selectionsContainer.append(caretElement, ...indicators);
    }

    _drawClientAvatar({ selection, clientId, clientAvatarUrl = '', clientName = this.options._t('Anonymous') }) {
        const anchorNode = this.idFind(selection.anchorNodeOid);
        const focusNode = this.idFind(selection.focusNodeOid);
        if (!anchorNode || !focusNode) {
            return;
        }
        const anchorBlock = closestBlock(anchorNode);
        if (!anchorBlock) return;

        const containerRect = this._avatarsContainer.getBoundingClientRect();

        // Draw user avatar.
        const selectionInfo = this._collabSelectionInfos.get(clientId) || {};
        let avatarElement = selectionInfo.avatarElement;
        if (!avatarElement) {
            avatarElement = this.document.createElement('div');
            avatarElement.className = 'oe-collaboration-caret-avatar';
            avatarElement.style.display = 'none';
            const image = this.document.createElement('img');
            avatarElement.append(image);
            image.onload = () => avatarElement.style.removeProperty('display');
            image.setAttribute('src', clientAvatarUrl);
            image.classList.add('o_object_fit_cover');
        }
        // Avoid re-appending the element in the dom.
        if (!avatarElement.parentElement) {
            this._avatarsContainer.append(avatarElement);
        }
        // Make sure data is up to date.
        selectionInfo.avatarElement = avatarElement;
        selectionInfo.clientName = clientName;
        selectionInfo.avatarTargetElement = anchorBlock;
        this._collabSelectionInfos.set(clientId, selectionInfo);

        const anchorBlockRect = anchorBlock.getBoundingClientRect();
        const top = anchorBlockRect.y - containerRect.y;
        avatarElement.style.top = top + 'px';
        const closestList = closestElement(anchorNode, 'ul, ol'); // Prevent overlap bullets.
        const anchorX = closestList ? closestList.getBoundingClientRect().x : anchorBlockRect.x;
        const left = anchorX - containerRect.x - AVATAR_SIZE;
        avatarElement.style.left = left + 'px';
        selectionInfo.avatarPositionKey = `${left}|${top}`;
    }

    _updateAvatarCounters() {
        this._avatarsOverlaps = {};
        for (const info of this._collabSelectionInfos.values()) {
            const key =  info.avatarPositionKey;
            this._avatarsOverlaps[key] = this._avatarsOverlaps[key] || new Set();
            this._avatarsOverlaps[key].add(info);
        }

        // Render avatars overlap.
        this._avatarsCountersContainer.replaceChildren();
        for (const [overlapKey, infos] of Object.entries(this._avatarsOverlaps)) {
            const size = infos.size;
            if (size > 1) {
                const [left, top] = overlapKey.split('|').map((n) => parseInt(n, 10));
                const div = document.createElement('div');
                div.className = 'oe-overlapping-counter';
                div.style.left = left + 10 + 'px';
                div.style.top = top + 10 + 'px';
                div.innerText = size;
                this._avatarsCountersContainer.append(div);
            }
        }
    }

    multiselectionRemove(clientId) {
        const selectionInfo = this._collabSelectionInfos.get(clientId);
        if (selectionInfo && selectionInfo.avatarElement) {
            selectionInfo.avatarElement.remove();
        }
        this._multiselectionRemoveClient(clientId)
        this._collabSelectionInfos.delete(clientId);
        this._updateAvatarCounters();
    }

    _multiselectionRemoveClient(clientId) {
        const elements = this._selectionsContainer.querySelectorAll(
            `[data-selection-client-id="${clientId}"]`,
        );
        for (const element of elements) {
            element.remove();
        }
    }

    /**
     * Same as @see _applyCommand, except that also simulates all the
     * contenteditable behaviors we let happen, e.g. the backspace handling
     * we then rollback.
     *
     * TODO this uses document.execCommand (which is deprecated) and relies on
     * the fact that using a command through it leads to the same result as
     * executing that command through a user keyboard on the unaltered editable
     * section with standard contenteditable attribute. This is already a huge
     * assomption.
     *
     * @param {string} method
     * @returns {?}
     */
    execCommand(...args) {
        this._computeHistorySelection();
        return this._applyCommand(...args);
    }

    /**
     * Find all descendants of `element` with a `data-call` attribute and bind
     * them on click to the execution of the command matching that
     * attribute.
     */
    bindExecCommand(element) {
        for (const buttonEl of element.querySelectorAll('[data-call]')) {
            buttonEl.addEventListener('click', ev => {
                if (!this.isSelectionInEditable()) {
                    this.historyResetLatestComputedSelection(true);
                }
                const arg1 = buttonEl.dataset.arg1;
                const args = arg1 && arg1.split(",") || [];
                this.execCommand(buttonEl.dataset.call, ...args);

                ev.preventDefault();
                this._updateToolbar();
            });
        }
    }

    /**
     * Remove any custom table selection from the editor.
     *
     * @returns {boolean} true if a table was deselected
     */
    deselectTable() {
        const tds = this.editable.querySelectorAll('.o_selected_table, .o_selected_td');
        if (!tds.length) {
            return false;
        }
        this.observerUnactive('deselectTable');
        for (const td of tds) {
            td.classList.remove('o_selected_td', 'o_selected_table');
            if (!td.classList.length) {
                td.removeAttribute('class');
            }
        }
        this.observerActive('deselectTable');
        return true;
    }

    /**
     * `activateContenteditable` serves as an interface for external use,
     * allowing users to conveniently trigger `_activateContenteditable`
     * from outside the odooEditor.
     */
    activateContenteditable() {
        this.canActivateContentEditable = true;
        this._activateContenteditable();
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    _removeDomListener() {
        for (const [element, eventName, boundCallback] of this._domListeners) {
            element.removeEventListener(eventName, boundCallback);
        }
        this._domListeners = [];
    }

    // EDITOR COMMANDS
    // ===============

    deleteRange(sel) {
        if (this.deleteTableRange()) {
            return;
        }
        // Remove all FEFF text nodes
        let range = getDeepRange(this.editable, { sel, correctTripleClick: true });
        if (!range) return;
        for (const node of descendants(closestBlock(range.commonAncestorContainer))) {
            if (node.nodeType === Node.TEXT_NODE && [...node.textContent].every(char => char === '\uFEFF')) {
                const restore = prepareUpdate(...leftPos(node));
                node.remove();
                restore(); // Make sure to make <br>s visible if needed.
            }
        }
        if (!this.editable.childElementCount) {
            // Ensure the editable has content.
            const p = document.createElement('p');
            p.append(document.createElement('br'));
            this.editable.append(p);
            setSelection(p, 0);
            return;
        }
        range = getDeepRange(this.editable, {
            sel,
            splitText: true,
            select: true,
            correctTripleClick: true,
        });
        if (!range) return;
        // Expand the range to fully include all contentEditable=False elements.
        const commonAncestorContainer = this.editable.contains(range.commonAncestorContainer) ?
            range.commonAncestorContainer :
            this.editable;
        const startUneditable = getFurthestUneditableParent(range.startContainer, commonAncestorContainer);
        if (startUneditable) {
            let leaf = previousLeaf(startUneditable);
            if (leaf) {
                range.setStart(leaf, nodeSize(leaf));
            } else {
                range.setStart(commonAncestorContainer, 0);
            }
        }
        const endUneditable = getFurthestUneditableParent(range.endContainer, commonAncestorContainer);
        if (endUneditable) {
            let leaf = nextLeaf(endUneditable);
            if (leaf) {
                range.setEnd(leaf, 0);
            } else {
                range.setEnd(commonAncestorContainer, nodeSize(commonAncestorContainer));
            }
        }
        let insertedZws;
        let { startContainer: start, startOffset, endContainer: end, endOffset } = range;
        const startBlock = closestBlock(start);
        const endBlock = closestBlock(end);
        const [firstLeafOfStartBlock, lastLeafOfEndBlock] = [firstLeaf(startBlock), lastLeaf(endBlock)];
        const startLink = closestElement(range.startContainer, 'a');
        if (sel && !sel.isCollapsed && !range.startOffset && !range.startContainer.previousSibling && !startLink) {
            // Insert a zero-width space before the selection if the selection
            // is non-collapsed and at the beginning of its parent, so said
            // parent will have content after extraction. This ensures that the
            // parent will not be removed by "tricking" `range.extractContents`.
            // Eg, <h1><font>[...]</font></h1> will preserve the styles of the
            // <font> node. If it remains empty, it will be cleaned up later by
            // the sanitizer.
            // Links are excluded from this.
            const zws = document.createTextNode('\u200B');
            range.startContainer.before(zws);
            insertedZws = zws;
        }
        // Do not join blocks in the following cases:
        // 1. start and end share a common ancestor block with the range
        // 2. selection spans multiple TDs
        // 3. selection starts at beginning of startBlock and ends at end of
        //    endBlock
        const doJoin =
            !(startBlock === closestBlock(range.commonAncestorContainer) &&
                endBlock === closestBlock(range.commonAncestorContainer))
            && (startBlock.tagName !== 'TD' && endBlock.tagName !== 'TD')
            && !(firstLeafOfStartBlock === start && lastLeafOfEndBlock === end);
        let next = nextLeaf(end, this.editable);

        // Get the boundaries of the range so as to get the state to restore.
        if (end.nodeType === Node.TEXT_NODE) {
            splitTextNode(end, endOffset);
            endOffset = nodeSize(end);
        }
        if (start.nodeType === Node.TEXT_NODE) {
            splitTextNode(start, startOffset);
            startOffset = 0;
        }
        const restoreUpdate = prepareUpdate(
            ...boundariesOut(start).slice(0, 2),
            ...boundariesOut(end).slice(2, 4),
            { allowReenter: false, label: 'deleteRange' });

        // Let the DOM split and delete the range.
        const contents = range.extractContents();

        setSelection(start, nodeSize(start));
        const startLi = closestElement(start, 'li');
        // Uncheck a list item with empty text in multi-list selection.
        if (startLi && startLi.classList.contains('o_checked') &&
            ['\u200B', ''].includes(startLi.textContent) && closestElement(end, 'li') !== startLi) {
            startLi.classList.remove('o_checked');
        }
        range = getDeepRange(this.editable, { sel });
        // Restore unremovables removed by extractContents.
        [...contents.querySelectorAll('*')].filter(isUnremovable).forEach(n => {
            closestBlock(range.endContainer).after(n);
            n.textContent = '';
        });
        // If the end container was fully selected, extractContents may have
        // emptied it without removing it. Ensure it's gone.
        const isRemovableInvisible = node =>
            !isVisible(node) && !isZWS(node) && !isUnremovable(node);
        const endIsStart = end === start;
        while (end && isRemovableInvisible(end) && !end.contains(range.endContainer)) {
            const parent = end.parentNode;
            end.remove();
            end = parent;
        }
        // Same with the start container
        while (
            start &&
            !isBlock(start) && isRemovableInvisible(start) &&
            !(endIsStart && start.contains(range.startContainer))
        ) {
            const parent = start.parentNode;
            start.remove();
            start = parent;
        }
        // Ensure empty blocks be given a <br> child.
        if (start) {
            if (start === this.editable && startBlock.textContent === '\u200B') {
                const p = document.createElement('p');
                start.appendChild(p);
                start = p;
            }
            fillEmpty(closestBlock(start));
        }
        fillEmpty(closestBlock(range.endContainer));
        range = getDeepRange(this.editable, { sel });
        let joinWith = range.endContainer;
        const rightLeaf = rightLeafOnlyNotBlockPath(joinWith).next().value;
        if (rightLeaf && rightLeaf.nodeValue === ' ') {
            joinWith = rightLeaf;
        }
        // Rejoin blocks that extractContents may have split in two.
        while (
            doJoin &&
            next &&
            !(next.previousSibling && next.previousSibling === joinWith) &&
            this.editable.contains(next) && (closestElement(joinWith,'TD') === closestElement(next, 'TD'))
        ) {
            const restore = preserveCursor(this.document);
            this.observerFlush();
            const res = this._protect(() => {
                next.oDeleteBackward();
                if (!this.editable.contains(joinWith)) {
                    this._toRollback = UNREMOVABLE_ROLLBACK_CODE; // tried to delete too far -> roll it back.
                } else {
                    next = firstLeaf(next);
                }
            }, this._currentStep.mutations.length);
            if ([UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE].includes(res)) {
                restore();
                break;
            }
        }
        // If the oDeleteBackward loop emptied the start block and the range
        // ends in another element (rangeStart !== rangeEnd), we delete the
        // start block and move the cursor to the end block.
        if (
            startBlock &&
            startBlock.textContent === '\u200B' &&
            endBlock &&
            startBlock !== endBlock &&
            !isEmptyBlock(endBlock) &&
            paragraphRelatedElements.includes(endBlock.nodeName)
        ) {
            startBlock.remove();
            setSelection(endBlock, 0);
            fillEmpty(endBlock);
        }
        if (insertedZws) {
            // Remove the zero-width space (zws) that was added to preserve the
            // parent styles, then call `fillEmpty` to properly add a flagged
            // zws if still needed.
            const el = closestElement(insertedZws);
            const next = insertedZws.nextSibling;
            insertedZws.remove();
            el && fillEmpty(el);
            setSelection(next, 0);
        }
        if (joinWith) {
            const el = closestElement(joinWith);
            el && fillEmpty(el);
        }
        const restoreCursor = preserveCursor(this.document);
        restoreUpdate();
        restoreCursor();
    }

    /**
     * Handle range deletion in cases that involve custom table selections.
     * Return true if nodes removed _inside_ a table, false otherwise (or if the
     * table itself was removed).
     *
     * @param {Selection} sel
     * @returns {boolean}
     */
    deleteTableRange() {
        const selectedTds = this.editable.querySelectorAll('.o_selected_td');
        const fullySelectedTables = [...this.editable.querySelectorAll('.o_selected_table')].filter(table => (
            [...table.querySelectorAll('td')].every(td => td.classList.contains('o_selected_td'))
        ));
        if (selectedTds.length && !fullySelectedTables.length) {
            this.historyPauseSteps();
            // A selection within a table has to be handled differently so it
            // takes into account the custom table cell selections, and doesn't
            // break the table. If the selection includes a table cell but also
            // elements that are out of a table, the whole table will be
            // selected so its deletion can be handled separately.
            const rows = [...closestElement(selectedTds[0], 'tr').parentElement.children].filter(child => child.nodeName === 'TR');
            const firstRowCells = [...rows[0].children].filter(child => child.nodeName === 'TD' || child.nodeName === 'TH');
            const areFullColumnsSelected = getRowIndex(selectedTds[0]) === 0 && getRowIndex(selectedTds[selectedTds.length - 1]) === rows.length - 1;
            const areFullRowsSelected = getColumnIndex(selectedTds[0]) === 0 && getColumnIndex(selectedTds[selectedTds.length - 1]) === firstRowCells.length - 1;
            if (areFullColumnsSelected || areFullRowsSelected) {
                // If some full columns are selected, remove them.
                if (areFullColumnsSelected) {
                    const startIndex = getColumnIndex(selectedTds[0]);
                    let endIndex = getColumnIndex(selectedTds[selectedTds.length - 1]);
                    let currentIndex = startIndex;
                    while (currentIndex <= endIndex) {
                        this.execCommand('removeColumn', firstRowCells[currentIndex]);
                        currentIndex++;
                    }
                }
                // If some full rows are selected, remove them.
                if (areFullRowsSelected) {
                    const startIndex = getRowIndex(selectedTds[0]);
                    let endIndex = getRowIndex(selectedTds[selectedTds.length - 1]);
                    let currentIndex = startIndex;
                    while (currentIndex <= endIndex) {
                        this.execCommand('removeRow', rows[currentIndex]);
                        currentIndex++;
                    }
                }
            } else {
                // If no full row or column is selected, empty the selected cells.
                for (const td of selectedTds) {
                    [...td.childNodes].forEach(child => child.remove());
                    td.append(document.createElement('br'));
                }
            }
            this.historyUnpauseSteps();
            this.historyStep();
            return true;
        } else if (fullySelectedTables.length) {
            fullySelectedTables.forEach(table => table.remove());
        }
        this._toggleTableUi();
        return false;
    }

    /**
     * Displays the text colors (foreground ink and background highlight)
     * based on the current text cursor position. For gradients, displays
     * the average color of the gradient.
     *
     * @param {object} [params]
     * @param {string} [params.foreColor] - forces the 'foreColor' in the
     *     toolbar instead of determining it from the cursor position
     * @param {string} [params.hiliteColor] - forces the 'hiliteColor' in the
     *     toolbar instead of determining it from the cursor position
     */
    updateColorpickerLabels(params = {}) {
        function hexFromColor(color) {
            if (isColorGradient(color)) {
                // For gradients, compute the average color
                color = color.match(/gradient(.*)/)[0];
                let r = 0, g = 0, b = 0, count = 0;
                for (const entry of color.matchAll(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/g)) {
                    count++;
                    r += parseInt(entry[1], 10);
                    g += parseInt(entry[2], 10);
                    b += parseInt(entry[3], 10);
                }
                color = `rgb(${Math.round(r / count)}, ${Math.round(g / count)}, ${Math.round(b / count)})`;
            }
            return rgbToHex(color);
        }
        let foreColor = params.foreColor;
        let hiliteColor = params.hiliteColor;

        // Determine colors at cursor position
        const sel = this.document.getSelection();
        if (sel.rangeCount && (!foreColor || !hiliteColor)) {
            const endContainer = closestElement(sel.getRangeAt(0).endContainer);
            const computedStyle = getComputedStyle(endContainer);
            const backgroundImage = computedStyle.backgroundImage;
            const hasGradient = isColorGradient(backgroundImage);
            const hasTextGradientClass = endContainer.classList.contains('text-gradient');
            if (!foreColor) {
                if (hasGradient && hasTextGradientClass) {
                    foreColor = backgroundImage;
                } else {
                    foreColor = this.document.queryCommandValue('foreColor');
                }
            }
            if (!hiliteColor) {
                if (hasGradient && !hasTextGradientClass) {
                    hiliteColor = backgroundImage;
                } else {
                    let ancestor = endContainer;
                    while (ancestor && !hiliteColor) {
                        hiliteColor = ancestor.style.backgroundColor;
                        ancestor = ancestor.parentElement;
                    }
                    if (!hiliteColor) {
                        hiliteColor = this.document.queryCommandValue('backColor');
                    }
                }
            }
        }

        // display colors in toolbar buttons
        foreColor = hexFromColor(foreColor);
        this.toolbar.style.setProperty('--fore-color', foreColor);
        const foreColorInput = this.toolbar.querySelector('#foreColor input');
        if (foreColorInput) {
            foreColorInput.value = foreColor;
        }

        hiliteColor = hexFromColor(hiliteColor);
        this.toolbar.style.setProperty('--hilite-color', hiliteColor);
        const hiliteColorInput = this.toolbar.querySelector('#hiliteColor input');
        if (hiliteColorInput) {
            hiliteColorInput.value = hiliteColor.length <= 7 ? hiliteColor : hexFromColor(hiliteColor);
        }
    }

    /**
     * Applies the given command to the current selection. This does *NOT*:
     * 1) update the history cursor
     * 2) protect the unbreakables or unremovables
     * 3) sanitize the result
     * 4) create new history entry
     * 5) follow the exact same operations that would be done following events
     *    that would lead to that command
     *
     * For points 1 -> 4, @see _applyCommand
     * For points 1 -> 5, @see execCommand
     *
     * @private
     * @param {string} method
     * @returns {?}
     */
    _applyRawCommand(method, ...args) {
        const sel = this.document.getSelection();
        if (sel.anchorNode && isProtected(sel.anchorNode)) {
            return;
        }
        if (!(SELECTIONLESS_COMMANDS.includes(method) && args.length) &&
            !this.isSelectionInEditable(sel) &&
            !(closestElement(sel.anchorNode, "*[t-field],*[t-out],*[t-esc]") && FORMATTING_COMMANDS.includes(method))
        ) {
            // Do not apply commands out of the editable area.
            return false;
        }
        if (!sel.isCollapsed && BACKSPACE_FIRST_COMMANDS.includes(method)) {
            let range = getDeepRange(this.editable, {sel, splitText: true, select: true, correctTripleClick: true});
            if (range &&
                range.startContainer === range.endContainer &&
                range.endContainer.nodeType === Node.TEXT_NODE &&
                ZERO_WIDTH_CHARS.includes(range.cloneContents().textContent)
            ) {
                // We Collapse the selection and bypass deleteRange
                // if the range content is only one ZWS.
                sel.collapseToStart();
                if (BACKSPACE_ONLY_COMMANDS.includes(method)) {
                    this._applyRawCommand(method);
                }
                return;
            }
            this.deleteRange(sel);
            if (BACKSPACE_ONLY_COMMANDS.includes(method)) {
                return true;
            }
        }

        this.options.beforeAnyCommand();

        if (editorCommands[method]) {
            return editorCommands[method](this, ...args);
        }
        if (method.startsWith('justify')) {
            const mode = method.split('justify').join('').toLocaleLowerCase();
            return this._align(mode === 'full' ? 'justify' : mode);
        }
        return sel.anchorNode[method](sel.anchorOffset, ...args);
    }

    /**
     * Same as @see _applyRawCommand but adapt history, protects unbreakables
     * and removables and sanitizes the result.
     *
     * @private
     * @param {string} method
     * @returns {?}
     */
    _applyCommand(...args) {
        this._recordHistorySelection(true);
        const result = this._protect(() => this._applyRawCommand(...args));
        this.historyStep();
        this._handleCommandHint();
        return result;
    }
    /**
     * @private
     * @param {function} callback
     * @param {number} [rollbackCounter]
     * @returns {?}
     */
    _protect(callback, rollbackCounter) {
        try {
            const result = callback.call(this);
            this.observerFlush();
            if (this._toRollback) {
                const torollbackCode = this._toRollback;
                this.historyRollback(rollbackCounter);
                return torollbackCode; // UNBREAKABLE_ROLLBACK_CODE || UNREMOVABLE_ROLLBACK_CODE
            } else {
                return result;
            }
        } catch (error) {
            if (error === UNBREAKABLE_ROLLBACK_CODE || error === UNREMOVABLE_ROLLBACK_CODE) {
                this.historyRollback(rollbackCounter);
                return error;
            } else {
                throw error;
            }
        }
    }
    _activateContenteditable() {
        this.observerUnactive('_activateContenteditable');
        this.editable.setAttribute('contenteditable', this.options.isRootEditable);

        const editableAreas = this.options.getContentEditableAreas(this);
        for (const node of editableAreas) {
            if (!node.isContentEditable) {
                if (isArtificialVoidElement(node) || node.nodeName === 'IMG') {
                    node.classList.add('o_editable_media');
                } else {
                    node.setAttribute('contenteditable', true);
                }
            }
        }
        for (const node of this.options.getReadOnlyAreas()) {
            node.setAttribute('contenteditable', false);
        }
        for (const element of this.options.getUnremovableElements()) {
            element.classList.add("oe_unremovable");
        }
        this.observerActive('_activateContenteditable');
    }

    _stopContenteditable() {
        this.observerUnactive('_stopContenteditable');
        if (this.options.isRootEditable) {
            this.editable.setAttribute('contenteditable', !this.options.isRootEditable);
        }
        for (const node of this.options.getContentEditableAreas(this)) {
            if (node.getAttribute('contenteditable') === 'true') {
                node.setAttribute('contenteditable', false);
            }
        }
        this.observerActive('_stopContenteditable');
    }

    // TABLE MANAGEMENT
    // ================

    /**
     * Handle the selection of table cells rectangularly (as opposed to line by
     * line from left to right then top to bottom). If such a special selection
     * was indeed applied, return true (and false otherwise).
     *
     * @private
     * @param {MouseEvent|undefined} [ev]
     * @returns {boolean}
     */
    _handleSelectionInTable(ev=undefined) {
        const selection = this.document.getSelection();
        // Selection could be gone if the document comes from an iframe that has been removed.
        const anchorNode = selection && selection.rangeCount && selection.getRangeAt(0) && selection.anchorNode;
        if (anchorNode && !ancestors(anchorNode).includes(this.editable)) {
            return false;
        }
        const traversedNodes = getTraversedNodes(this.editable);
        if (this._isResizingTable || !traversedNodes.some(node => !!closestElement(node, 'td') && !isProtected(node))) {
            return false;
        }
        let range;
        if (this.isFirefox) {
            if (selection.rangeCount > 1) {
                // In Firefox, selecting multiple cells within a table using the mouse can create multiple ranges.
                // This behavior can cause the original selection (where the selection started) to be lost.
                // To address this, we reset the selection to the _latestComputedSelection, ensuring that
                // even when multiple ranges are selected, the original selection remains accessible.
                this.historyResetLatestComputedSelection(true);
            } else if (
                ev &&
                closestElement(ev.target, 'table') === closestElement(selection.anchorNode, 'table') &&
                closestElement(ev.target, 'td') !== closestElement(selection.focusNode, 'td')
            ) {
                // When we modify a multiple range selection to a single range selection,
                // Firefox stops updating the selection automatically.
                // As a result, we need to manually update the selection based on the current target.
                setSelection(selection.anchorNode, selection.anchorOffset, ev.target, 0);
            }
            // We need the triple click correction only for a bug in firefox
            // where it gives a selection of a full cell as tr 0 tr 1. The
            // correction makes it so it gives us the cell and not its neighbor.
            // In all other cases we don't want to make that correction so as to
            // avoid flicker when hovering borders.
            range = getDeepRange(this.editable, { correctTripleClick: anchorNode && anchorNode.nodeName === 'TR' });
        } else {
            range = getDeepRange(this.editable);
        }
        const startTd = closestElement(range.startContainer, 'td');
        const endTd = closestElement(range.endContainer, 'td');
        let appliedCustomSelection = false;
        // Get the top table ancestors at range bounds.
        const startTable = ancestors(range.startContainer, this.editable).filter(node => node.nodeName === 'TABLE').pop();
        const endTable = ancestors(range.endContainer, this.editable).filter(node => node.nodeName === 'TABLE').pop();
        if (startTd !== endTd && startTable === endTable) {
            if (!isProtected(startTable)) {
                // The selection goes through at least two different cells ->
                // select cells.
                this._selectTableCells(range);
                appliedCustomSelection = true;
            }
        } else if (!traversedNodes.every(node => node.parentElement && closestElement(node.parentElement, 'table')) && !selection.isCollapsed) {
            // The selection goes through a table but also outside of it ->
            // select the whole table.
            this.observerUnactive('handleSelectionInTable');
            const traversedTables = new Set(
                traversedNodes
                    .map((node) => closestElement(node, "table"))
                    .filter((node) => !isProtected(node))
            );
            for (const table of traversedTables) {
                // Don't apply several nested levels of selection.
                if (table && !ancestors(table, this.editable).some(node => [...traversedTables].includes(node))) {
                    table.classList.toggle('o_selected_table', true);
                    for (const td of [...table.querySelectorAll('td')].filter(td => closestElement(td, 'table') === table)) {
                        td.classList.toggle('o_selected_td', true);
                    }
                    appliedCustomSelection = true;
                }
            }
            this.observerActive('handleSelectionInTable');
        } else if (ev && startTd && !isProtected(startTd)) {
            // We're redirected from a mousemove event.
            const selectedNodes = getSelectedNodes(this.editable);
            const cellContents = descendants(startTd);
            const areCellContentsFullySelected = cellContents.filter(d => !isBlock(d)).every(child => selectedNodes.includes(child));
            if (areCellContentsFullySelected) {
                const SENSITIVITY = 5;
                const rangeRect = range.getBoundingClientRect();
                const isMovingAwayFromSelection = ev.clientX > rangeRect.x + rangeRect.width + SENSITIVITY // moving right
                    || ev.clientX < rangeRect.x - SENSITIVITY; // moving left
                if (isMovingAwayFromSelection) {
                    // A cell is fully selected and the mouse is moving away
                    // from the selection, within said cell -> select the cell.
                    this._selectTableCells(range);
                    appliedCustomSelection = true;
                }
            } else if (cellContents.filter(isBlock).every(isEmptyBlock) &&
                Math.abs(ev.clientX - (this._lastMouseClickPosition ? this._lastMouseClickPosition[0] : ev.clientX)) >= 15
            ) {
                // Handle selecting an empty cell.
                this._selectTableCells(range);
                appliedCustomSelection = true;
            }
        }
        return appliedCustomSelection;
    }
    /**
     * Helper function to `_handleSelectionInTable`. Do the actual selection of
     * cells in a table based on the current range.
     *
     * @private
     * @see _handleSelectionInTable
     * @param {Range} range
     */
    _selectTableCells(range) {
        const table = closestElement(range.commonAncestorContainer, 'table');
        if (!table) {
            return;
        }
        this.observerUnactive('_selectTableCells');
        const alreadyHadSelection = table.classList.contains('o_selected_table');
        this.deselectTable(); // Undo previous selection.
        table.classList.toggle('o_selected_table', true);
        const columns = [...table.querySelectorAll('td')].filter(td => closestElement(td, 'table') === table);
        const startCol = [range.startContainer, ...ancestors(range.startContainer, this.editable)]
            .find(node => node.nodeName === 'TD' && closestElement(node, 'table') === table) || columns[0];
        const endCol = [range.endContainer, ...ancestors(range.endContainer, this.editable)]
            .find(node => node.nodeName === 'TD' && closestElement(node, 'table') === table) || columns[columns.length - 1];
        const [startRow, endRow] = [closestElement(startCol, 'tr'), closestElement(endCol, 'tr')];
        const [startColIndex, endColIndex] = [getColumnIndex(startCol), getColumnIndex(endCol)];
        const [startRowIndex, endRowIndex] = [getRowIndex(startRow), getRowIndex(endRow)];
        const [minRowIndex, maxRowIndex] = [Math.min(startRowIndex, endRowIndex), Math.max(startRowIndex, endRowIndex)];
        const [minColIndex, maxColIndex]  = [Math.min(startColIndex, endColIndex), Math.max(startColIndex, endColIndex)];
        // Create an array of arrays of tds (each of which is a row).
        const grid = [...table.querySelectorAll('tr')]
            .filter(tr => closestElement(tr, 'table') === table)
            .map(tr => [...tr.children].filter(child => child.nodeName === 'TD'));
        for (const tds of grid.filter((_, index) => index >= minRowIndex && index <= maxRowIndex)) {
            for (const td of tds.filter((_, index) => index >= minColIndex && index <= maxColIndex)) {
                td.classList.toggle('o_selected_td', true);
            }
        }
        if (!alreadyHadSelection) {
            this.toolbarShow();
        }
        this.observerActive('_selectTableCells');
    }
    /**
     * If the mouse is hovering over one of the borders of a table cell element,
     * return the side of that border ('left'|'top'|'right'|'bottom').
     * Otherwise, return false.
     *
     * @private
     * @param {MouseEvent} ev
     * @returns {boolean}
     */
    _isHoveringTdBorder(ev) {
        if (ev.target && ev.target.nodeName === 'TD' && ev.target.isContentEditable) {
            const SENSITIVITY = 5;
            const targetRect = ev.target.getBoundingClientRect();
            if (ev.clientX <= targetRect.x + SENSITIVITY) {
                return 'left';
            } else if (ev.clientY <= targetRect.y + SENSITIVITY) {
                return 'top';
            } else if (ev.clientX >= targetRect.x + ev.target.clientWidth - SENSITIVITY) {
                return 'right';
            } else if (ev.clientY >= targetRect.y + ev.target.clientHeight - SENSITIVITY) {
                return 'bottom';
            }
        }
        return false;
    }
    /**
     * Change the cursor to a resizing cursor, in the direction specified. If no
     * direction is specified, return the cursor to its default.
     *
     * @private
     * @param {'col'|'row'|false} direction 'col'/'row' to hint column/row,
     *                                      false to remove the hints
     */
    _toggleTableResizeCursor(direction) {
        this.editable.classList.remove('o_col_resize', 'o_row_resize');
        if (direction === 'col') {
            this.editable.classList.add('o_col_resize');
        } else if (direction === 'row') {
            this.editable.classList.add('o_row_resize');
        }
    }
    /**
     * Resizes a table in the given direction, by "pulling" the border between
     * the given targets (ordered left to right or top to bottom).
     *
     * @private
     * @param {MouseEvent} ev
     */
    _resizeTable(ev, direction, target1, target2) {
        ev.preventDefault();
        let position = target1 ? (target2 ? 'middle' : 'last') : 'first';
        let [item, neighbor] = [target1 || target2, target2];
        const table = closestElement(item, 'table');
        const [sizeProp, positionProp, clientPositionProp] = direction === 'col' ? ['width', 'x', 'clientX'] : ['height', 'y', 'clientY'];

        const isRTL = this.options.direction === "rtl";
        // Preserve current width.
        if (sizeProp === 'width') {
            const tableRect = table.getBoundingClientRect();
            table.style[sizeProp] = tableRect[sizeProp] + 'px';
        }
        const unsizedItemsSelector = `${direction === 'col' ? 'td' : 'tr'}:not([style*=${sizeProp}])`;
        for (const unsizedItem of table.querySelectorAll(unsizedItemsSelector)) {
            unsizedItem.style[sizeProp] = unsizedItem.getBoundingClientRect()[sizeProp] + 'px';
        }

        // TD widths should only be applied in the first row. Change targets and
        // clean the rest.
        if (direction === 'col') {
            let hostCell = closestElement(table, 'td');
            const hostCells = [];
            while (hostCell) {
                hostCells.push(hostCell);
                hostCell = closestElement(hostCell.parentElement, 'td');
            }
            const nthColumn = getColumnIndex(item);
            const firstRow = [...table.querySelector('tr').children];
            [item, neighbor] = [firstRow[nthColumn], firstRow[nthColumn + 1]];
            for (const td of hostCells) {
                if (td !== item && td !== neighbor && closestElement(td, 'table') === table && getColumnIndex(td) !== 0) {
                    td.style.removeProperty(sizeProp);
                }
            }
            if (isRTL && position == "middle") {
                [item, neighbor] = [neighbor, item];
            }
        }

        const MIN_SIZE = 33; // TODO: ideally, find this value programmatically.
        switch (position) {
            case 'first': {
                const marginProp = direction === 'col' ? (isRTL ? 'marginRight' : 'marginLeft') : 'marginTop';
                const itemRect = item.getBoundingClientRect();
                const tableStyle = getComputedStyle(table);
                const currentMargin = pxToFloat(tableStyle[marginProp]);
                let sizeDelta = itemRect[positionProp] - ev[clientPositionProp];
                if (direction === 'col' && isRTL) {
                    sizeDelta = ev[clientPositionProp] - itemRect[positionProp] -itemRect[sizeProp] ;
                }
                const newMargin = currentMargin - sizeDelta;
                const currentSize = itemRect[sizeProp];
                const newSize = currentSize + sizeDelta;
                if (newMargin >= 0 && newSize > MIN_SIZE) {
                    const tableRect = table.getBoundingClientRect();
                    // Check if a nested table would overflow its parent cell.
                    const hostCell = closestElement(table.parentElement, 'td');
                    const childTable = item.querySelector('table');
                    const endProp = isRTL ? 'left' : 'right'
                    if (direction === 'col' &&
                        (hostCell && tableRect[endProp] + sizeDelta > hostCell.getBoundingClientRect()[endProp] - 5 ||
                        childTable && childTable.getBoundingClientRect()[endProp] > itemRect[endProp] + sizeDelta - 5)) {
                        break;
                    }
                    table.style[marginProp] = newMargin + 'px';
                    item.style[sizeProp] = newSize + 'px';
                    if (sizeProp === 'width') {
                        table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';
                    }
                }
                break;
            }
            case 'middle': {
                const [itemRect, neighborRect] = [item.getBoundingClientRect(), neighbor.getBoundingClientRect()];
                const [currentSize, newSize] = [itemRect[sizeProp], ev[clientPositionProp] - itemRect[positionProp]];
                const editableStyle = getComputedStyle(this.editable);
                const sizeDelta = newSize - currentSize;
                const currentNeighborSize = neighborRect[sizeProp];
                const newNeighborSize = currentNeighborSize - sizeDelta;
                const maxWidth = this.editable.clientWidth - pxToFloat(editableStyle.paddingLeft) - pxToFloat(editableStyle.paddingRight);
                const tableRect = table.getBoundingClientRect();
                if (newSize > MIN_SIZE &&
                        // prevent resizing horizontally beyond the bounds of
                        // the editable:
                        (direction === 'row' ||
                        newNeighborSize > MIN_SIZE ||
                        tableRect[sizeProp] + sizeDelta < maxWidth)) {

                    // Check if a nested table would overflow its parent cell.
                    const childTable = item.querySelector('table');
                    if (direction === 'col' &&
                        childTable && childTable.getBoundingClientRect().right > itemRect.right + sizeDelta - 5) {
                        break
                    }
                    item.style[sizeProp] = newSize + 'px';
                    if (direction === 'col') {
                        neighbor.style[sizeProp] = (newNeighborSize > MIN_SIZE ? newNeighborSize : currentNeighborSize) + 'px';
                    } else if (sizeProp === 'width') {
                        table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';
                    }
                }
                break;
            }
            case 'last': {
                const itemRect = item.getBoundingClientRect();
                let sizeDelta = ev[clientPositionProp] - (itemRect[positionProp] + itemRect[sizeProp]); // todo: rephrase
                if (direction === 'col' && isRTL) {
                    sizeDelta = itemRect[positionProp] - ev[clientPositionProp];
                }
                const currentSize = itemRect[sizeProp];
                const newSize = currentSize + sizeDelta;
                if ((newSize >= 0 || direction === 'row') && newSize > MIN_SIZE) {
                    const tableRect = table.getBoundingClientRect();
                    // Check if a nested table would overflow its parent cell.
                    const hostCell = closestElement(table.parentElement, 'td');
                    const childTable = item.querySelector('table');
                    const endProp = isRTL ? 'left' : 'right'
                    if (direction === 'col' &&
                        (hostCell && tableRect[endProp] + sizeDelta > hostCell.getBoundingClientRect()[endProp] - 5 ||
                        childTable && childTable.getBoundingClientRect()[endProp] > itemRect[endProp] + sizeDelta - 5)) {
                        break
                    }
                    if (sizeProp === 'width') {
                        table.style[sizeProp] = tableRect[sizeProp] + sizeDelta + 'px';
                    }
                    item.style[sizeProp] = newSize + 'px';
                }
                break;
            }
        }
    }
    /**
     * Show/hide and position the table row/column manipulation UI.
     *
     * @private
     * @param {HTMLTableRowElement} [row=false]
     * @param {HTMLTableCellElement} [column=false]
     */
    _toggleTableUi(row=false, column=false) {
        if (row) {
            this._rowUi.style.visibility = 'visible';
            this._rowUiTarget = row;
            this._positionTableUi(row);
        } else {
            this._rowUi.style.visibility = 'hidden';
        }
        if (column) {
            this._columnUi.style.visibility = 'visible';
            this._columnUiTarget = column;
            this._positionTableUi(column);
        } else {
            this._columnUi.style.visibility = 'hidden';
        }
        if (row || column) {
            this._tableUiTarget = closestElement(row || column, 'table');
            this._tableUiTarget && this._tableUiTarget.addEventListener('mouseleave', () => this._toggleTableUi(), { once: true });
        }
    }
    /**
     * Position the table row/column tools (depending on whether a row or a cell
     * is passed as argument).
     *
     * @private
     * @param {HTMLTableRowElement|HTMLTableCellElement} element
     */
    _positionTableUi(element) {
        if (!element.isConnected) {
            return;
        }
        const tableUiContainerRect = this._tableUiContainer.getBoundingClientRect();
        const isRtl = this.options.direction === 'rtl';
        const isRow = element.nodeName === 'TR';
        const ui = isRow ? this._rowUi : this._columnUi;
        const elementRect = element.getBoundingClientRect();
        const wrappedUi = ui.firstElementChild;
        const table = closestElement(element, 'table');
        const tableRect = table && table.getBoundingClientRect();
        const resetTableSize = ui.querySelector('.o_reset_table_size');
        if (table && !table.hasAttribute('style')) {
            resetTableSize.classList.add('d-none');
        } else {
            resetTableSize.classList.remove('d-none');
        }

        let left;
        let top;
        if (isRow) {
            if (isRtl) {
                left = tableRect.right - tableUiContainerRect.x;
            } else {
                left = elementRect.left - tableUiContainerRect.left - wrappedUi.clientWidth;
            }
        } else if (isRtl) {
            left = elementRect.left - tableUiContainerRect.left + wrappedUi.clientWidth;
        } else {
            left = elementRect.left - tableUiContainerRect.left - (isRow ? wrappedUi.clientWidth : 0);
        }
        top = elementRect.top - tableUiContainerRect.top - (isRow ? 0 : wrappedUi.clientHeight);

        ui.style.left = left + 'px';
        ui.style.top = top + 'px';
        wrappedUi.style[isRow ? 'height' : 'width'] = elementRect[isRow ? 'height' : 'width'] + 'px';

    }

    // HISTORY
    // =======

    /**
     * @private
     * @returns {Object}
     */
    _computeHistorySelection() {
        const sel = this.document.getSelection();
        if (!(sel && sel.anchorNode)) {
            return this._latestComputedSelection;
        }
        this._latestComputedSelection = {
            anchorNode: sel.anchorNode,
            anchorOffset: sel.anchorOffset,
            focusNode: sel.focusNode,
            focusOffset: sel.focusOffset,
        };
        if (this.isSelectionInEditable(sel)) {
            this._latestComputedSelectionInEditable = this._latestComputedSelection;
        }
        return this._latestComputedSelection;
    }
    /**
     * @private
     * @param {boolean} [useCache=false]
     */
    _recordHistorySelection(useCache = false) {
        this._currentStep.selection =
            serializeSelection(
                useCache ? this._latestComputedSelection : this._computeHistorySelection(),
            ) || {};
    }
    /**
     * Return true if the latest computed selection was inside an empty inline tag
     *
     * @private
     * @return {boolean}
     */
    _isLatestComputedSelectionInsideEmptyInlineTag() {
        if (!this._latestComputedSelection) {
            return false;
        }
        const anchorNode = this._latestComputedSelection.anchorNode;
        const focusNode = this._latestComputedSelection.focusNode;
        const parentTextContent = anchorNode.parentElement? anchorNode.parentElement.textContent : null;
        return anchorNode === focusNode && (['', ...ZERO_WIDTH_CHARS].includes(parentTextContent))
    }
    /**
     * Get the step index in the history to undo.
     * Return -1 if no undo index can be found.
     */
    _getNextUndoIndex() {
        // Go back to first step that can be undone ("redo" or undefined).
        for (let index = this._historySteps.length - 1; index >= 0; index--) {
            if (
                this._historySteps[index] &&
                this._historySteps[index].clientId === this._collabClientId
            ) {
                const state = this._historyStepsStates.get(this._historySteps[index].id);
                if (state === 'redo' || !state) {
                    return index;
                }
            }
        }
        // There is no steps left to be undone, return an index that does not
        // point to any step
        return -1;
    }
    /**
     * Get the step index in the history to redo.
     * Return -1 if no redo index can be found.
     */
    _getNextRedoIndex() {
        // We cannot redo more than what is consumed.
        // Check if we have no more "consumed" than "redo" until we get to an
        // "undo"
        let totalConsumed = 0;
        for (let index = this._historySteps.length - 1; index >= 0; index--) {
            if (
                this._historySteps[index] &&
                this._historySteps[index].clientId === this._collabClientId
            ) {
                const state = this._historyStepsStates.get(this._historySteps[index].id);
                switch (state) {
                    case 'undo':
                        return totalConsumed <= 0 ? index : -1;
                    case 'redo':
                        totalConsumed -= 1;
                        break;
                    case 'consumed':
                        totalConsumed += 1;
                        break;
                    default:
                        return -1;
                }
            }
        }
        return -1;
    }
    historyRevertUntil (toStepIndex) {
        const lastStep = this._currentStep;
        this.historyRevert(lastStep);
        let stepIndex = this._historySteps.length - 1;
        while (stepIndex > toStepIndex) {
            const step = this._historySteps[stepIndex];
            const stepState = this._historyStepsStates.get(step.id);
            if (step.clientId === this._collabClientId && stepState !== 'consumed') {
                this.historyRevert(this._historySteps[stepIndex]);
                this._historyStepsStates.set(''+step.id, 'consumed');
            }
            stepIndex--;
        }
    }

    // TOOLBAR
    // =======

    toolbarHide() {
        this._updateToolbar(false);
    }
    toolbarShow() {
        this._updateToolbar(true);
    }
    /**
     * @private
     * @param {boolean} [show]
     */
    _updateToolbar(show) {
        if (!this.toolbar) {
            return;
        }
        if (!this.autohideToolbar && this.toolbar.style.visibility !== 'visible') {
            this.toolbar.style.visibility = 'visible';
        }

        const sel = this.document.getSelection();
        if (!hasTableSelection(this.editable)) {
            if (this.editable.classList.contains('o_col_resize') || this.editable.classList.contains('o_row_resize')) {
                show = false;
            }
            if (!sel.anchorNode) {
                show = false;
            } else {
                const selAncestors = [sel.anchorNode, ...ancestors(sel.anchorNode, this.editable)];
                const isInStars = selAncestors.some(node => node.classList && node.classList.contains('o_stars'));
                if (isInStars) {
                    show = false;
                }
            }
        }
        if (this.autohideToolbar && !this.toolbar.contains(sel.anchorNode)) {
            if (!this.isMobile) {
                if (this.powerboxTablePicker.el.style.display === 'block') {
                    this.toolbar.style.visibility = 'hidden';
                    return;
                }
                if (show !== undefined) {
                    this.toolbar.style.visibility = show ? 'visible' : 'hidden';
                }
                if (show === false) {
                    for (const menu of this.toolbar.querySelectorAll('.dropdown-menu.show')) {
                        menu.parentElement?.querySelector('[data-bs-toggle="dropdown"]')?.click();
                    };
                    return;
                }
            }
        }
        if (!this.isSelectionInEditable(sel)) {
            return;
        }
        const paragraphDropdownButton = this.toolbar.querySelector('#paragraphDropdownButton');
        if (paragraphDropdownButton) {
            for (const commandState of [
                'justifyLeft',
                'justifyRight',
                'justifyCenter',
                'justifyFull',
            ]) {
                const button = this.toolbar.querySelector('#' + commandState);
                const direction = commandState === 'justifyFull'
                    ? 'justify' : commandState.replace('justify', '').toLowerCase();
                let isStateTrue = false;
                const link = sel.anchorNode && closestElement(sel.anchorNode, 'a');
                const linkBlock = link && closestBlock(link);
                if (linkBlock) {
                    // We don't support links with a width that is larger than
                    // their contents so an alignment within the link is not
                    // visible. Since the editor applies alignments to a node's
                    // closest block, we show the alignment of the link's
                    // closest block.
                    const alignment = getComputedStyle(linkBlock).textAlign;
                    isStateTrue = alignment === direction;
                } else {
                    isStateTrue = this.document.queryCommandState(commandState)
                }
                button.classList.toggle('active', isStateTrue);
                const newClass = `fa-align-${direction}`;
                paragraphDropdownButton.classList.toggle(newClass, isStateTrue);
            }
        }
        if (sel.rangeCount) {
            // queryCommandState does not take stylesheets into account
            for (const format of ['bold', 'italic', 'underline', 'strikeThrough', 'switchDirection']) {
                const formatButton = this.toolbar.querySelector(`#${format.toLowerCase()}`);
                if (formatButton) {
                    formatButton.classList.toggle('active', isSelectionFormat(this.editable, format));
                }
            }

            const fontSizeEl = this.toolbar.querySelector("#fontSizeCurrentValue");
            if (fontSizeEl) {
                fontSizeEl.value = Math.round(getFontSizeDisplayValue(sel,
                    this.options.getCSSVariableValue,
                    this.options.convertNumericToUnit
                ));
            }

            const table = getInSelection(this.document, 'table');
            const toolbarButton = this.toolbar.querySelector('.toolbar-edit-table');
            if (toolbarButton) {
                this.toolbar.querySelector('.toolbar-edit-table').style.display = table
                    ? 'block'
                    : 'none';
            }
        }
        this.updateColorpickerLabels();
        const listUIClasses = {UL: 'fa-list-ul', OL: 'fa-list-ol', CL: 'fa-tasks'};
        const block = closestBlock(sel.anchorNode);
        let activeLabel = undefined;
        for (const [style, cssSelector, isList] of [
            // TODO we might want to review this list to not mention o_xxx
            // classes but be a setting instead? Probably after current
            // refactorings being made in master.
            ['paragraph', 'p:not(.small, .lead, .o_small)', false],
            ['pre', 'pre', false],
            ['heading1', 'h1:not(.display-1, .display-2, .display-3, .display-4)', false],
            ['heading2', 'h2', false],
            ['heading3', 'h3', false],
            ['heading4', 'h4', false],
            ['heading5', 'h5', false],
            ['heading6', 'h6', false],
            ['display-1', 'h1.display-1', false],
            ['display-2', 'h1.display-2', false],
            ['display-3', 'h1.display-3', false],
            ['display-4', 'h1.display-4', false],
            ['blockquote', 'blockquote', false],
            // Note: this button will apply the "o_small" class but as an
            // approximation, we display "Small" if this actually use the
            // Bootstrap "small" class.
            ['small', '.small, .o_small', false],
            ['light', '.lead', false],
            ['unordered', 'UL', true],
            ['ordered', 'OL', true],
            ['checklist', 'CL', true],
        ]) {
            const button = this.toolbar.querySelector('#' + style);
            if (button && !block) {
                button.classList.toggle('active', false);
            } else if (button) {
                const isActive = isList
                    ? block.tagName === 'LI' && getListMode(block.parentElement) === cssSelector
                    : block.matches(cssSelector);
                button.classList.toggle('active', isActive);

                if (!isList && isActive) {
                    activeLabel = button.textContent;
                }
            }
        }
        if (block) {
            const listMode = getListMode(block.parentElement);
            const listDropdownButton = this.toolbar.querySelector('#listDropdownButton');
            if (listDropdownButton) {
                if (listMode) {
                    listDropdownButton.classList.remove('fa-list-ul', 'fa-list-ol', 'fa-tasks');
                    listDropdownButton.classList.add(listUIClasses[listMode]);
                }
                listDropdownButton.closest('button').classList.toggle('active', block.tagName === 'LI');
            }
        }

        const styleSection = this.toolbar.querySelector('#style');
        if (styleSection) {
            if (!activeLabel) {
                // If no element from the text style dropdown was marked as active,
                // mark the paragraph one as active and use its label.
                const firstButtonEl = styleSection.querySelector('#paragraph');
                firstButtonEl.classList.add('active');
                activeLabel = firstButtonEl.textContent;
            }
            styleSection.querySelector('button span').textContent = activeLabel;
        }

        const isInMedia = this.toolbar.classList.contains('oe-media');
        const linkNode = getInSelection(this.document, 'a');
        const linkButton = this.toolbar.querySelector('#create-link');
        linkButton && linkButton.classList.toggle('active', !!linkNode);
        // Hide unlink button if no link in selection, always hide on media
        // elements.
        const unlinkButton = this.toolbar.querySelector('#unlink');
        unlinkButton?.classList.toggle('d-none', isInMedia || !linkNode);
        const undoButton = this.toolbar.querySelector('#undo');
        undoButton && undoButton.classList.toggle('disabled', !this.historyCanUndo());
        const redoButton = this.toolbar.querySelector('#redo');
        redoButton && redoButton.classList.toggle('disabled', !this.historyCanRedo());

        // Hide create-link button if selection spans several blocks, always
        // hide on media elements.
        const range = getDeepRange(this.editable, { sel, correctTripleClick: true });
        const spansBlocks = [...range.commonAncestorContainer.childNodes].some(isBlock);
        linkButton?.classList.toggle('d-none', spansBlocks || isInMedia);

        // Hide link button group if it has no visible button.
        const linkBtnGroup = this.toolbar.querySelector('#link.btn-group');
        linkBtnGroup?.classList.toggle('d-none', !linkBtnGroup.querySelector('.btn:not(.d-none)'));
        if (this.autohideToolbar && !this.isMobile && !this.toolbar.contains(sel.anchorNode)) {
            this._positionToolbar();
        }
    }

    updateToolbarPosition() {
        if (
            this.autohideToolbar &&
            !this.isMobile &&
            getComputedStyle(this.toolbar).visibility === 'visible'
        ) {
            this._positionToolbar();
        }
    }

    _positionToolbar() {
        const OFFSET = 10;
        let isBottom = false;
        // Toolbar display must not be none in order to calculate width and height.
        this.toolbar.classList.toggle('d-none', false);
        this.toolbar.style.maxWidth = window.innerWidth - OFFSET * 2 + 'px';
        const sel = this.document.getSelection();
        const range = sel.getRangeAt(0);
        const isSelForward =
            sel.anchorNode === range.startContainer && sel.anchorOffset === range.startOffset;
        const startRect = range.startContainer.getBoundingClientRect && range.startContainer.getBoundingClientRect();
        const selRect = range.getBoundingClientRect();
        // In some undetermined circumstance in chrome, the selection rect is
        // wrongly defined and result with all the values for x, y, width, and
        // height to be 0. In that case, use the rect of the startContainer if
        // possible.
        const isSelectionPotentiallyBugged = [selRect.x, selRect.y, selRect.width, selRect.height].every( x => x === 0 );
        let correctedSelectionRect = isSelectionPotentiallyBugged && startRect ? startRect : selRect;
        const selAncestors = [sel.anchorNode, ...ancestors(sel.anchorNode, this.editable)];
        // If a table is selected, we want to position the toolbar in function
        // of the table, rather than follow the DOM selection.
        const selectedTable = selAncestors.find(node => node.classList && node.classList.contains('o_selected_table'));
        if (selectedTable) {
            correctedSelectionRect = selectedTable.getBoundingClientRect();
        }
        const toolbarWidth = this.toolbar.offsetWidth;
        const toolbarHeight = this.toolbar.offsetHeight;
        const editorRect = this.editable.getBoundingClientRect();
        const parentContextRect = this.options.getContextFromParentRect();
        const scrollContainerRect = this.options.getScrollContainerRect();
        const editorTopPos = Math.max(0, editorRect.top);
        const scrollX = document.defaultView.scrollX;
        const scrollY = document.defaultView.scrollY;

        // Get left position.
        let left = correctedSelectionRect.left + OFFSET;
        // Ensure the toolbar doesn't overflow the editor on the left.
        left = Math.max(OFFSET, left);
        // Ensure the toolbar doesn't overflow the editor on the right.
        left = Math.min(window.innerWidth - OFFSET - toolbarWidth, left);
        // Offset left to compensate for parent context position (eg. Iframe).
        const adjustedLeft = left + parentContextRect.left;
        this.toolbar.style.left = scrollX + adjustedLeft + 'px';

        // Get top position.
        let top = correctedSelectionRect.top - toolbarHeight - OFFSET;
        // Ensure the toolbar doesn't overflow the editor or scroll container on the top.
        if (top < editorTopPos || top + parentContextRect.top - scrollContainerRect.top < OFFSET / 2) {
            // Position the toolbar below the selection.
            top = correctedSelectionRect.bottom + OFFSET;
            isBottom = true;
        }
        // Offset top to compensate for parent context position (eg. Iframe).
        top += parentContextRect.top;
        this.toolbar.style.top = scrollY + top + 'px';

        // Position the arrow.
        let arrowLeftPos = (isSelForward && !isSelectionPotentiallyBugged ? correctedSelectionRect.right : correctedSelectionRect.left) - left - OFFSET;
        // Ensure the arrow doesn't overflow the toolbar on the left.
        arrowLeftPos = Math.max(OFFSET, arrowLeftPos);
        // Ensure the arrow doesn't overflow the toolbar on the right.
        arrowLeftPos = Math.min(toolbarWidth - OFFSET - 20, arrowLeftPos);
        this.toolbar.style.setProperty('--arrow-left-pos', arrowLeftPos + 'px');
        const arrowTopPos = isBottom ? -17 : toolbarHeight - 3;
        this.toolbar.classList.toggle('toolbar-bottom', isBottom);
        this.toolbar.style.setProperty('--arrow-top-pos', arrowTopPos + 'px');

        // Calculate toolbar dimensions including the arrow.
        const toolbarTop = Math.min(top , top + arrowTopPos);
        const toolbarBottom = Math.max(top + toolbarHeight, top + arrowTopPos + 20);

        // Hide toolbar if it overflows the scroll container.
        const distToScrollContainer = Math.min(toolbarTop - scrollContainerRect.top,
                                                scrollContainerRect.bottom - toolbarBottom);
        this.toolbar.classList.toggle('d-none', distToScrollContainer < OFFSET / 2);
    }

    // PASTING / DROPPING

    /**
     * Prepare clipboard data (text/html) for safe pasting into the editor.
     *
     * @private
     * @param {string} clipboardData
     * @returns {Element}
     */
    _prepareClipboardData(clipboardData) {
        const container = document.createElement('fake-container');
        container.append(parseHTML(this.document, clipboardData));

        for (const tableElement of container.querySelectorAll('table')) {
            tableElement.classList.add('table', 'table-bordered', 'o_table');
        }

        const progId = container.querySelector('meta[name="ProgId"]')
        if (progId && progId.content === 'Excel.Sheet') {
            // Microsoft Excel keeps table style in a <style> tag with custom
            // classes. The following lines parse that style and apply it to the
            // style attribute of <td> tags with matching classes.
            const xlStylesheet = container.querySelector('style');
            const xlNodes = container.querySelectorAll("[class*=xl],[class*=font]");
            for (const xlNode of xlNodes) {
                for (const xlClass of xlNode.classList) {
                    // Regex captures a CSS rule definition for that xlClass.
                    const xlStyle = xlStylesheet.textContent.match(`.${xlClass}[^\{]*\{(?<xlStyle>[^\}]*)\}`)
                        .groups.xlStyle.replace('background:', 'background-color:');
                    xlNode.setAttribute('style', xlNode.style.cssText + ';' + xlStyle)
                }
            }
        }

        for (const child of [...container.childNodes]) {
            this._cleanForPaste(child);
        }
        // Force inline nodes at the root of the container into separate P
        // elements. This is a tradeoff to ensure some features that rely on
        // nodes having a parent (e.g. convert to list, title, etc.) can work
        // properly on such nodes without having to actually handle that
        // particular case in all of those functions. In fact, this case cannot
        // happen on a new document created using this editor, but will happen
        // instantly when editing a document that was created from Etherpad.
        const fragment = document.createDocumentFragment();
        let p = document.createElement('p');
        for (const child of [...container.childNodes]) {
            if (isBlock(child)) {
                if (p.childNodes.length > 0) {
                    fragment.appendChild(p);
                    p = document.createElement('p');
                }
                fragment.appendChild(child);
            } else {
                p.appendChild(child);
            }

            if (p.childNodes.length > 0) {
                fragment.appendChild(p);
            }
        }

        // Split elements containing <br> into seperate elements for each line.
        const brs = fragment.querySelectorAll('br');
        for (const br of brs) {
            const block = closestBlock(br);
            if (
                ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(block.nodeName) &&
                !block.closest('li')
            ) {
                // A linebreak at the beginning of a block is an empty line.
                const isEmptyLine = block.firstChild.nodeName === 'BR';
                // Split blocks around it until only the BR remains in the
                // block.
                const remainingBrContainer = splitAroundUntil(br, block);
                // Remove the container unless it represented an empty line.
                if (!isEmptyLine) {
                    remainingBrContainer.remove();
                }
            }
        }
        return fragment;
    }
    /**
     * Clean a node for safely pasting. Cleaning an element involves unwrapping
     * its contents if it's an illegal (blacklisted or not whitelisted) element,
     * or removing its illegal attributes and classes.
     *
     * @param {Node} node
     */
    _cleanForPaste(node) {
        if (
            !this._isWhitelisted(node) ||
            this._isBlacklisted(node) ||
            // Google Docs have their html inside a B tag with custom id.
            node.id && node.id.startsWith('docs-internal-guid')
        ) {
            if (!node.matches || node.matches(CLIPBOARD_BLACKLISTS.remove.join(','))) {
                node.remove();
            } else {
                // Unwrap the illegal node's contents.
                for (const unwrappedNode of unwrapContents(node)) {
                    this._cleanForPaste(unwrappedNode);
                }
            }
        } else if (node.nodeType !== Node.TEXT_NODE) {
            if (node.nodeName === 'TD') {
                if (node.hasAttribute('bgcolor') && !node.style['background-color']) {
                    node.style['background-color'] = node.getAttribute('bgcolor');
                }
            } else if (node.nodeName === 'FONT') {
                // FONT tags have some style information in custom attributes,
                // this maps them to the style attribute.
                if (node.hasAttribute('color') && !node.style['color']) {
                    node.style['color'] = node.getAttribute('color');
                }
                if (node.hasAttribute('size') && !node.style['font-size']) {
                    // FONT size uses non-standard numeric values.
                    node.style['font-size'] = +node.getAttribute('size') + 10 + 'pt';
                }
            } else if (['S', 'U'].includes(node.nodeName) && node.childNodes.length === 1 && node.firstChild.nodeName === 'FONT') {
                // S and U tags sometimes contain FONT tags. We prefer the
                // strike to adopt the style of the text, so we invert them.
                const fontNode = node.firstChild;
                node.before(fontNode);
                node.replaceChildren(...fontNode.childNodes);
                fontNode.appendChild(node);
            } else if (node.nodeName === 'IMG' && node.getAttribute('aria-roledescription') === 'checkbox') {
                const checklist = node.closest('ul');
                const closestLi = node.closest('li');
                if (checklist) {
                    checklist.classList.add('o_checklist');
                    if (node.getAttribute('alt') === 'checked') {
                        closestLi.classList.add('o_checked');
                    }
                    node.remove();
                    node = checklist;
                }
            }
            // Remove all illegal attributes and classes from the node, then
            // clean its children.
            for (const attribute of [...node.attributes]) {
                // Keep allowed styles on nodes with allowed tags.
                if (CLIPBOARD_WHITELISTS.styledTags.includes(node.nodeName) && attribute.name === 'style') {
                    node.removeAttribute(attribute.name);
                    if (['SPAN', 'FONT'].includes(node.tagName)) {
                        for (const unwrappedNode of unwrapContents(node)) {
                            this._cleanForPaste(unwrappedNode);
                        }
                    }
                } else if (!this._isWhitelisted(attribute)) {
                    node.removeAttribute(attribute.name);
                }

            }
            for (const klass of [...node.classList]) {
                if (!this._isWhitelisted(klass)) {
                    node.classList.remove(klass);
                }
            }
            for (const child of [...node.childNodes]) {
                this._cleanForPaste(child);
            }
        }
    }
    /**
     * Return true if the given attribute, class or node is whitelisted for
     * pasting, false otherwise.
     *
     * @private
     * @param {Attr | string | Node} item
     * @returns {boolean}
     */
    _isWhitelisted(item) {
        if (item instanceof Attr) {
            return CLIPBOARD_WHITELISTS.attributes.includes(item.name);
        } else if (typeof item === 'string') {
            return CLIPBOARD_WHITELISTS.classes.some(okClass =>
                okClass instanceof RegExp ? okClass.test(item) : okClass === item,
            );
        } else {
            return (
                item.nodeType === Node.TEXT_NODE ||
                (
                    item.matches &&
                    item.matches(CLIPBOARD_WHITELISTS.nodes)
                )
            );
        }
    }
    /**
     * Return true if the given node is blacklisted for pasting, false
     * otherwise.
     *
     * @private
     * @param {Node} node
     * @returns {boolean}
     */
    _isBlacklisted(node) {
        return (
            node.nodeType !== Node.TEXT_NODE &&
            node.matches([].concat(...Object.values(CLIPBOARD_BLACKLISTS)).join(','))
        );
    }
    _safeSetAttribute(node, attributeName, attributeValue) {
        const clone = document.createElement(node.tagName);
        clone.setAttribute(attributeName, attributeValue);
        DOMPurify.sanitize(clone, { IN_PLACE: true });
        if (clone.hasAttribute(attributeName)) {
            node.setAttribute(attributeName, clone.getAttribute(attributeName));
        } else {
            node.removeAttribute(attributeName);
        }
    }

    disableAvatarForElement(element) {
        this.enableAvatars();
        for (const info of this._collabSelectionInfos.values()) {
            if (info.avatarTargetElement === element) {
                if (!info.avatarElement.classList.contains('opacity-0')) {
                    info.avatarElement.classList.add('opacity-0');
                }
            }
        }
    }
    enableAvatars() {
        for (const element of this._avatarsContainer.querySelectorAll('.oe-collaboration-caret-avatar.opacity-0')) {
            element.classList.remove('opacity-0');
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    _onBeforeInput(ev) {
        this._lastBeforeInputType = ev.inputType;
        // For chrome when we have this structure
        // <div contenteditable="true">
        //     <ul>
        //         <div contenteditable="false">
        //             <div contenteditable="true">
        //                 <p>
        //                     text[]
        //                 </p>
        //             </div>
        //         </div>
        //     </ul>
        // </div>
        // clicking on `enter` doesn't works as expected and the `input` event is never
        // triggered, to solve the problem we can use this hack where we stop the propagation
        // and trigger manually the input event to simulate the correct flow.
        if (ev.inputType ==="insertParagraph") {
            const banner = closestElement(ev.target, ".o_editor_banner");
            if (banner && closestElement(banner, "ul, ol")) {
                ev.preventDefault();
                this._onInput(ev);
                return;
            }
        }
    }

    /**
     * If backspace/delete input, rollback the operation and handle the
     * operation ourself. Needed for mobile, used for desktop for consistency.
     *
     * @private
     */
    _onInput(ev) {
        // See if the Powerbox should be opened. If so, it will open at the end.
        const newSelection = this.document.getSelection();
        if (newSelection.anchorNode && isProtected(newSelection.anchorNode)) {
            return;
        }
        const shouldOpenPowerbox = newSelection.isCollapsed && newSelection.rangeCount &&
            ev.data === '/' && this.powerbox && !this.powerbox.isOpen &&
            (!this.options.getPowerboxElement || !!this.options.getPowerboxElement());
        if (shouldOpenPowerbox) {
            // Undo input '/'.
            this._powerboxBeforeStepIndex = this._historySteps.length - 1;
        }
        // Record the selection position that was computed on keydown or before
        // contentEditable execCommand (whatever preceded the 'input' event)
        this._recordHistorySelection(true);
        const selection = this._currentStep.selection;
        const { anchorNodeOid, anchorOffset, focusNodeOid, focusOffset } = selection || {};
        const wasCollapsed =
            !selection || (focusNodeOid === anchorNodeOid && focusOffset === anchorOffset);
        // Sometimes google chrome wrongly triggers an input event with `data`
        // being `null` on `deleteContentForward` `insertParagraph`. Luckily,
        // chrome provide the proper signal with the event `beforeinput`.
        const isChromeDeleteforward =
            ev.inputType === 'insertText' &&
            ev.data === null &&
            this._lastBeforeInputType === 'deleteContentForward';
        const isChromeInsertParagraph =
            ev.inputType === 'insertText' &&
            ev.data === null &&
            this._lastBeforeInputType === 'insertParagraph';
        const isCompositionEvent =
            ev.inputType === "insertCompositionText" ||
            (ev.inputType === "insertText" &&
                (this.keyboardType === KEYBOARD_TYPES.VIRTUAL ||
                    this.isMobile));
        if (isCompositionEvent) {
            this._fromCompositionText = true;
        }
        if (this.keyboardType === KEYBOARD_TYPES.PHYSICAL || !wasCollapsed) {
            // Most deletion cases in complex HTML like Bootstrap etc can end
            // with a wrong result if done by the contenteditable itself.
            // Intervene as soon as the selection was not collapsed, except
            // while composing. In that case the composition should be left
            // alone unless the selection was spanning different blocks.
            const anchorNode = this.idFind(anchorNodeOid);
            const focusNode = this.idFind(focusNodeOid);
            const wasSelectingAcrossDifferentBlocks =
                anchorNode &&
                focusNode &&
                closestBlock(anchorNode) !== closestBlock(focusNode);
            const shouldInterveneForDeletion =
                !this._fromCompositionText ||
                wasSelectingAcrossDifferentBlocks;
            if (ev.inputType === 'deleteContentBackward' && shouldInterveneForDeletion) {
                this._compositionStep();
                this.historyRollback();
                ev.preventDefault();
                this._applyCommand('oDeleteBackward');
            } else if (
                (ev.inputType === 'deleteContentForward' || isChromeDeleteforward) &&
                shouldInterveneForDeletion
            ) {
                this._compositionStep();
                this.historyRollback();
                ev.preventDefault();
                this._applyCommand('oDeleteForward');
            } else if (
                (['insertParagraph', 'insertLineBreak'].includes(ev.inputType) || isChromeInsertParagraph)
            ) {
                this._compositionStep();
                this.historyRollback();
                ev.preventDefault();
                this._handleAutomaticLinkInsertion();
                getDeepRange(this.editable, { select: true, correctTripleClick: true });
                // To remove only the anchor cell's content when multiple table cells are selected on Enter,
                // we need to change the selection to focus only on the anchor cell. This can't be done in `oEnter`
                // because `deleteRange` responsible for removing content, execute before `oEnter` in `_applyRawCommand`.
                // Therefore, the anchor cell selection should be adjusted before `_applyRawCommand` is called.
                const anchorTD = closestElement(newSelection.anchorNode, '.o_selected_td');
                const focusTD = closestElement(newSelection.focusNode, '.o_selected_td');
                if (anchorTD && focusTD && closestElement(anchorTD, 'table') === closestElement(focusTD, 'table')) {
                    this.deselectTable();
                    setSelection(anchorTD.firstChild, 0, anchorTD.lastChild, nodeSize(anchorTD.lastChild));
                }
                if (ev.inputType === 'insertLineBreak' || this._applyCommand('oEnter') === UNBREAKABLE_ROLLBACK_CODE) {
                    this._applyCommand('oShiftEnter');
                }
            } else if (['insertText', 'insertCompositionText'].includes(ev.inputType)) {
                const selection = this.document.getSelection();
                // Unit tests events are not trusted by the browser,
                // the insertText has to be done manualy.
                const isUnitTests = !ev.isTrusted && this.testMode;
                // we cannot trust the browser to keep the selection inside empty tags.
                const latestSelectionInsideEmptyTag = this._isLatestComputedSelectionInsideEmptyInlineTag();
                const shouldInterveneForInsertion = !wasCollapsed && shouldInterveneForDeletion;
                if (
                    shouldInterveneForInsertion ||
                    latestSelectionInsideEmptyTag ||
                    isUnitTests
                ) {
                    ev.preventDefault();
                    if (!isUnitTests) {
                        // First we need to undo the character inserted by the browser.
                        // Since the unit test Event is not trusted by the browser, we don't
                        // need to undo the char during the unit tests.
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted
                        this._protect(() => this._applyRawCommand('oDeleteBackward'));
                    }
                    if (latestSelectionInsideEmptyTag) {
                        // Restore the selection inside the empty Element.
                        const selectionBackup = this._latestComputedSelection;
                        setSelection(selectionBackup.anchorNode, selectionBackup.anchorOffset);
                    }
                    // When the spellcheck of Safari modify text, ev.data is
                    // null and the string can be found within ev.dataTranser.
                    insertText(selection, ev.data === null ? ev.dataTransfer.getData('text/plain') : ev.data);
                    selection.collapseToEnd();
                }
                if (ev.data === '`' && !closestElement(selection.anchorNode, 'code')) {
                    // We just inserted a backtick, check if there was another
                    // one in the text.
                    const range = getDeepRange(this.editable);
                    let textNode = range.startContainer;
                    let offset = range.startOffset;
                    let sibling = textNode.previousSibling;
                    while (sibling && sibling.nodeType === Node.TEXT_NODE) {
                        offset += sibling.textContent.length;
                        sibling.textContent += textNode.textContent;
                        textNode.remove();
                        textNode = sibling;
                        sibling = textNode.previousSibling;
                    }
                    sibling = textNode.nextSibling;
                    while (sibling && sibling.nodeType === Node.TEXT_NODE) {
                        textNode.textContent += sibling.textContent;
                        sibling.remove();
                        sibling = textNode.nextSibling;
                    }
                    setSelection(textNode, offset);
                    const textHasTwoTicks = /`.*`/.test(textNode.textContent);
                    if (textHasTwoTicks) {
                        this.historyStep();
                        const insertedBacktickIndex = offset - 1;
                        const textBeforeInsertedBacktick = textNode.textContent.substring(0, insertedBacktickIndex - 1);
                        let startOffset, endOffset;
                        const isClosingForward = textBeforeInsertedBacktick.includes('`');
                        if (isClosingForward) {
                            // There is a backtick before the new backtick.
                            startOffset = textBeforeInsertedBacktick.lastIndexOf('`');
                            endOffset = insertedBacktickIndex;
                        } else {
                            // There is a backtick after the new backtick.
                            const textAfterInsertedBacktick = textNode.textContent.substring(offset);
                            startOffset = insertedBacktickIndex;
                            endOffset = offset + textAfterInsertedBacktick.indexOf('`');
                        }
                        // Split around the backticks if needed so text starts
                        // and ends with a backtick.
                        if (endOffset && endOffset < textNode.textContent.length) {
                            splitTextNode(textNode, endOffset + 1, DIRECTIONS.LEFT);
                        }
                        if (startOffset) {
                            splitTextNode(textNode, startOffset);
                        }
                        // Remove ticks.
                        textNode.textContent = textNode.textContent.substring(1, textNode.textContent.length - 1);
                        // Insert code element.
                        const codeElement = this.document.createElement('code');
                        codeElement.classList.add('o_inline_code');
                        textNode.before(codeElement);
                        codeElement.append(textNode);
                        if (!codeElement.previousSibling || codeElement.previousSibling.nodeType !== Node.TEXT_NODE) {
                            codeElement.before(document.createTextNode('\u200B'));
                        }
                        if (isClosingForward) {
                            // Move selection out of code element.
                            codeElement.after(document.createTextNode('\u200B'));
                            setSelection(codeElement.nextSibling, 1);
                        } else {
                            setSelection(codeElement.firstChild, 0);
                        }
                    }
                }
                this.historyStep();
            } else {
                this.historyStep();
            }
        }
        if (!isCompositionEvent) {
            this._fromCompositionText = false;
        }
        if (shouldOpenPowerbox) {
            this._isPowerboxOpenOnInput = true;
            this.powerbox.open();
        }
    }

    _onClipboardCut(clipboardEvent) {
        this._onClipboardCopy(clipboardEvent);
        this._recordHistorySelection();
        this.deleteRange();
        this.historyStep();
    }
    _onClipboardCopy(clipboardEvent) {
        if (!this.isSelectionInEditable()) {
            return;
        }
        clipboardEvent.preventDefault();
        const selection = this.document.getSelection();
        const range = selection.getRangeAt(0);
        let rangeContent = range.cloneContents();
        if (!rangeContent.hasChildNodes()) {
            return;
        }
        // Repair the copied range.
        if (rangeContent.firstChild.nodeName === 'LI') {
            const list = range.commonAncestorContainer.cloneNode();
            list.replaceChildren(...rangeContent.childNodes);
            rangeContent = list;
        }
        if (rangeContent.firstChild.nodeName === 'TR' || rangeContent.firstChild.nodeName === 'TD') {
            // We enter this case only if selection is within single table.
            const table = closestElement(range.commonAncestorContainer, 'table');
            const tableClone = table.cloneNode(true);
            // A table is considered fully selected if it is nested inside a
            // cell that is itself selected, or if all its own cells are
            // selected.
            const isTableFullySelected =
                table.parentElement && !!closestElement(table.parentElement, 'td.o_selected_td') ||
                [...table.querySelectorAll('td')]
                    .filter(td => closestElement(td, 'table') === table)
                    .every(td => td.classList.contains('o_selected_td'));
            if (!isTableFullySelected) {
                for (const td of tableClone.querySelectorAll('td:not(.o_selected_td)')) {
                    if (closestElement(td, 'table') === tableClone) { // ignore nested
                        td.remove();
                    }
                }
                const trsWithoutTd = Array.from(tableClone.querySelectorAll('tr')).filter(row => !row.querySelector('td'));
                for (const tr of trsWithoutTd) {
                    if (closestElement(tr, 'table') === tableClone) { // ignore nested
                        tr.remove();
                    }
                }
            }
            // If it is fully selected, clone the whole table rather than
            // just its rows.
            rangeContent = tableClone;
        }
        const table = closestElement(range.startContainer, 'table');
        if (rangeContent.firstChild.nodeName === 'TABLE' && table) {
            // Make sure the full leading table is copied.
            rangeContent.firstChild.after(table.cloneNode(true));
            rangeContent.firstChild.remove();
        }
        if (rangeContent.lastChild.nodeName === 'TABLE') {
            // Make sure the full trailing table is copied.
            rangeContent.lastChild.before(closestElement(range.endContainer, 'table').cloneNode(true));
            rangeContent.lastChild.remove();
        }

        const commonAncestorElement = closestElement(range.commonAncestorContainer);
        if (commonAncestorElement && !isBlock(rangeContent.firstChild)) {
            // Get the list of ancestor elements starting from the provided
            // commonAncestorElement up to the block-level element.
            const blockEl = closestBlock(commonAncestorElement);
            const ancestorsList = [commonAncestorElement, ...ancestors(commonAncestorElement, blockEl)];
            // Wrap rangeContent with clones of their ancestors to keep the styles.
            for (const ancestor of ancestorsList) {
                // Keep the formatting by keeping inline ancestors and paragraph
                // related ones like headings etc.
                if (!isBlock(ancestor) || paragraphRelatedElements.includes(ancestor.nodeName)) {
                    const clone = ancestor.cloneNode();
                    clone.append(...rangeContent.childNodes);
                    rangeContent.appendChild(clone);
                }
            }
        }
        const dataHtmlElement = document.createElement('data');
        dataHtmlElement.append(rangeContent);
        const odooHtml = dataHtmlElement.innerHTML;
        const odooText = selection.toString();
        clipboardEvent.clipboardData.setData('text/plain', odooText);
        clipboardEvent.clipboardData.setData('text/html', odooHtml);
        clipboardEvent.clipboardData.setData('text/odoo-editor', odooHtml);
    }
    /**
     * @private
     */
    _onKeyDown(ev) {
        const selection = this.document.getSelection();
        if (selection.anchorNode && isProtected(selection.anchorNode)) {
            return;
        }
        this.keyboardType =
            ev.key === 'Unidentified' ? KEYBOARD_TYPES.VIRTUAL : KEYBOARD_TYPES.PHYSICAL;
        this._currentKeyPress = ev.key;
        // If the pressed key has a printed representation, the returned value
        // is a non-empty Unicode character string containing the printable
        // representation of the key. In this case, call `deleteRange` before
        // inserting the printed representation of the character.
        if (/^.$/u.test(ev.key) && !ev.ctrlKey && !ev.metaKey && (isMacOS() || !ev.altKey)) {
            const selection = this.document.getSelection();
            if (selection && !selection.isCollapsed && this.isSelectionInEditable(selection)) {
                this.deleteRange(selection);
            }
        }
        if (ev.key === 'Backspace') {
            // backspace
            const selection = this.document.getSelection();
            if (!ev.ctrlKey && !ev.metaKey) {
                if (selection.isCollapsed && !this._fromCompositionText) {
                    // We need to hijack it because firefox doesn't trigger a
                    // deleteBackward input event with a collapsed selection in
                    // front of a contentEditable="false" (eg: font awesome).
                    ev.preventDefault();
                    this._applyCommand('oDeleteBackward');
                }
            } else if (selection.isCollapsed && selection.anchorNode) {
                const anchor = (selection.anchorNode.nodeType !== Node.TEXT_NODE && selection.anchorOffset) ?
                    selection.anchorNode[selection.anchorOffset] : selection.anchorNode;
                const element = closestBlock(anchor);
                if (isEmptyBlock(element) && element.parentElement.children.length === 1) {
                    // Prevent removing a <p> if it is the last element of its
                    // parent.
                    ev.preventDefault();
                    if (element.tagName !== 'P') {
                        // Replace an empty block which is not a <p> by a <p>
                        const paragraph = this.document.createElement('P');
                        const br = this.document.createElement('BR');
                        paragraph.append(br);
                        element.before(paragraph);
                        const result = this._protect(() => element.remove());
                        if (result !== UNBREAKABLE_ROLLBACK_CODE && result !== UNREMOVABLE_ROLLBACK_CODE) {
                            setCursorStart(paragraph);
                            this.historyStep();
                        }
                    }
                }
            }
        } else if (ev.key === 'Tab') {
            // Tab
            const tabHtml = '<span class="oe-tabs" contenteditable="false">\u0009</span>\u200B';
            const sel = this.document.getSelection();
            const closestTableOrLi = closestElement(sel.anchorNode, 'table, li');
            if (closestTableOrLi && closestTableOrLi.nodeName === 'TABLE') {
                this._onTabulationInTable(ev);
            } else if (!ev.shiftKey && sel.isCollapsed && !closestTableOrLi) {
                // Indent text (collapsed selection).
                this.execCommand('insert', parseHTML(this.document, tabHtml));
            } else {
                // Indent/outdent selection.
                // Split traversed nodes into list items and the rest.
                const listItems = new Set();
                const nonListItems = new Set();
                for (const node of getTraversedNodes(this.editable)) {
                    const closestLi = closestElement(node, 'li');
                    const target = closestLi || node;
                    if (!(target.querySelector && target.querySelector('li'))) {
                        if (closestLi) {
                            listItems.add(closestLi);
                        } else {
                            nonListItems.add(node);
                        }
                    }
                }

                const restore = preserveCursor(this.document);

                // Indent/outdent list items.
                for (const listItem of listItems) {
                    if (ev.shiftKey) {
                        listItem.oShiftTab(0);
                    } else {
                        listItem.oTab(0);
                    }
                }

                // Indent/outdent the rest.
                if (ev.shiftKey) {
                    const editorTabs = new Set(
                        [...nonListItems].map(node => {
                            const block = closestBlock(node);
                            return descendants(block).find(child => isEditorTab(child));
                        }).filter(node => (
                            // Filter out tabs preceded by visible text.
                            node && !getAdjacentPreviousSiblings(node).some(sibling => (
                                sibling.nodeType === Node.TEXT_NODE && !/^[\u200B\s]*$/.test(sibling.textContent)
                            ))
                    )));
                    for (const tab of editorTabs) {
                        let { anchorNode, anchorOffset, focusNode, focusOffset } = sel;
                        const updateAnchor = anchorNode === tab.nextSibling;
                        const updateFocus = focusNode === tab.nextSibling;
                        let zwsRemoved = 0;
                        while (tab.nextSibling && tab.nextSibling.nodeType === Node.TEXT_NODE && tab.nextSibling.textContent.startsWith('\u200B')) {
                            splitTextNode(tab.nextSibling, 1, DIRECTIONS.LEFT);
                            tab.nextSibling.remove();
                            zwsRemoved++;
                        }
                        if (updateAnchor || updateFocus) {
                            setSelection(
                                updateAnchor ? tab.nextSibling : anchorNode,
                                updateAnchor ? Math.max(0, anchorOffset - zwsRemoved) : anchorOffset,
                                updateFocus ? tab.nextSibling : focusNode,
                                updateFocus ? Math.max(0, focusOffset - zwsRemoved) : focusOffset
                            );
                        }
                        tab.remove();
                    };
                } else {
                    const tab = parseHTML(this.document, tabHtml);
                    for (const block of new Set([...nonListItems].map(node => closestBlock(node)).filter(node => node))) {
                        block.prepend(tab.cloneNode(true));
                    }
                    restore();
                }
                this.historyStep();
            }
            ev.preventDefault();
            ev.stopPropagation();
        } else if (ev.key === ' ') {
            this._handleAutomaticLinkInsertion();
        } else if (IS_KEYBOARD_EVENT_UNDO(ev)) {
            // Ctrl-Z
            ev.preventDefault();
            ev.stopPropagation();
            this.historyUndo();
        } else if (IS_KEYBOARD_EVENT_REDO(ev)) {
            // Ctrl-Y
            ev.preventDefault();
            ev.stopPropagation();
            this.historyRedo();
        } else if (IS_KEYBOARD_EVENT_BOLD(ev)) {
            // Ctrl-B
            ev.preventDefault();
            ev.stopPropagation();
            this.execCommand('bold');
        } else if (IS_KEYBOARD_EVENT_ITALIC(ev)) {
            // Ctrl-I
            ev.preventDefault();
            ev.stopPropagation();
            this.execCommand('italic');
        } else if (IS_KEYBOARD_EVENT_UNDERLINE(ev)) {
            // Ctrl-U
            ev.preventDefault();
            ev.stopPropagation();
            this.execCommand('underline');
        } else if (IS_KEYBOARD_EVENT_STRIKETHROUGH(ev)) {
            // Ctrl-5 / Ctrl-shift-(
            ev.preventDefault();
            ev.stopPropagation();
            this.execCommand('strikeThrough');
        } else if (IS_KEYBOARD_EVENT_LEFT_ARROW(ev) || IS_KEYBOARD_EVENT_RIGHT_ARROW(ev)) {
            const side = ev.key === 'ArrowLeft' ? 'previous' : 'next';
            const { anchorNode, anchorOffset } = this.document.getSelection() || {};
            // If the selection is at the edge of a code element at the edge of
            // its parent, make sure there's a zws next to it, where the
            // selection can then be set.
            const codeElement = anchorNode && closestElement(anchorNode, 'code');
            const siblingProperty = `${side}Sibling`;
            if (
                codeElement?.classList.contains('o_inline_code') &&
                (
                    (side === 'previous' && !anchorOffset) ||
                    (side === 'next' && anchorOffset === nodeSize(anchorNode))
                ) &&
                codeElement[siblingProperty]?.nodeType !== Node.TEXT_NODE &&
                !isZWS(codeElement[siblingProperty])
            ) {
                codeElement[side === 'previous' ? 'before' : 'after'](document.createTextNode('\u200B'));
                setSelection(codeElement[siblingProperty], side === 'previous' ? 0 : 1);
            } else {
                // Move selection if adjacent character is zero-width space.
                let didSkipFeff = false;
                let adjacentCharacter = getAdjacentCharacter(this.editable, side);
                let previousSelection; // Is used to stop if `modify` doesn't move the selection.
                const hasSelectionChanged = (oldSelection = {}) => {
                    const newSelection = this.document.getSelection();
                    return (
                        oldSelection.anchorNode !== newSelection.anchorNode ||
                        oldSelection.anchorOffset !== newSelection.anchorOffset ||
                        oldSelection.focusNode !== newSelection.focusNode ||
                        oldSelection.focusOffset !== newSelection.focusOffset
                    );
                };
                while (ZERO_WIDTH_CHARS.includes(adjacentCharacter) && hasSelectionChanged(previousSelection)) {
                    const selection = this.document.getSelection();
                    previousSelection = {...selection};
                    selection.modify(
                        ev.shiftKey ? 'extend' : 'move',
                        side === 'previous' ? 'backward' : 'forward',
                        'character',
                    );
                    didSkipFeff = didSkipFeff || adjacentCharacter === '\ufeff';
                    adjacentCharacter = getAdjacentCharacter(this.editable, side);
                }
                if (didSkipFeff && !ev.shiftKey) {
                    // If moving, just skip the zws then stop. Otherwise, do as if
                    // they weren't there.
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        }
    }
    /**
     * @private
     */
    _onSelectionChange() {
        const currentKeyPress = this._currentKeyPress;
        delete this._currentKeyPress;
        const selection = this.document.getSelection();
        if (!selection) {
            // Because the `selectionchange` event is async, the selection can
            // be null if the node has been removed between the moment the
            // selection was moved and the moment the event is triggered.
            return;
        }
        const anchorNode = selection.anchorNode;
        // Correct cursor if at editable root.
        if (
            selection.isCollapsed &&
            anchorNode === this.editable &&
            !this.options.allowInlineAtRoot
        ) {
            this._fixSelectionOnEditableRoot(selection, currentKeyPress);
            // The _onSelectionChange handler is going to be triggered again.
            return;
        }
        let appliedCustomSelection = false;
        if (selection.rangeCount && selection.getRangeAt(0)) {
            appliedCustomSelection = this._handleSelectionInTable();
            if (!appliedCustomSelection) {
                this.deselectTable();
            }
        }
        const isSelectionInEditable = this.isSelectionInEditable(selection);
        if (!appliedCustomSelection) {
            this._updateToolbar(!selection.isCollapsed && isSelectionInEditable);
        }
        if (!isSelectionInEditable) {
            return;
        }
        // When CTRL+A in the editor, sometimes the browser use the editable
        // element as an anchor & focus node. This is an issue for the commands
        // and the toolbar so we need to fix the selection to be based on the
        // editable children. Calling `getDeepRange` ensure the selection is
        // limited to the editable.
        if (
            selection.anchorNode === this.editable &&
            selection.focusNode === this.editable &&
            selection.anchorOffset === 0 &&
            selection.focusOffset === [...this.editable.childNodes].length
        ) {
            getDeepRange(this.editable, {select: true});
            // The selection is changed in `getDeepRange` and will therefore
            // re-trigger the _onSelectionChange.
            return;
        }
        this._resetLinkInSelection();
        // Compute the current selection on selectionchange but do not record it. Leave
        // that to the command execution or the 'input' event handler.
        this._computeHistorySelection();

        if (this._currentMouseState === 'mouseup') {
            this._fixFontAwesomeSelection();
        }
        if (
            selection.rangeCount &&
            selection.getRangeAt(0) &&
            this.options.onCollaborativeSelectionChange
        ) {
            this.options.onCollaborativeSelectionChange(this.getCurrentCollaborativeSelection());
        }
    }

    /**
     * Apply the o_link_in_selection class if the selection is in a single link,
     * remove it otherwise.
     */
    _resetLinkInSelection() {
        const selection = this.document.getSelection();
        if (!selection) {
            return;
        }
        const [anchorLink, focusLink] = [selection.anchorNode, selection.focusNode]
            .map(node => closestElement(node, 'a:not(.btn)'));
        const singleLinkInSelection = anchorLink === focusLink && anchorLink && isLinkEligibleForZwnbsp(this.editable, anchorLink) && anchorLink;
        if (singleLinkInSelection) {
            singleLinkInSelection.classList.add('o_link_in_selection');
        }
        for (const link of this.editable.querySelectorAll('.o_link_in_selection')) {
            if (link !== singleLinkInSelection) {
                link.classList.remove('o_link_in_selection');
            }
        };
    }
    /**
     * Returns true if the current selection is inside the editable.
     *
     * @param {Object} [selection]
     * @returns {boolean}
     */
    isSelectionInEditable(selection) {
        selection = selection || this.document.getSelection();
        if (selection && selection.anchorNode && selection.focusNode) {
            const anchorElement = closestElement(selection.anchorNode);
            const focusElement = closestElement(selection.focusNode);
            return anchorElement && anchorElement.isContentEditable && focusElement && focusElement.isContentEditable &&
                this.editable.contains(selection.anchorNode) && this.editable.contains(selection.focusNode);
        } else {
            return false;
        }
    }
    /**
     * Returns true if the current selection is in at least one block Element
     * relative to the current contentEditable root.
     *
     * @returns {boolean}
     */
    isSelectionInBlockRoot() {
        const selection = this.document.getSelection();
        let selectionInBlockRoot;
        let currentNode = closestElement(selection.anchorNode);
        while (
            !currentNode.classList.contains('o_editable') &&
            !currentNode.classList.contains('odoo-editor-editable') &&
            !selectionInBlockRoot
            ) {
            selectionInBlockRoot = isBlock(currentNode);
            currentNode = currentNode.parentElement;
        }
        return !!selectionInBlockRoot;
    }

    /**
     * @private
     */
    _compositionStep() {
        if (this._fromCompositionText) {
            this._fromCompositionText = false;
            this.sanitize();
            this.historyStep();
        }
    }

    getCurrentCollaborativeSelection() {
        const selection = this._latestComputedSelection || this._computeHistorySelection();
        return {
            selection: selection ? serializeSelection(selection) : {
                anchorNodeOid: undefined,
                anchorOffset: undefined,
                focusNodeOid: undefined,
                focusOffset: undefined,
            },
            color: this._collabSelectionColor,
            clientId: this._collabClientId,
            clientAvatarUrl: this._collabClientAvatarUrl,
        };
    }

    clean() {
        this.observerUnactive();
        this.cleanForSave();
        this.observerActive();
    }

    /**
     * Initialize the provided element to be ready for edition.
     */
    initElementForEdition(element = this.editable) {
        // Detect if the editable base element contain orphan inline nodes. If
        // so we transform the base element HTML to put those orphans inside
        // `<p>` containers.
        const orphanInlineChildNodes = [...element.childNodes].find(
            (n) => !isBlock(n) && (n.nodeType === Node.ELEMENT_NODE || n.textContent.trim() !== "")
        );
        if (orphanInlineChildNodes && !this.options.allowInlineAtRoot) {
            const childNodes = [...element.childNodes];
            const tempEl = document.createElement('temp-container');
            let currentP = document.createElement('p');
            currentP.style.marginBottom = '0';
            do {
                const node = childNodes.shift();
                const nodeIsBlock = isBlock(node);
                const nodeIsBR = node.nodeName === 'BR';
                // Append to the P unless child is block or an unneeded BR.
                if (!(nodeIsBlock || (nodeIsBR && currentP.childNodes.length))) {
                    currentP.append(node);
                }
                // Break paragraphs on blocks and BR.
                if (nodeIsBlock || nodeIsBR || childNodes.length === 0) {
                    // Ensure we don't add an empty P or a P containing only
                    // formating spaces that should not be visible.
                    if (currentP.childNodes.length && currentP.innerHTML.trim() !== '') {
                        tempEl.append(currentP);
                    }
                    currentP = currentP.cloneNode();
                    // Append block children directly to the template.
                    if (nodeIsBlock) {
                        tempEl.append(node);
                    }
                }
            } while (childNodes.length)
            element.replaceChildren(...tempEl.childNodes);
        }

        // Flag elements with forced contenteditable=false.
        // We need the flag to be able to leave the contentEditable
        // at the end of the edition (see cleanForSave())
        for (const el of element.querySelectorAll('[contenteditable="false"]')) {
            el.setAttribute('data-oe-keep-contenteditable', '');
        }
        // Flag elements .oe-tabs contenteditable=false.
        for (const el of element.querySelectorAll('.oe-tabs')) {
            el.setAttribute('contenteditable', 'false');
        }
    }

    cleanForSave(element = this.editable) {
        for (const hint of element.querySelectorAll('.oe-hint')) {
            hint.classList.remove('oe-hint', 'oe-command-temporary-hint');
            if (hint.classList.length === 0) {
                hint.removeAttribute('class');
            }
            hint.removeAttribute('placeholder');
        }
        this._pluginCall('cleanForSave', [element]);

        // Clean the zero-width spaces added by the `fillEmpty` function
        // (flagged with the "data-oe-zws-empty-inline" attributes). Reverse the
        // list to start from the deepest elements (for emptiness checks).
        const allWhitespaceRegex = /^[\s\u200b]*$/;
        for (const emptyElement of [...element.querySelectorAll('[data-oe-zws-empty-inline]')].reverse()) {
            emptyElement.removeAttribute('data-oe-zws-empty-inline');
            if (!allWhitespaceRegex.test(emptyElement.textContent)) {
                // The element has some meaningful text. Remove the ZWS in it.
                cleanZWS(emptyElement);
            } else if (!emptyElement.classList.length) {
                // We only remove the empty element if it has no class, to
                // ensure we don't break visual styles (in that case, its
                // ZWS was kept to ensure the cursor can be placed in it).
                emptyElement.remove();
            }
        }

        // Clean all transient nodes
        const protectedNodes = element.querySelectorAll('[data-oe-transient-content="true"], [data-oe-transient-content=""]');
        for (const node of protectedNodes) {
            node.replaceChildren();
        }

        sanitize(element);

        // Remove o_link_in_selection class
        for (const link of element.querySelectorAll('.o_link_in_selection')) {
            link.classList.remove('o_link_in_selection');
        }

        // Remove all FEFF within a `prepareUpdate` to make sure to make <br>
        // nodes visible if needed.
        for (const node of descendants(element)) {
            if (node.nodeType === Node.TEXT_NODE && node.textContent.includes('\uFEFF')) {
                const restore = prepareUpdate(...leftPos(node));
                node.textContent = node.textContent.replaceAll('\uFEFF', '');
                restore(); // Make sure to make <br>s visible if needed.
            }
        }

        const tAttrs = ['t-elif', 't-else', 't-esc', 't-foreach', 't-if', 't-out', 't-raw', 't-value'];
        // Remove now empty links
        for (const link of element.querySelectorAll('a')) {
            if (![...link.childNodes].some(isVisible) && !link.classList.length
                && !tAttrs.some(attr => link.hasAttribute(attr))) {
                link.remove();
            }
        }

        // Remove contenteditable=false on elements
        for (const el of element.querySelectorAll('[contenteditable="false"]')) {
            if (!el.hasAttribute('data-oe-keep-contenteditable')) {
                el.removeAttribute('contenteditable');
            }
        }
        // Remove data-oe-keep-contenteditable on elements
        for (const el of element.querySelectorAll('[data-oe-keep-contenteditable]')) {
            el.removeAttribute('data-oe-keep-contenteditable');
        }

        // Remove Zero Width Spaces on Font awesome elements
        for (const el of element.querySelectorAll(ICON_SELECTOR)) {
            cleanZWS(el);
        }

        // Clean custom selections
        if (this.deselectTable() && hasValidSelection(this.editable)) {
            this.document.getSelection().collapseToStart();
        }

        // Remove empty class attributes
        for (const el of element.querySelectorAll('*[class=""]')) {
            el.removeAttribute('class');
        }
    }
    /**
     * Handle the hint preview for the Powerbox.
     * @private
     */
    _handleCommandHint() {
        const selection = this.document.getSelection();
        const anchorNode = selection.anchorNode;
        if (isProtected(anchorNode)) {
            return;
        }

        const selectors = {
            BLOCKQUOTE: this.options._t('Empty quote'),
            H1: this.options._t('Heading 1'),
            H2: this.options._t('Heading 2'),
            H3: this.options._t('Heading 3'),
            H4: this.options._t('Heading 4'),
            H5: this.options._t('Heading 5'),
            H6: this.options._t('Heading 6'),
            'UL LI': this.options._t('List'),
            'OL LI': this.options._t('List'),
            'CL LI': this.options._t('To-do'),
        };

        for (const hint of this.editable.querySelectorAll('.oe-hint')) {
            if (
                hint.classList.contains('oe-command-temporary-hint') ||
                !isEmptyBlock(hint) ||
                hint.querySelector('T[t-out]')
            ) {
                this.observerUnactive();
                hint.classList.remove('oe-hint', 'oe-command-temporary-hint');
                if (hint.dataset.oeEditPlaceholder) {
                    hint.setAttribute("placeholder", hint.dataset.oeEditPlaceholder);
                    if (hint.innerText.trim().length === 0) {
                        hint.classList.add("oe-hint");
                    }
                } else {
                    hint.removeAttribute("placeholder");
                }
                if (hint.classList.length === 0) {
                    hint.removeAttribute('class');
                }
                this.observerActive();
            }
        }

        if (this.options.showEmptyElementHint) {
            for (const [selector, text] of Object.entries(selectors)) {
                for (const el of this.editable.querySelectorAll(selector)) {
                    if (!this.options.isHintBlacklisted(el)) {
                        this._makeHint(el, text);
                    }
                }
            }
        }

        const block = this.options.getPowerboxElement();
        if (block) {
            this._makeHint(block, this.options._t('Type "/" for commands'), true);
        }

        // placeholder hint
        const sel = this.document.getSelection();
        if (this.editable.textContent.trim() === '' && this.options.placeholder && this.editable.firstChild && this.editable.firstChild.innerHTML && !this.editable.contains(sel.focusNode)) {
            this._makeHint(this.editable.firstChild, this.options.placeholder, true);
        }
    }
    _makeHint(block, text, temporary = false) {
        const content = block && block.innerHTML.trim();
        if (
            block &&
            (content === '' || content === '<br>') &&
            !block.querySelector('T[t-out],[t-field]') &&
            ancestors(block, this.editable).includes(this.editable)
        ) {
            this.observerUnactive();
            block.setAttribute('placeholder', text);
            block.classList.add('oe-hint');
            if (temporary) {
                block.classList.add('oe-command-temporary-hint');
            }
            this.observerActive();
        }
    }

    /**
     * Places the cursor in a safe place (not the editable root).
     * Inserts an empty paragraph if selection results from mouse click and
     * there's no other way to insert text before/after a block.
     *
     * @param {Selection} selection - Collapsed selection at the editable root.
     * @param {String} currentKeyPress
     */
    _fixSelectionOnEditableRoot(selection, currentKeyPress) {
        if (!this.editable.isContentEditable) {
            return;
        }
        let nodeAfterCursor = this.editable.childNodes[selection.anchorOffset];
        let nodeBeforeCursor = nodeAfterCursor && nodeAfterCursor.previousElementSibling;
        // Handle arrow key presses.
        if (currentKeyPress === 'ArrowRight' || currentKeyPress === 'ArrowDown') {
            while (nodeAfterCursor && isNotAllowedContent(nodeAfterCursor)) {
                nodeAfterCursor = nodeAfterCursor.nextElementSibling;
            }
            if (nodeAfterCursor) {
                setSelection(...getDeepestPosition(nodeAfterCursor, 0));
            } else {
                this.historyResetLatestComputedSelection(true);
            }
        } else if (currentKeyPress === 'ArrowLeft' || currentKeyPress === 'ArrowUp') {
            while (nodeBeforeCursor && isNotAllowedContent(nodeBeforeCursor)) {
                nodeBeforeCursor = nodeBeforeCursor.previousElementSibling;
            }
            if (nodeBeforeCursor) {
                setSelection(...getDeepestPosition(nodeBeforeCursor, nodeSize(nodeBeforeCursor)));
            } else {
                this.historyResetLatestComputedSelection(true);
            }
        // Handle cursor next to a 'P'.
        } else if (nodeAfterCursor && paragraphRelatedElements.includes(nodeAfterCursor.nodeName)) {
            // Cursor is right before a 'P'.
            setCursorStart(nodeAfterCursor);
        } else if (nodeBeforeCursor && paragraphRelatedElements.includes(nodeBeforeCursor.nodeName)) {
            // Cursor is right after a 'P'.
            setCursorEnd(nodeBeforeCursor);
        // Handle cursor not next to a 'P'.
        // Insert a new 'P' if selection resulted from a mouse click.
        } else if (this._currentMouseState === 'mousedown') {
            this._recordHistorySelection(true);
            const p = this.document.createElement('p');
            p.append(this.document.createElement('br'));
            if (!nodeAfterCursor) {
                // Cursor is at the end of the editable.
                this.editable.append(p);
            } else if (!nodeBeforeCursor) {
                // Cursor is at the beginning of the editable.
                this.editable.prepend(p);
            } else {
                // Cursor is between two non-p blocks
                nodeAfterCursor.before(p);
            }
            setCursorStart(p);
            this.historyStep();
        } else {
            // Remove selection as a fallback.
            selection.removeAllRanges();
        }
    }

    _onMouseup(ev) {
        this._currentMouseState = ev.type;

        this._fixFontAwesomeSelection();
    }

    _onMouseDown(ev) {
        this._currentMouseState = ev.type;
        this._lastMouseClickPosition = [ev.x, ev.y];

        if (this.canActivateContentEditable) {
            this._activateContenteditable();
        }

        // Ignore any changes that might have happened before this point.
        this.observer.takeRecords();

        const node = ev.target;
        // handle checkbox lists
        if (node.tagName == 'LI' && getListMode(node.parentElement) == 'CL') {
            const beforStyle = window.getComputedStyle(node, ':before');
            const style1 = {
                left: parseInt(beforStyle.getPropertyValue('left'), 10),
                top: parseInt(beforStyle.getPropertyValue('top'), 10),
            }
            style1.right = style1.left + parseInt(beforStyle.getPropertyValue('width'), 10);
            style1.bottom = style1.top + parseInt(beforStyle.getPropertyValue('height'), 10);

            const isMouseInsideCheckboxBox =
                ev.offsetX >= style1.left &&
                ev.offsetX <= style1.right &&
                ev.offsetY >= style1.top &&
                ev.offsetY <= style1.bottom;

            if (isMouseInsideCheckboxBox) {
                toggleClass(node, 'o_checked');
                this.historyStep();
                if (!document.getSelection().isCollapsed) {
                    this._updateToolbar(true);
                }
            }
        }

        // handle stars
        const isStar = el => el.nodeType === Node.ELEMENT_NODE && (
            el.classList.contains('fa-star') || el.classList.contains('fa-star-o')
        );
        if (isStar(node) &&
            node.parentElement && node.parentElement.className.includes('o_stars')) {
            const previousStars = getAdjacentPreviousSiblings(node, isStar);
            const nextStars = getAdjacentNextSiblings(node, isStar);
            if (nextStars.length || previousStars.length) {
                const shouldToggleOff = node.classList.contains('fa-star') &&
                    (!nextStars[0] || !nextStars[0].classList.contains('fa-star'));
                for (const star of [...previousStars, node]) {
                    star.classList.toggle('fa-star-o', shouldToggleOff);
                    star.classList.toggle('fa-star', !shouldToggleOff);
                };
                for (const star of nextStars) {
                    star.classList.toggle('fa-star-o', true);
                    star.classList.toggle('fa-star', false);
                };
                this.historyStep();
            }
        }

        // Handle table selection.
        if (this.toolbar && !ancestors(ev.target, this.editable).includes(this.toolbar)) {
            this.toolbar.style.pointerEvents = 'none';
            if (this.deselectTable() && hasValidSelection(this.editable)) {
                this.document.getSelection().collapseToStart();
                this._updateToolbar(false);
            }
        }
        // Handle table resizing.
        const isHoveringTdBorder = this._isHoveringTdBorder(ev);
        const isRTL = this.options.direction === 'rtl';
        if (isHoveringTdBorder) {
            ev.preventDefault();
            const direction = { top: 'row', right: 'col', bottom: 'row', left: 'col' }[isHoveringTdBorder] || false;
            let target1, target2;
            const column = closestElement(ev.target, 'tr');
            if (isHoveringTdBorder === 'top' && column) {
                target1 = getAdjacentPreviousSiblings(column).find(node => node.nodeName === 'TR');
                target2 = closestElement(ev.target, 'tr');
            } else if (isHoveringTdBorder === 'right') {
                if (isRTL) {
                    target1 = getAdjacentPreviousSiblings(ev.target).find(node => node.nodeName === 'TD');
                    target2 = ev.target;
                } else {
                    target1 = ev.target;
                    target2 = getAdjacentNextSiblings(ev.target).find(node => node.nodeName === 'TD');
                }
            } else if (isHoveringTdBorder === 'bottom' && column) {
                target1 = closestElement(ev.target, 'tr');
                target2 = getAdjacentNextSiblings(column).find(node => node.nodeName === 'TR');
            } else if (isHoveringTdBorder === 'left') {
                if (isRTL) {
                    target1 = ev.target;
                    target2 = getAdjacentNextSiblings(ev.target).find(node => node.nodeName === 'TD');
                } else {
                    target1 = getAdjacentPreviousSiblings(ev.target).find(node => node.nodeName === 'TD');
                    target2 = ev.target;
                }
            }
            this._isResizingTable = true;
            this._toggleTableResizeCursor(direction);
            const resizeTable = ev => this._resizeTable(ev, direction, target1, target2);
            const stopResizing = ev => {
                ev.preventDefault();
                this._isResizingTable = false;
                this._toggleTableResizeCursor(false);
                this.historyStep();
                this.document.removeEventListener('mousemove', resizeTable);
                this.document.removeEventListener('mouseup', stopResizing);
                this.document.removeEventListener('mouseleave', stopResizing);
            };
            this.document.addEventListener('mousemove', resizeTable);
            this.document.addEventListener('mouseup', stopResizing);
            this.document.addEventListener('mouseleave', stopResizing);
        }

        // Handle emoji popover
        const isEmojiPopover = document.querySelector('.o-EmojiPicker');
        if (isEmojiPopover && ev.target !== isEmojiPopover) {
            isEmojiPopover.remove();
        }
    }

    _onScroll(ev) {
        if (this._rowUiTarget && !this._rowUi.classList.contains('o_open')) {
            this._positionTableUi(this._rowUiTarget);
        }
        if (this._columnUiTarget && !this._columnUi.classList.contains('o_open')) {
            this._positionTableUi(this._columnUiTarget);
        }
    }

    _onDocumentKeydown(ev) {
        const canUndoRedo = !['INPUT', 'TEXTAREA'].includes(this.document.activeElement.tagName);

        if (this.options.controlHistoryFromDocument && canUndoRedo) {
            if (IS_KEYBOARD_EVENT_UNDO(ev) && canUndoRedo) {
                ev.preventDefault();
                this.historyUndo();
            } else if (IS_KEYBOARD_EVENT_REDO(ev) && canUndoRedo) {
                ev.preventDefault();
                this.historyRedo();
            }
        } else {
            if (IS_KEYBOARD_EVENT_REDO(ev) || IS_KEYBOARD_EVENT_UNDO(ev)) {
                this._onKeyupResetContenteditableNodes.push(
                    ...this.editable.querySelectorAll('[contenteditable=true]'),
                );
                if (this.editable.getAttribute('contenteditable') === 'true') {
                    this._onKeyupResetContenteditableNodes.push(this.editable);
                }

                for (const node of this._onKeyupResetContenteditableNodes) {
                    this.automaticStepSkipStack();
                    node.setAttribute('contenteditable', false);
                }
            }
        }
    }

    _onDocumentKeyup() {
        if (this._onKeyupResetContenteditableNodes.length) {
            for (const node of this._onKeyupResetContenteditableNodes) {
                this.automaticStepSkipStack();
                node.setAttribute('contenteditable', true);
            }
            this._onKeyupResetContenteditableNodes = [];
        }
    }

    _onDocumentMouseup(ev) {
        this._currentMouseState = ev.type;
        if (this.toolbar) {
            this.toolbar.style.pointerEvents = 'auto';
        }
    }

    _onMousemove(ev) {
        if (this._currentMouseState === 'mousedown' && !this._isResizingTable) {
            this._handleSelectionInTable(ev);
        }
        if (!this._rowUi.classList.contains('o_open') && !this._columnUi.classList.contains('o_open')) {
            const column = closestElement(ev.target, 'td');
            if (this._isResizingTable || !column || !column.isContentEditable || !ev.target || ev.target.nodeType !== Node.ELEMENT_NODE) {
                this._toggleTableUi(false, false);
            } else {
                const row = closestElement(column, 'tr');
                const isFirstColumn = column === row.querySelector('td');
                const table = column && closestElement(column, 'table');
                const isFirstRow = table && row === table.querySelector('tr');
                this._toggleTableUi(isFirstColumn && row, isFirstRow && column);
            }
        }
        const direction = {top: 'row', right: 'col', bottom: 'row', left: 'col'}[this._isHoveringTdBorder(ev)] || false;
        if (direction || !this._isResizingTable) {
            this._toggleTableResizeCursor(direction);
        }
    }

    _onMouseLeave(ev) {
        if (!this._isResizingTable) {
            this._toggleTableResizeCursor(false);
        }
    }

    _onDocumentClick(ev) {
        // Close Table UI.
        this._rowUi.classList.remove('o_open');
        this._columnUi.classList.remove('o_open');
    }

    /**
     * Inserts a link in the editor. Called after pressing space or (shif +) enter.
     * Performs a regex check to determine if the url has correct syntax.
     */
    _handleAutomaticLinkInsertion() {
        const selection = this.document.getSelection();
        if (
            selection &&
            selection.anchorNode &&
            isHtmlContentSupported(selection.anchorNode) &&
            !closestElement(selection.anchorNode).closest('a') &&
            selection.anchorNode.nodeType === Node.TEXT_NODE
        ) {
            // Merge adjacent text nodes.
            selection.anchorNode.parentNode.normalize();
            const textSliced = selection.anchorNode.textContent.slice(0, selection.anchorOffset);
            const textNodeSplitted = textSliced.split(/\s/);
            const potentialUrl = textNodeSplitted.pop() || '';
            // In case of multiple matches, only the last one will be converted.
            const match = [...potentialUrl.matchAll(new RegExp(URL_REGEX, 'g'))].pop();

            if (match && !EMAIL_REGEX.test(match[0])) {
                const nodeForSelectionRestore = selection.anchorNode.splitText(selection.anchorOffset);
                const url = match[2] ? match[0] : 'http://' + match[0];
                const range = this.document.createRange();
                const startOffset = selection.anchorOffset - potentialUrl.length + match.index;
                range.setStart(selection.anchorNode, startOffset);
                range.setEnd(selection.anchorNode, startOffset + match[0].length);
                const link = this._createLink(range.extractContents().textContent, url);
                range.insertNode(link);
                setCursorStart(nodeForSelectionRestore, false);
            }
        }
    }

    /**
     * @param {String} label
     * @param {String} url
     */
    _createLink(label, url) {
        const link = this.document.createElement('a');
        link.setAttribute('href', url);
        for (const [param, value] of Object.entries(this.options.defaultLinkAttributes)) {
            link.setAttribute(param, `${value}`);
        }
        link.innerText = label;
        return link;
    }
    /**
     * Add images inside the editable at the current selection.
     *
     * @param {File[]} imageFiles
     */
    addImagesFiles(imageFiles) {
        const promises = [];
        for (const imageFile of imageFiles) {
            const imageNode = document.createElement('img');
            imageNode.classList.add('img-fluid');
            // Mark images as having to be saved as attachments.
            if (this.options.dropImageAsAttachment) {
                imageNode.classList.add('o_b64_image_to_save');
            }
            imageNode.dataset.fileName = imageFile.name;
            promises.push(getImageUrl(imageFile).then(url => {
                imageNode.src = url;
                return imageNode;
            }));
        }
        return Promise.all(promises).then(nodes => {
            const fragment = document.createDocumentFragment();
            fragment.append(...nodes);
            return fragment;
        });
    }
    /**
     * Handle safe pasting of html or plain text into the editor.
     */
    _onPaste(ev) {
        const sel = this.document.getSelection();
        if (sel.anchorNode && isProtected(sel.anchorNode)) {
            return;
        }
        ev.preventDefault();
        const files = getImageFiles(ev.clipboardData);
        const odooEditorHtml = ev.clipboardData.getData('text/odoo-editor');
        const clipboardHtml = ev.clipboardData.getData('text/html');
        const targetSupportsHtmlContent = isHtmlContentSupported(sel.anchorNode);
        // Replace entire link if its label is fully selected.
        const link = closestElement(sel.anchorNode, 'a');
        if (link && sel.toString().replace(ZERO_WIDTH_CHARS_REGEX, '') === link.innerText.replace(ZERO_WIDTH_CHARS_REGEX, '')) {
            const start = leftPos(link);
            link.remove();
            setSelection(...start, ...start, false);
        }
        if (!targetSupportsHtmlContent) {
            const text = ev.clipboardData.getData("text/plain");
            this._applyCommand("insert", text);
        } else if (odooEditorHtml) {
            const fragment = parseHTML(this.document, odooEditorHtml);
            const selector = this.options.renderingClasses.map(c => `.${c}`).join(',');
            if (selector) {
                for (const element of fragment.querySelectorAll(selector)) {
                    element.classList.remove(...this.options.renderingClasses);
                }
            }
            // Instantiate DOMPurify with the correct window.
            this.DOMPurify ??= DOMPurify(this.document.defaultView);
            this.DOMPurify.sanitize(fragment, { IN_PLACE: true });
            if (fragment.hasChildNodes()) {
                this._applyCommand('insert', fragment);
            }
        } else if (files.length || clipboardHtml) {
            const clipboardElem = this._prepareClipboardData(clipboardHtml);
            // When copy pasting a table from the outside, a picture of the
            // table can be included in the clipboard as an image file. In that
            // particular case the html table is given a higher priority than
            // the clipboard picture.
            if (files.length && !clipboardElem.querySelector('table')) {
                this.addImagesFiles(files).then(html => {
                    this._applyCommand('insert', html);
                });
            } else {
                if (closestElement(sel.anchorNode, 'a')) {
                    this._applyCommand('insert', clipboardElem.textContent);
                }
                else {
                    this._applyCommand('insert', clipboardElem);
                }
            }
        } else {
            const text = ev.clipboardData.getData('text/plain');
            const selectionIsInsideALink = !!closestElement(sel.anchorNode, 'a');
            let splitAroundUrl = [text];
            // Avoid transforming dynamic placeholder pattern to url.
            if(!text.match(/\${.*}/gi)) {
                splitAroundUrl = text.split(URL_REGEX);
                // Remove 'http(s)://' capturing group from the result (indexes
                // 2, 5, 8, ...).
                splitAroundUrl = splitAroundUrl.filter((_, index) => ((index + 1) % 3));
            }
            if (splitAroundUrl.length === 3 && !splitAroundUrl[0] && !splitAroundUrl[2]) {
                // Pasted content is a single URL.
                const url = /^https?:\/\//i.test(text) ? text : 'http://' + text;
                const youtubeUrl = this.options.allowCommandVideo && YOUTUBE_URL_GET_VIDEO_ID.exec(url);
                const urlFileExtention = url.split('.').pop();
                const isImageUrl = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp'].includes(urlFileExtention.toLowerCase());
                // A url cannot be transformed inside an existing link.
                // An image can be embedded inside an existing link, a video cannot.
                if (selectionIsInsideALink) {
                    if (isImageUrl) {
                        const img = document.createElement('IMG');
                        img.setAttribute('src', url);
                        this._applyCommand('insert', img);
                    } else {
                        this._applyCommand('insert', text);
                    }
                } else if (isImageUrl || youtubeUrl) {
                    // Open powerbox with commands to embed media or paste as link.
                    // Store history step index to revert it later.
                    const stepIndexBeforeInsert = this._historySteps.length - 1;
                    // Store mutations before text insertion, to reapply them after history revert.
                    this.observerFlush();
                    const currentStepMutations = [...this._currentStep.mutations];
                    // Insert URL as text, revert it later.
                    this._applyCommand('insert', text);
                    const revertTextInsertion = () => {
                        this.historyRevertUntil(stepIndexBeforeInsert);
                        this.historyStep(true);
                        this._historyStepsStates.set(peek(this._historySteps).id, 'consumed');
                        // Reapply mutations that were done before the text insertion.
                        this.historyApply(currentStepMutations);
                    };
                    let commands;
                    const pasteAsURLCommand = {
                        name: this.options._t('Paste as URL'),
                        description: this.options._t('Create an URL.'),
                        fontawesome: 'fa-link',
                        callback: () => {
                            revertTextInsertion();
                            this._applyRawCommand('insert', this._createLink(text, url))
                        },
                    };
                    if (isImageUrl) {
                        const embedImageCommand = {
                            name: this.options._t('Embed Image'),
                            description: this.options._t('Embed the image in the document.'),
                            fontawesome: 'fa-image',
                            callback: () => {
                                revertTextInsertion();
                                const img = document.createElement('IMG');
                                img.setAttribute('src', url);
                                this._applyRawCommand('insert', img);
                            },
                        };
                        commands = [embedImageCommand, pasteAsURLCommand];
                    } else {
                         // URL is a YouTube video.
                        const embedVideoCommand = {
                            name: this.options._t('Embed Youtube Video'),
                            description: this.options._t('Embed the youtube video in the document.'),
                            fontawesome: 'fa-youtube-play',
                            callback: async () => {
                                revertTextInsertion();
                                let videoElement;
                                if (this.options.getYoutubeVideoElement) {
                                    videoElement = await this.options.getYoutubeVideoElement(youtubeUrl[0]);
                                } else {
                                    videoElement = document.createElement('iframe');
                                    videoElement.setAttribute('width', '560');
                                    videoElement.setAttribute('height', '315');
                                    videoElement.setAttribute(
                                        'src',
                                        `https://www.youtube.com/embed/${encodeURIComponent(youtubeUrl[1])}`,
                                    );
                                    videoElement.setAttribute('title', 'YouTube video player');
                                    videoElement.setAttribute('frameborder', '0');
                                    videoElement.setAttribute(
                                        'allow',
                                        'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture',
                                    );
                                    videoElement.setAttribute('allowfullscreen', '1');
                                }
                                this._applyRawCommand('insert', videoElement);
                            },
                        };
                        commands = [embedVideoCommand, pasteAsURLCommand];
                    }
                    this.powerbox.open(commands);
                } else {
                    this._applyCommand('insert', this._createLink(text, url));
                }
            } else {
                this.historyPauseSteps();
                for (let i = 0; i < splitAroundUrl.length; i++) {
                    const url = /^https?:\/\//gi.test(splitAroundUrl[i])
                        ? splitAroundUrl[i]
                        : 'http://' + splitAroundUrl[i];
                    // Even indexes will always be plain text, and odd indexes will always be URL.
                    // A url cannot be transformed inside an existing link.
                    if (i % 2 && !selectionIsInsideALink) {
                        this._applyCommand('insert', this._createLink(splitAroundUrl[i], url));
                    } else if (splitAroundUrl[i] !== '') {
                        const textFragments = splitAroundUrl[i].split(/\r?\n/);
                        let textIndex = 1;
                        for (const textFragment of textFragments) {
                            // Replace consecutive spaces by alternating nbsp.
                            const modifiedTextFragment = textFragment.replace(/( {2,})/g, match => {
                                let alertnateValue = false;
                                return match.replace(/ /g, () => {
                                    alertnateValue = !alertnateValue;
                                    const replaceContent = alertnateValue ? '\u00A0' : ' ';
                                    return replaceContent;
                                });
                            });
                            this._applyCommand('insert', modifiedTextFragment);
                            if (textIndex < textFragments.length) {
                                // Break line by inserting new paragraph and
                                // remove current paragraph's bottom margin.
                                const p = closestElement(sel.anchorNode, 'p');
                                if (isUnbreakable(closestBlock(sel.anchorNode))) {
                                    this._applyCommand('oShiftEnter');
                                } else {
                                    this._applyCommand('oEnter');
                                    p && (p.style.marginBottom = '0px');
                                }
                            }
                            textIndex++;
                        }
                    }
                }
                this.historyUnpauseSteps();
                this.historyStep();
            }
        }
    }
    _onDragStart(ev) {
        if (ev.target.nodeName === 'IMG') {
            ev.dataTransfer.setData('text/plain', `oid:${ev.target.oid}`);
        }
    }
    /**
     * Handle safe dropping of html into the editor.
     */
    _onDrop(ev) {
        ev.preventDefault();
        if (!isHtmlContentSupported(ev.target)) {
            return;
        }
        const sel = this.document.getSelection();
        let isInEditor = false;
        let ancestor = sel.anchorNode;
        while (ancestor && !isInEditor) {
            if (ancestor === this.editable) {
                isInEditor = true;
            }
            ancestor = ancestor.parentNode;
        }
        const dataTransfer = (ev.originalEvent || ev).dataTransfer;
        const imageOidMatch = (dataTransfer.getData('text') || '').match('oid:(.*)');
        const imageOid = imageOidMatch && imageOidMatch[1];
        const image = imageOid && [...this.editable.querySelectorAll('*')].find(
            node => node.oid === imageOid,
        );
        const fileTransferItems = getImageFiles(dataTransfer);
        const htmlTransferItem = [...dataTransfer.items].find(
            item => item.type === 'text/html',
        );
        if (image || fileTransferItems.length || htmlTransferItem) {
            if (this.document.caretPositionFromPoint) {
                const range = this.document.caretPositionFromPoint(ev.clientX, ev.clientY);
                setSelection(range.offsetNode, range.offset);
            } else if (this.document.caretRangeFromPoint) {
                const range = this.document.caretRangeFromPoint(ev.clientX, ev.clientY);
                setSelection(range.startContainer, range.startOffset);
            }
        }
        if (image) {
            image.classList.toggle('img-fluid', true);
            const html = image.outerHTML;
            image.remove();
            this.execCommand('insert', this._prepareClipboardData(html));
        } else if (fileTransferItems.length) {
            this.addImagesFiles(fileTransferItems).then(html => {
                this.execCommand('insert', html);
            });
        } else if (htmlTransferItem) {
            htmlTransferItem.getAsString(pastedText => {
                this.execCommand('insert', this._prepareClipboardData(pastedText));
            });
        }
        this.historyStep();
    }

    _onTabulationInTable(ev) {
        const sel = this.document.getSelection();
        const closestTable = closestElement(sel.anchorNode, 'table');
        if (!closestTable) {
            return;
        }
        const closestTd = closestElement(sel.anchorNode, 'td');
        const tds = [...closestTable.querySelectorAll('td')];
        const direction = ev.shiftKey ? DIRECTIONS.LEFT : DIRECTIONS.RIGHT;
        const cursorDestination =
            tds[tds.findIndex(td => closestTd === td) + (direction === DIRECTIONS.LEFT ? -1 : 1)];
        if (cursorDestination) {
            setCursorEnd(lastLeaf(cursorDestination));
        } else if (direction === DIRECTIONS.RIGHT) {
            this.execCommand('addRow', 'after');
            this._onTabulationInTable(ev);
        }
    }
    _onTableMenuTogglerClick(ev) {
        const uiWrapper = ev.target.closest('.o_table_ui');
        uiWrapper.classList.toggle('o_open');

        if (this.options.direction === 'rtl') {
            const menuRowEl = this._tableUiContainer.querySelector('.o_row_ui .o_table_ui_menu')
            const menuRowRect = menuRowEl.getBoundingClientRect();
            menuRowEl.style.position = 'absolute';
            menuRowEl.style.left = `-${menuRowRect.width}px`;
            menuRowEl.style.margin = `0px`;
        }

        if (uiWrapper.classList.contains('o_column_ui')) {
            const columnIndex = getColumnIndex(this._columnUiTarget);
            uiWrapper.querySelector('.o_move_left').classList.toggle('o_hide', columnIndex === 0);
            const shouldHideRight = columnIndex === [...this._columnUiTarget.parentElement.children].filter(child => child.nodeName === 'TD').length - 1;
            uiWrapper.querySelector('.o_move_right').classList.toggle('o_hide', shouldHideRight);
        } else {
            const rowIndex = getRowIndex(this._rowUiTarget);
            uiWrapper.querySelector('.o_move_up').classList.toggle('o_hide', rowIndex === 0);
            const shouldHideDown = rowIndex === [...this._rowUiTarget.parentElement.children].filter(child => child.nodeName === 'TR').length - 1;
            uiWrapper.querySelector('.o_move_down').classList.toggle('o_hide', shouldHideDown);
        }
        ev.stopPropagation();
    }
    _onTableMoveUpClick() {
        if (this._rowUiTarget.previousSibling) {
            // When moving the second row up, copy the widths of first row's td
            // elements to second row's td elements, as td widths are only
            // applied to the first row.
            if (!this._rowUiTarget.previousSibling.previousSibling) {
                this._rowUiTarget.childNodes.forEach((cell, index) => {
                    cell.style.width = this._rowUiTarget.previousSibling.childNodes[index].style.width;
                });
            }
            this._rowUiTarget.previousSibling.before(this._rowUiTarget);
        }
    }
    _onTableMoveDownClick() {
        if (this._rowUiTarget.nextSibling) {
            // When moving the first row down, copy the widths of its td
            // elements to second row's td elements, as td widths are only
            // applied to the first row.
            if (!this._rowUiTarget.previousSibling) {
                this._rowUiTarget.nextSibling.childNodes.forEach((cell, index) => {
                    cell.style.width = this._rowUiTarget.childNodes[index].style.width;
                });
            }
            this._rowUiTarget.nextSibling.after(this._rowUiTarget);
        }
    }
    _onTableMoveRightClick() {
        const trs = [...this._columnUiTarget.parentElement.parentElement.children].filter(child => child.nodeName === 'TR');
        const columnIndex = getColumnIndex(this._columnUiTarget);
        const tdsToMove = trs.map(tr => [...tr.children].filter(child => child.nodeName === 'TD')[columnIndex]);
        for (const tdToMove of tdsToMove) {
            const target = [...tdToMove.parentElement.children].filter(child => child.nodeName === 'TD')[columnIndex + 1];
            target.after(tdToMove);
        }
    }
    _onTableMoveLeftClick() {
        const trs = [...this._columnUiTarget.parentElement.parentElement.children].filter(child => child.nodeName === 'TR');
        const columnIndex = getColumnIndex(this._columnUiTarget);
        const tdsToMove = trs.map(tr => [...tr.children].filter(child => child.nodeName === 'TD')[columnIndex]);
        for (const tdToMove of tdsToMove) {
            const target = [...tdToMove.parentElement.children].filter(child => child.nodeName === 'TD')[columnIndex - 1];
            target.before(tdToMove);
        }
    }
    _onTableDeleteColumnClick() {
        this.historyPauseSteps();
        const rows = [...closestElement(this._columnUiTarget, 'tr').parentElement.children].filter(child => child.nodeName === 'TR');
        this.execCommand('removeColumn', this._columnUiTarget);
        if (rows.every(row => !row.parentElement)) {
            this.execCommand('deleteTable', this.editable.querySelector('.o_selected_table'));
        }
        this.historyUnpauseSteps();
        this.historyStep();
    }
    _onTableDeleteRowClick() {
        this.historyPauseSteps();
        const rows = [...this._rowUiTarget.parentElement.children].filter(child => child.nodeName === 'TR');
        this.execCommand('removeRow', this._rowUiTarget);
        if (rows.every(row => !row.parentElement)) {
            this.execCommand('deleteTable', this.editable.querySelector('.o_selected_table'));
        }
        this.historyUnpauseSteps();
        this.historyStep();
    }

    /**
     * Fix the current selection range in case the range start or end inside a fontAwesome node
     */
    _fixFontAwesomeSelection() {
        const selection = this.document.getSelection();
        if (
            selection.isCollapsed ||
            (selection.anchorNode &&
                !ancestors(selection.anchorNode, this.editable).includes(this.editable))
        )
            return;
        let shouldUpdateSelection = false;
        const fixedSelection = {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset,
        };
        const selectionDirection = getCursorDirection(
            selection.anchorNode,
            selection.anchorOffset,
            selection.focusNode,
            selection.focusOffset,
        );
        // check and fix anchor node
        const closestAnchorNodeEl = closestElement(selection.anchorNode);
        if (isFontAwesome(closestAnchorNodeEl)) {
            shouldUpdateSelection = true;
            fixedSelection.anchorNode =
                selectionDirection === DIRECTIONS.RIGHT
                    ? closestAnchorNodeEl.previousSibling
                    : closestAnchorNodeEl.nextSibling;
            if (fixedSelection.anchorNode) {
                fixedSelection.anchorOffset =
                    selectionDirection === DIRECTIONS.RIGHT ? fixedSelection.anchorNode.length : 0;
            } else {
                fixedSelection.anchorNode = closestAnchorNodeEl.parentElement;
                fixedSelection.anchorOffset = 0;
            }
        }
        // check and fix focus node
        const closestFocusNodeEl = closestElement(selection.focusNode);
        if (isFontAwesome(closestFocusNodeEl)) {
            shouldUpdateSelection = true;
            fixedSelection.focusNode =
                selectionDirection === DIRECTIONS.RIGHT
                    ? closestFocusNodeEl.nextSibling
                    : closestFocusNodeEl.previousSibling;
            if (fixedSelection.focusNode) {
                fixedSelection.focusOffset =
                    selectionDirection === DIRECTIONS.RIGHT ? 0 : fixedSelection.focusNode.length;
            } else {
                fixedSelection.focusNode = closestFocusNodeEl.parentElement;
                fixedSelection.focusOffset = 0;
            }
        }
        if (shouldUpdateSelection) {
            setSelection(
                fixedSelection.anchorNode,
                fixedSelection.anchorOffset,
                fixedSelection.focusNode,
                fixedSelection.focusOffset,
                false,
            );
        }
    }
    _pluginAdd(Plugin) {
        this._plugins.push(new Plugin({ editor: this }));
    }
    _pluginCall(method, args = []) {
        for (const plugin of this._plugins) {
            if (plugin[method]) {
                plugin[method](...args);
            }
        }
    }
}

return __exports;
});
;

/**********************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/utils/constants.js  *
*  Lines: 10                                                                      *
**********************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/utils/constants', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const UNBREAKABLE_ROLLBACK_CODE = __exports.UNBREAKABLE_ROLLBACK_CODE = 'UNBREAKABLE';
const UNREMOVABLE_ROLLBACK_CODE = __exports.UNREMOVABLE_ROLLBACK_CODE = 'UNREMOVABLE';
const REGEX_BOOTSTRAP_COLUMN = __exports.REGEX_BOOTSTRAP_COLUMN = /(?:^| )col(-[a-zA-Z]+)?(-\d+)?(?:$| )/;

return __exports;
});
;

/*********************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/utils/sanitize.js  *
*  Lines: 373                                                                    *
*********************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/utils/sanitize', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const {
    closestBlock,
    closestElement,
    startPos,
    getListMode,
    isBlock,
    isSelfClosingElement,
    moveNodes,
    preserveCursor,
    isFontAwesome,
    getDeepRange,
    isUnbreakable,
    isEditorTab,
    isProtected,
    isZWS,
    isArtificialVoidElement,
    ancestors,
    EMAIL_REGEX,
    PHONE_REGEX,
    URL_REGEX,
    unwrapContents,
    padLinkWithZws,
    getTraversedNodes,
    ZERO_WIDTH_CHARS_REGEX,
    isVisible,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

const NOT_A_NUMBER = /[^\d]/g;

// In some cases, we want to prevent merging identical elements.
const UNMERGEABLE_SELECTORS = __exports.UNMERGEABLE_SELECTORS = [];

function hasPseudoElementContent (node, pseudoSelector) {
    const content = getComputedStyle(node, pseudoSelector).getPropertyValue('content');
    return content && content !== 'none';
}

__exports.areSimilarElements = areSimilarElements; function areSimilarElements(node, node2) {
    if (![node, node2].every(n => n?.nodeType === Node.ELEMENT_NODE)) {
        return false; // The nodes don't both exist or aren't both elements.
    }
    if (node.nodeName !== node2.nodeName) {
        return false; // The nodes aren't the same type of element.
    }
    const nodeName = node.nodeName;

    for (const name of new Set([
        ...node.getAttributeNames(),
        ...node2.getAttributeNames(),
    ])) {
        if (node.getAttribute(name) !== node2.getAttribute(name)) {
            return false; // The nodes don't have the same attributes.
        }
    }
    if ([node, node2].some(n => hasPseudoElementContent(n, ':before') || hasPseudoElementContent(n, ':after'))) {
        return false; // The nodes have pseudo elements with content.
    }
    if (isFontAwesome(node) || isFontAwesome(node2)) {
        return false;
    }
    if (nodeName === 'LI' && node.classList.contains('oe-nested')) {
        // If the nodes are adjacent nested list items, we need to compare the
        // types of their "adjacent" list children rather that the list items
        // themselves.
        return (
            node.lastElementChild &&
            node2.firstElementChild &&
            getListMode(node.lastElementChild) === getListMode(node2.firstElementChild)
        );
    }
    if (['UL', 'OL'].includes(nodeName)) {
        return !isSelfClosingElement(node) && !isSelfClosingElement(node2); // The nodes are non-empty lists. TODO: this doesn't check that and it will always be true!
    }
    if (isBlock(node) || isSelfClosingElement(node) || isSelfClosingElement(node2)) {
        return false; // The nodes are blocks or are empty but visible. TODO: Not sure this was what we wanted to check (see just above).
    }
    const nodeStyle = getComputedStyle(node);
    const node2Style = getComputedStyle(node2);
    return (
        !+nodeStyle.padding.replace(NOT_A_NUMBER, '') &&
        !+node2Style.padding.replace(NOT_A_NUMBER, '') &&
        !+nodeStyle.margin.replace(NOT_A_NUMBER, '') &&
        !+node2Style.margin.replace(NOT_A_NUMBER, '')
    );
}

/**
* Returns a complete URL if text is a valid email address, http URL or telephone
* number, null otherwise.
* The optional link parameter is used to prevent protocol switching between
* 'http' and 'https'.
*
* @param {String} text
* @param {HTMLAnchorElement} [link]
* @returns {String|null}
*/
__exports.deduceURLfromText = deduceURLfromText; function deduceURLfromText(text, link) {
   const label = text.replace(ZERO_WIDTH_CHARS_REGEX, '').trim();
   // Check first for e-mail.
   let match = label.match(EMAIL_REGEX);
   if (match) {
       return match[1] ? match[0] : 'mailto:' + match[0];
   }
   // Check for http link.
   match = label.match(URL_REGEX);
   if (match && match[0] === label) {
       const currentHttpProtocol = (link?.href.match(/^http(s)?:\/\//gi) || [])[0];
       if (match[2]) {
           return match[0];
       } else if (currentHttpProtocol) {
           // Avoid converting a http link to https.
           return currentHttpProtocol + match[0];
       } else {
           return 'http://' + match[0];
       }
   }
   // Check for telephone url.
   match = label.match(PHONE_REGEX);
   if (match) {
       return match[1] ? match[0] : 'tel://' + match[0];
   }
   return null;
}

function shouldPreserveCursor(node, root) {
    const selection = root.ownerDocument.getSelection();
    return node.isConnected && selection &&
        selection.anchorNode && root.contains(selection.anchorNode) &&
        selection.focusNode && root.contains(selection.focusNode);
}

/**
 * Sanitize the given node and return it.
 *
 * @param {Node} node
 * @param {Element} root
 * @returns {Node} the sanitized node
 */
function sanitizeNode(node, root) {
    // First ensure elements which should not contain any content are tagged
    // contenteditable=false to avoid any hiccup.
    if (isArtificialVoidElement(node) && node.getAttribute('contenteditable') !== 'false') {
        node.setAttribute('contenteditable', 'false');
    }

    // Remove empty class/style attributes.
    for (const attributeName of ['class', 'style']) {
        if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute(attributeName) && !node.getAttribute(attributeName)) {
            node.removeAttribute(attributeName);
        }
    }

    if (
        ['SPAN', 'FONT'].includes(node.nodeName)
        && !node.hasAttributes()
        && !hasPseudoElementContent(node, "::before")
        && !hasPseudoElementContent(node, "::after")
    ) {
        // Unwrap the contents of SPAN and FONT elements without attributes.
        getDeepRange(root, { select: true });
        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);
        const parent = node.parentElement;
        unwrapContents(node);
        restoreCursor && restoreCursor();
        node = parent; // The node has been removed, update the reference.
    } else if (
        areSimilarElements(node, node.previousSibling) &&
        !isUnbreakable(node) &&
        !isEditorTab(node) &&
        !(
            node.attributes?.length === 1 &&
            node.hasAttribute('data-oe-zws-empty-inline') &&
            (node.textContent === '\u200B' || node.previousSibling.textContent === '\u200B')
        ) &&
        !UNMERGEABLE_SELECTORS.some(selectorClass => node.classList?.contains(selectorClass))
    ) {
        // Merge identical elements together.
        getDeepRange(root, { select: true });
        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);
        moveNodes(...startPos(node), node.previousSibling);
        restoreCursor && restoreCursor();
    } else if (node.nodeType === Node.COMMENT_NODE) {
        // Remove comment nodes to avoid issues with mso comments.
        const parent = node.parentElement;
        node.remove();
        node = parent; // The node has been removed, update the reference.
    } else if (
        node.nodeName === 'P' && // Note: not sure we should limit to <p>.
        ['LI', 'A'].includes(node.parentElement.nodeName) &&
        !node.parentElement.classList.contains('nav-item')
    ) {
        // Remove empty paragraphs in <li>.
        const previous = node.previousSibling;
        const attributes = node.attributes;
        const parent = node.parentElement;
        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);
        if (attributes.length) {
            const spanEl = document.createElement('span');
            for (const attribute of attributes) {
                spanEl.setAttribute(attribute.name, attribute.value);
            }
            if (spanEl.style.textAlign) {
                // This is a tradeoff. Ideally, the state of the html
                // after this function should be reachable by standard
                // edition means and a span with display block is not.
                // However, this is required in order to not break the
                // design of already existing snippets.
                spanEl.style.display = 'block';
            }
            spanEl.append(...node.childNodes);
            node.replaceWith(spanEl);
        } else {
            unwrapContents(node);
        }
        if (previous && isVisible(previous) && !isBlock(previous) && previous.nodeName !== 'BR') {
            const br = document.createElement('br');
            previous.after(br);
        }
        restoreCursor && restoreCursor(new Map([[node, parent]]));
        node = parent; // The node has been removed, update the reference.
    } else if (node.nodeName === 'LI' && !node.closest('ul, ol')) {
        // Transform <li> into <p> if they are not in a <ul> / <ol>.
        const paragraph = document.createElement('p');
        paragraph.replaceChildren(...node.childNodes);
        node.replaceWith(paragraph);
        node = paragraph; // The node has been removed, update the reference.
    } else if (
        ['UL', 'OL'].includes(node.nodeName) &&
        ['UL', 'OL'].includes(node.parentNode.nodeName)
    ) {
        const restoreCursor = shouldPreserveCursor(node, root) && preserveCursor(root.ownerDocument);
        const li = document.createElement('li');
        node.parentNode.insertBefore(li, node);
        li.appendChild(node);
        li.classList.add('oe-nested');
        node = li;
        restoreCursor && restoreCursor();
    } else if (isFontAwesome(node) && node.textContent !== '\u200B') {
        // Ensure a zero width space is present inside the FA element.
        node.textContent = '\u200B';
    } else if (isEditorTab(node)) {
        // Ensure the editor tabs align on a 40px grid.
        let tabPreviousSibling = node.previousSibling;
        while (isZWS(tabPreviousSibling)) {
            tabPreviousSibling = tabPreviousSibling.previousSibling;
        }
        if (isEditorTab(tabPreviousSibling)) {
            node.style.width = '40px';
        } else {
            const editable = closestElement(node, '.odoo-editor-editable');
            if (editable?.firstElementChild) {
                const nodeRect = node.getBoundingClientRect();
                const referenceRect = editable.firstElementChild.getBoundingClientRect();
                // Values from getBoundingClientRect() are all zeros during
                // Editor startup or saving. We cannot recalculate the tabs
                // width in thoses cases.
                if (nodeRect.width && referenceRect.width) {
                    const width = (nodeRect.left - referenceRect.left) % 40;
                    node.style.width = (40 - width) + 'px';
                }
            }
        }
    } else if (node.nodeName === 'A') {
        // Ensure links have ZWNBSPs so the selection can be set at their edges.
        padLinkWithZws(root, node);
    } else if (
        node.nodeType === Node.TEXT_NODE &&
        node.textContent.includes('\uFEFF') &&
        !closestElement(node, 'a') &&
        !(
            closestElement(root, '[contenteditable=true]') &&
            getTraversedNodes(closestElement(root, '[contenteditable=true]')).includes(node)
        )
    ) {
        const startsWithLegitZws = node.textContent.startsWith('\uFEFF') && node.previousSibling && node.previousSibling.nodeName === 'A';
        const endsWithLegitZws = node.textContent.endsWith('\uFEFF') && node.nextSibling && node.nextSibling.nodeName === 'A';
        let newText = node.textContent.replace(/\uFEFF/g, '');
        if (startsWithLegitZws) {
            newText = '\uFEFF' + newText;
        }
        if (endsWithLegitZws) {
            newText = newText + '\uFEFF';
        }
        if (newText !== node.textContent) {
            // We replace the text node with a new text node with the
            // update text rather than just changing the text content of
            // the node because these two methods create different
            // mutations and at least the tour system breaks if all we
            // send here is a text content change.
            let replacement;
            if (newText.length) {
                replacement = document.createTextNode(newText);
                node.before(replacement);
            } else {
                replacement = node.parentElement;
            }
            node.remove();
            node = replacement; // The node has been removed, update the reference.
        }
    }
    return node;
}

/**
 * Sanitize a node tree and return the sanitized node.
 *
 * @param {Node} nodeToSanitize the node to sanitize
 * @param {Node} [root] the root of the tree to sanitize (will not sanitize nodes outside of this tree)
 * @returns {Node} the sanitized node
 */
__exports.sanitize = sanitize; function sanitize(nodeToSanitize, root = nodeToSanitize) {
    const start = nodeToSanitize.ownerDocument.getSelection()?.anchorNode;
    const block = closestBlock(nodeToSanitize);
    if (block && root.contains(block)) {
        // If the node is a list, start sanitization from its parent to ensure
        // adjacent lists are merged when needed.
        const isList = ['UL', 'OL'].includes(block.nodeName);
        let node = isList ? block.parentElement : block;

        // Sanitize the tree.
        while (node && !(root.isConnected && !node.isConnected) && root.contains(node)) {
            if (!isProtected(node)) {
                node = sanitizeNode(node, root); // The node itself might be replaced during sanitization.
            }
            node = node.firstChild || node.nextSibling || ancestors(node, root).find(a => a.nextSibling)?.nextSibling;
        }

        // Ensure unique ids on checklists and stars.
        const elementsWithId = [...block.querySelectorAll('[id^=checkId-]')];
        const maxId = Math.max(...[0, ...elementsWithId.map(node => +node.getAttribute('id').substring(8))]);
        let nextId = maxId + 1;
        const ids = [];
        for (const node of block.querySelectorAll('[id^=checkId-], .o_checklist > li, .o_stars')) {
            if (
                !node.classList.contains('o_stars') && (
                    !node.parentElement.classList.contains('o_checklist') ||
                    [...node.children].some(child => ['UL', 'OL'].includes(child.nodeName))
            )) {
                // Remove unique ids from checklists and stars from elements
                // that are no longer checklist items or stars, and from
                // parents of nested lists.
                node.removeAttribute('id')
            } else {
                // Add/change IDs where needed, and ensure they're unique.
                let id = node.getAttribute('id');
                if (!id || ids.includes(id)) {
                    id = `checkId-${nextId}`;
                    nextId++;
                    node.setAttribute('id', id);
                }
                ids.push(id);
            }
        }

        // Update link URL if label is a new valid link.
        const startEl = start && closestElement(start, 'a');
        if (startEl && root.contains(startEl)) {
            const label = startEl.innerText;
            const url = deduceURLfromText(label, startEl);
            if (url) {
                startEl.setAttribute('href', url);
            }
        }
    }
    return nodeToSanitize;
}

return __exports;
});
;

/**********************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/utils/serialize.js  *
*  Lines: 89                                                                      *
**********************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/utils/serialize', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
// TODO: avoid empty keys when not necessary to reduce request size
__exports.serializeNode = serializeNode; function serializeNode(node, nodesToStripFromChildren = new Set()) {
    if (!node.oid) {
        return;
    }
    const result = {
        nodeType: node.nodeType,
        oid: node.oid,
    };
    if (node.nodeType === Node.TEXT_NODE) {
        result.textValue = node.nodeValue;
    } else if (node.nodeType === Node.ELEMENT_NODE) {
        result.tagName = node.tagName;
        result.children = [];
        result.attributes = {};
        for (let i = 0; i < node.attributes.length; i++) {
            result.attributes[node.attributes[i].name] = node.attributes[i].value;
        }
        let child = node.firstChild;
        // Don't serialize transient nodes
        if (!["true", ""].includes(node.dataset.oeTransientContent)) {
            while (child) {
                if (!nodesToStripFromChildren.has(child.oid)) {
                    const serializedChild = serializeNode(child, nodesToStripFromChildren);
                    if (serializedChild) {
                        result.children.push(serializedChild);
                    }
                }
                child = child.nextSibling;
            }
        }
    }
    return result;
}

__exports.unserializeNode = unserializeNode; function unserializeNode(obj) {
    if (!obj) {
        return;
    }
    let result = undefined;
    if (obj.nodeType === Node.TEXT_NODE) {
        result = document.createTextNode(obj.textValue);
    } else if (obj.nodeType === Node.ELEMENT_NODE) {
        result = document.createElement(obj.tagName);
        for (const key in obj.attributes) {
            result.setAttribute(key, obj.attributes[key]);
        }
        obj.children.forEach(child => result.append(unserializeNode(child)));
    } else {
        console.warn('unknown node type');
    }
    if (result) {
        result.oid = obj.oid;
        return result;
    }
}

__exports.serializeSelection = serializeSelection; function serializeSelection(selection) {
    if (
        selection &&
        selection.anchorNode &&
        selection.anchorNode.oid &&
        typeof selection.anchorOffset !==  'undefined' &&
        selection.focusNode &&
        selection.anchorNode.oid &&
        typeof selection.focusOffset !==  'undefined'
    ) {
        return {
            anchorNodeOid: selection.anchorNode.oid,
            anchorOffset: selection.anchorOffset,
            focusNodeOid: selection.focusNode.oid,
            focusOffset: selection.focusOffset,
        };
    } else {
        return {
            anchorNodeOid: undefined,
            anchorOffset: undefined,
            focusNodeOid: undefined,
            focusOffset: undefined,
        };
    }
}

return __exports;
});
;

/******************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/tablepicker/TablePicker.js  *
*  Lines: 167                                                                             *
******************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/tablepicker/TablePicker', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { getRangePosition } = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

const TablePicker = __exports.TablePicker = class TablePicker extends EventTarget {
    constructor(options = {}) {
        super();
        this.options = options;
        this.options.minRowCount = this.options.minRowCount || 3;
        this.options.minColCount = this.options.minColCount || 3;
        this.options.getContextFromParentRect = this.options.getContextFromParentRect || (() => ({ top: 0, left: 0 }));

        this.rowNumber = this.options.minRowCount;
        this.colNumber = this.options.minColCount;

        this.tablePickerWrapper = document.createElement('div');
        this.tablePickerWrapper.classList.add('oe-tablepicker-wrapper');
        this.tablePickerWrapper.innerHTML = `
            <div class="oe-tablepicker"></div>
            <div class="oe-tablepicker-size"></div>
        `;

        if (this.options.floating) {
            this.tablePickerWrapper.style.position = 'absolute';
            this.tablePickerWrapper.classList.add('oe-floating');
        }

        this.tablePickerElement = this.tablePickerWrapper.querySelector('.oe-tablepicker');
        this.tablePickerSizeViewElement =
            this.tablePickerWrapper.querySelector('.oe-tablepicker-size');

        this.el = this.tablePickerWrapper;

        this.hide();
    }

    render() {
        this.tablePickerElement.innerHTML = '';

        const colCount = Math.max(this.colNumber, this.options.minRowCount);
        const rowCount = Math.max(this.rowNumber, this.options.minRowCount);
        const extraCol = 1;
        const extraRow = 1;

        for (let rowNumber = 1; rowNumber <= rowCount + extraRow; rowNumber++) {
            const rowElement = document.createElement('div');
            rowElement.classList.add('oe-tablepicker-row');
            this.tablePickerElement.appendChild(rowElement);
            for (let colNumber = 1; colNumber <= colCount + extraCol; colNumber++) {
                const cell = this.el.ownerDocument.createElement('div');
                cell.classList.add('oe-tablepicker-cell', 'btn');
                rowElement.appendChild(cell);

                if (rowNumber <= this.rowNumber && colNumber <= this.colNumber) {
                    cell.classList.add('active');
                }

                const bindMouseMove = () => {
                    cell.addEventListener('mouseover', () => {
                        if (this.colNumber !== colNumber || this.rowNumber != rowNumber) {
                            this.colNumber = colNumber;
                            this.rowNumber = rowNumber;
                            this.render();
                        }
                    });
                    this.el.ownerDocument.removeEventListener('mousemove', bindMouseMove);
                };
                this.el.ownerDocument.addEventListener('mousemove', bindMouseMove);
                cell.addEventListener('mousedown', this.selectCell.bind(this));
            }
        }

        this.tablePickerSizeViewElement.textContent = `${this.colNumber}x${this.rowNumber}`;
    }

    show() {
        this.reset();
        this.el.style.display = 'block';
        if (this.options.floating) {
            this._showFloating();
        }
    }

    hide() {
        this.el.style.display = 'none';
    }

    reset() {
        this.rowNumber = this.options.minRowCount;
        this.colNumber = this.options.minColCount;
        this.render();
    }

    selectCell() {
        this.dispatchEvent(
            new CustomEvent('cell-selected', {
                detail: { colNumber: this.colNumber, rowNumber: this.rowNumber },
            }),
        );
    }

    _showFloating() {
        const isRtl = this.options.direction === 'rtl';
        const keydown = e => {
            const actions = {
                ArrowRight: {
                    colNumber: (this.colNumber + (isRtl ? -1 : 1)) || 1,
                    rowNumber: this.rowNumber,
                },
                ArrowLeft: {
                    colNumber: (this.colNumber + (isRtl ? 1 : -1)) || 1,
                    rowNumber: this.rowNumber,
                },
                ArrowUp: {
                    colNumber: this.colNumber,
                    rowNumber: this.rowNumber - 1 || 1,
                },
                ArrowDown: {
                    colNumber: this.colNumber,
                    rowNumber: this.rowNumber + 1,
                },
            };
            const action = actions[e.key];
            if (action) {
                this.rowNumber = action.rowNumber || this.rowNumber;
                this.colNumber = action.colNumber || this.colNumber;
                this.render();

                e.preventDefault();
            } else if (e.key === 'Enter') {
                this.selectCell();
                e.preventDefault();
            } else if (e.key === 'Escape') {
                stop();
                e.preventDefault();
            }
        };

        const offset = getRangePosition(this.el, this.options.document, this.options);
        if (isRtl) {
            this.el.style.right = `${offset.right}px`;
        } else {
            this.el.style.left = `${offset.left}px`;
        }

        this.el.style.top = `${offset.top}px`;

        const stop = () => {
            this.hide();
            this.options.document.removeEventListener('mousedown', stop);
            this.removeEventListener('cell-selected', stop);
            this.options.document.removeEventListener('keydown', keydown, true);
        };

        // Allow the mousedown that activate this command callback to release before adding the listener.
        setTimeout(() => {
            this.options.document.addEventListener('mousedown', stop);
        });
        this.options.document.addEventListener('keydown', keydown, true);
        this.addEventListener('cell-selected', stop);
    }
}

return __exports;
});
;

/****************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/powerbox/patienceDiff.js  *
*  Lines: 269                                                                           *
****************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/powerbox/patienceDiff', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
/**
 * program: "patienceDiff" algorithm implemented in javascript.
 * author: Jonathan Trent
 * version: 2.0
 *
 * use:  patienceDiff( aLines[], bLines[], diffPlusFlag)
 *
 * where:
 *      aLines[] contains the original text lines.
 *      bLines[] contains the new text lines.
 *      diffPlusFlag if true, returns additional arrays with the subset of lines that were
 *          either deleted or inserted.  These additional arrays are used by patienceDiffPlus.
 *
 * returns an object with the following properties:
 *      lines[] with properties of:
 *          line containing the line of text from aLines or bLines.
 *          aIndex referencing the index in aLine[].
 *          bIndex referencing the index in bLines[].
 *              (Note:  The line is text from either aLines or bLines, with aIndex and bIndex
 *               referencing the original index. If aIndex === -1 then the line is new from bLines,
 *               and if bIndex === -1 then the line is old from aLines.)
 *          moved is true if the line was moved from elsewhere in aLines[] or bLines[].
 *      lineCountDeleted is the number of lines from aLines[] not appearing in bLines[].
 *      lineCountInserted is the number of lines from bLines[] not appearing in aLines[].
 *      lineCountMoved is the number of lines moved outside of the Longest Common Subsequence.
 *
 */

__exports.patienceDiff = patienceDiff; function patienceDiff(aLines, bLines, diffPlusFlag) {
    //
    // findUnique finds all unique values in arr[lo..hi], inclusive.  This
    // function is used in preparation for determining the longest common
    // subsequence.  Specifically, it first reduces the array range in question
    // to unique values.
    //
    // Returns an ordered Map, with the arr[i] value as the Map key and the
    // array index i as the Map value.
    //
    function findUnique(arr, lo, hi) {
        var lineMap = new Map();

        for (let i = lo; i <= hi; i++) {
            let line = arr[i];
            if (lineMap.has(line)) {
                lineMap.get(line).count++;
                lineMap.get(line).index = i;
            } else {
                lineMap.set(line, { count: 1, index: i });
            }
        }

        lineMap.forEach((val, key, map) => {
            if (val.count !== 1) {
                map.delete(key);
            } else {
                map.set(key, val.index);
            }
        });

        return lineMap;
    }

    //
    // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]
    // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare
    // down the aArray and bArray ranges first, before then walking the comparison
    // between the two arrays.
    //
    // Returns an ordered Map, with the Map key as the common line between aArray
    // and bArray, with the Map value as an object containing the array indexes of
    // the matching unique lines.
    //
    function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {
        let ma = findUnique(aArray, aLo, aHi);
        let mb = findUnique(bArray, bLo, bHi);

        ma.forEach((val, key, map) => {
            if (mb.has(key)) {
                map.set(key, { indexA: val, indexB: mb.get(key) });
            } else {
                map.delete(key);
            }
        });

        return ma;
    }

    //
    // longestCommonSubsequence takes an ordered Map from the function uniqueCommon
    // and determines the Longest Common Subsequence (LCS).
    //
    // Returns an ordered array of objects containing the array indexes of the
    // matching lines for a LCS.
    //
    function longestCommonSubsequence(abMap) {
        var ja = [];

        // First, walk the list creating the jagged array.
        abMap.forEach((val, key, map) => {
            let i = 0;
            while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {
                i++;
            }

            if (!ja[i]) {
                ja[i] = [];
            }

            if (0 < i) {
                val.prev = ja[i - 1][ja[i - 1].length - 1];
            }

            ja[i].push(val);
        });

        // Now, pull out the longest common subsequence.
        var lcs = [];
        if (0 < ja.length) {
            let n = ja.length - 1;
            var lcs = [ja[n][ja[n].length - 1]];
            while (lcs[lcs.length - 1].prev) {
                lcs.push(lcs[lcs.length - 1].prev);
            }
        }

        return lcs.reverse();
    }

    // "result" is the array used to accumulate the aLines that are deleted, the
    // lines that are shared between aLines and bLines, and the bLines that were
    // inserted.
    let result = [];
    let deleted = 0;
    let inserted = 0;

    // aMove and bMove will contain the lines that don't match, and will be returned
    // for possible searching of lines that moved.

    let aMove = [];
    let aMoveIndex = [];
    let bMove = [];
    let bMoveIndex = [];

    //
    // addToResult simply pushes the latest value onto the "result" array.  This
    // array captures the diff of the line, aIndex, and bIndex from the aLines
    // and bLines array.
    //
    function addToResult(aIndex, bIndex) {
        if (bIndex < 0) {
            aMove.push(aLines[aIndex]);
            aMoveIndex.push(result.length);
            deleted++;
        } else if (aIndex < 0) {
            bMove.push(bLines[bIndex]);
            bMoveIndex.push(result.length);
            inserted++;
        }

        result.push({
            line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],
            aIndex: aIndex,
            bIndex: bIndex,
        });
    }

    //
    // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,
    // this function might recursively call recurseLCS to further match the lines
    // between aLines and bLines.
    //
    function addSubMatch(aLo, aHi, bLo, bHi) {
        // Match any lines at the beginning of aLines and bLines.
        while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {
            addToResult(aLo++, bLo++);
        }

        // Match any lines at the end of aLines and bLines, but don't place them
        // in the "result" array just yet, as the lines between these matches at
        // the beginning and the end need to be analyzed first.
        let aHiTemp = aHi;
        while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {
            aHi--;
            bHi--;
        }

        // Now, check to determine with the remaining lines in the subsequence
        // whether there are any unique common lines between aLines and bLines.
        //
        // If not, add the subsequence to the result (all aLines having been
        // deleted, and all bLines having been inserted).
        //
        // If there are unique common lines between aLines and bLines, then let's
        // recursively perform the patience diff on the subsequence.
        let uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);
        if (uniqueCommonMap.size === 0) {
            while (aLo <= aHi) {
                addToResult(aLo++, -1);
            }
            while (bLo <= bHi) {
                addToResult(-1, bLo++);
            }
        } else {
            recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);
        }

        // Finally, let's add the matches at the end to the result.
        while (aHi < aHiTemp) {
            addToResult(++aHi, ++bHi);
        }
    }

    //
    // recurseLCS finds the longest common subsequence (LCS) between the arrays
    // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence
    // recursively performs another LCS search (via addSubMatch), until there are
    // none found, at which point the subsequence is dumped to the result.
    //
    function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {
        var x = longestCommonSubsequence(
            uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi),
        );
        if (x.length === 0) {
            addSubMatch(aLo, aHi, bLo, bHi);
        } else {
            if (aLo < x[0].indexA || bLo < x[0].indexB) {
                addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);
            }

            let i;
            for (i = 0; i < x.length - 1; i++) {
                addSubMatch(x[i].indexA, x[i + 1].indexA - 1, x[i].indexB, x[i + 1].indexB - 1);
            }

            if (x[i].indexA <= aHi || x[i].indexB <= bHi) {
                addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);
            }
        }
    }

    recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);

    if (diffPlusFlag) {
        return {
            lines: result,
            lineCountDeleted: deleted,
            lineCountInserted: inserted,
            lineCountMoved: 0,
            aMove: aMove,
            aMoveIndex: aMoveIndex,
            bMove: bMove,
            bMoveIndex: bMoveIndex,
        };
    }

    return {
        lines: result,
        lineCountDeleted: deleted,
        lineCountInserted: inserted,
        lineCountMoved: 0,
    };
}

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/powerbox/Powerbox.js  *
*  Lines: 407                                                                       *
************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/powerbox/Powerbox', ['@web_editor/js/editor/odoo-editor/src/powerbox/patienceDiff', '@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { patienceDiff } = require("@web_editor/js/editor/odoo-editor/src/powerbox/patienceDiff");
const { closestBlock, getRangePosition } = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

const REGEX_RESERVED_CHARS = /[\\^$.*+?()[\]{}|]/g;
/**
 * Make `num` cycle from 0 to `max`.
 */
function cycle(num, max) {
    const y = max + 1;
    return ((num % y) + y) % y;
}

/**
 * interface PowerboxCommand {
 *     category: string;
 *     name: string;
 *     priority: number;
 *     description: string;
 *     fontawesome: string; // a fontawesome class name
 *     callback: () => void; // to execute when the command is picked
 *     isDisabled?: () => boolean; // return true to disable the command
 * }
 */

const Powerbox = __exports.Powerbox = class Powerbox {
    constructor({
        categories, commands, commandFilters, editable, getContextFromParentRect,
        onShow, onStop, beforeCommand, afterCommand
    } = {}) {
        this.categories = categories;
        this.commands = commands;
        this.commandFilters = commandFilters || [];
        this.editable = editable;
        this.getContextFromParentRect = getContextFromParentRect;
        this.onShow = onShow;
        this.onStop = onStop;
        this.beforeCommand = beforeCommand;
        this.afterCommand = afterCommand;
        this.isOpen = false;
        this.document = editable.ownerDocument;

        // Draw the powerbox.
        this.el = document.createElement('div');
        this.el.className = 'oe-powerbox-wrapper position-absolute overflow-hidden';
        this.el.style.display = 'none';
        document.body.append(this.el);
        this._mainWrapperElement = document.createElement('div');
        this._mainWrapperElement.className = 'oe-powerbox-mainWrapper flex-skrink-1 overflow-auto py-2';
        this.el.append(this._mainWrapperElement);
        this.el.addEventListener('mousedown', ev => ev.stopPropagation());

        // Set up events for later binding.
        this._boundOnKeyup = this._onKeyup.bind(this);
        this._boundOnKeydown = this._onKeydown.bind(this);
        this._boundClose = this.close.bind(this);
        this._events = [
            [this.document, 'keyup', this._boundOnKeyup],
            [this.document, 'keydown', this._boundOnKeydown, true],
            [this.document, 'mousedown', this._boundClose],
        ]
        // If the global document is different from the provided
        // options.document, which happens when the editor is inside an iframe,
        // we need to listen to the mouse event on both documents to be sure the
        // Powerbox will always close when clicking outside of it.
        if (document !== this.document) {
            this._events.push(
                [document, 'mousedown', this._boundClose],
            );
        }

    }
    destroy() {
        if (this.isOpen) {
            this.close();
        }
        this.el.remove();
    }

    // -------------------------------------------------------------------------
    // Public
    // -------------------------------------------------------------------------

    /**
     * Open the Powerbox with the given commands or with all instance commands.
     *
     * @param {PowerboxCommand[]} [commands=this.commands]
     * @param {Array<{name: string, priority: number}} [categories=this.categories]
     */
    open(commands=this.commands, categories=this.categories) {
        commands = (commands || []).map(command => ({
            ...command,
            category: command.category || '',
            name: command.name || '',
            priority: command.priority || 0,
            description: command.description || '',
            callback: command.callback || (() => {}),
        }));
        categories = (categories || []).map(category => ({
            name: category.name || '',
            priority: category.priority || 0,
        }));
        const order = (a, b) => b.priority - a.priority || a.name.localeCompare(b.name);
        // Remove duplicate category names, keeping only last declared version,
        // and order them.
        categories = [...categories].reverse().filter((category, index, cats) => (
            cats.findIndex(cat => cat.name === category.name) === index
        )).sort(order);

        // Apply optional filters to disable commands, then order them.
        for (let filter of this.commandFilters) {
            commands = filter(commands);
        }
        commands = commands.filter(command => !command.isDisabled || !command.isDisabled()).sort(order);
        commands = this._groupCommands(commands, categories).flatMap(group => group[1]);

        const selection = this.document.getSelection();
        const currentBlock = (selection && closestBlock(selection.anchorNode)) || this.editable;
        this._context = {
            commands, categories, filteredCommands: commands, selectedCommand: undefined,
            initialTarget: currentBlock, initialValue: currentBlock.textContent,
            lastText: undefined,
        }
        this.isOpen = true;
        this._render(this._context.commands, this._context.categories);
        this._bindEvents();
        this.show();
    }
    /**
     * Close the Powerbox without destroying it. Unbind events, reset context
     * and call the optional `onStop` hook.
     */
    close() {
        this.isOpen = false;
        this.hide();
        this._context = undefined;
        this._unbindEvents();
        this.onStop && this.onStop();
    };
    /**
     * Show the Powerbox and position it. Call the optional `onShow` hook.
     */
    show() {
        this.onShow && this.onShow();
        this.el.style.display = 'flex';
        this._resetPosition();
    }
    /**
     * Hide the Powerbox. If the Powerbox is active, close it.
     *
     * @see close
     */
    hide() {
        this.el.style.display = 'none';
        if (this.isOpen) {
            this.close();
        }
    }

    // -------------------------------------------------------------------------
    // Private
    // -------------------------------------------------------------------------

    /**
     * Render the Powerbox with the given commands, grouped by `category`.
     *
     * @private
     * @param {PowerboxCommand[]} commands
     * @param {Array<{name: string, priority: number}} categories
     */
    _render(commands, categories) {
        const parser = new DOMParser();
        this._mainWrapperElement.innerHTML = '';
        this._hoverActive = false;
        this._mainWrapperElement.classList.toggle('oe-powerbox-noResult', commands.length === 0);
        this._context.selectedCommand = commands.find(command => command === this._context.selectedCommand) || commands[0];
        for (const [category, categoryCommands] of this._groupCommands(commands, categories)) {
            const categoryWrapperEl = parser.parseFromString(`
                <div class="oe-powerbox-categoryWrapper">
                    <div class="oe-powerbox-category mx-3 my-1 text-uppercase"></div>
                </div>`, 'text/html').body.firstChild;
            this._mainWrapperElement.append(categoryWrapperEl);
            categoryWrapperEl.firstElementChild.innerText = category;
            for (const command of categoryCommands) {
                const commandElWrapper = document.createElement('div');
                commandElWrapper.className = 'oe-powerbox-commandWrapper d-flex align-items-center px-3 py-2 cursor-pointer';
                commandElWrapper.classList.toggle('active', this._context.selectedCommand === command);
                commandElWrapper.replaceChildren(...parser.parseFromString(`
                    <div class="oe-powerbox-commandLeftCol border rounded">
                        <i class="oe-powerbox-commandImg d-flex align-items-center justify-content-center fa"></i>
                    </div>
                    <div class="oe-powerbox-commandRightCol ms-3">
                        <div class="oe-powerbox-commandName"></div>
                        <div class="oe-powerbox-commandDescription"></div>
                    </div>`, 'text/html').body.children);
                commandElWrapper.querySelector('.oe-powerbox-commandImg').classList.add(command.fontawesome);
                commandElWrapper.querySelector('.oe-powerbox-commandName').innerText = command.name;
                commandElWrapper.querySelector('.oe-powerbox-commandDescription').innerText = command.description;
                categoryWrapperEl.append(commandElWrapper);
                // Handle events on command (activate and pick).
                commandElWrapper.addEventListener('mousemove', () => {
                    this.el.querySelector('.oe-powerbox-commandWrapper.active').classList.remove('active');
                    this._context.selectedCommand = command;
                    commandElWrapper.classList.add('active');
                });
                commandElWrapper.addEventListener('click', ev => {
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                        this._pickCommand(command);
                    }, true,
                );
            }
        }
        // Hide category name if there is only a single one.
        if (this._mainWrapperElement.childElementCount === 1) {
            this._mainWrapperElement.querySelector('.oe-powerbox-category').style.display = 'none';
        }
        this._resetPosition();
    }
    /**
     * Handle the selection of a command: call the command's callback. Also call
     * the `beforeCommand` and `afterCommand` hooks if they exists.
     *
     * @private
     * @param {PowerboxCommand} [command=this._context.selectedCommand]
     */
    async _pickCommand(command=this._context.selectedCommand) {
        if (command) {
            if (this.beforeCommand) {
                await this.beforeCommand();
            }
            await command.callback();
            if (this.afterCommand) {
                await this.afterCommand();
            }
        }
        this.close();
    };
    /**
     * Takes a list of commands and returns an object whose keys are all
     * existing category names and whose values are each of these categories'
     * commands. Categories with no commands are removed.
     *
     * @private
     * @param {PowerboxCommand[]} commands
     * @param {Array<{name: string, priority: number}} categories
     * @returns {{Array<[string, PowerboxCommand[]]>}>}
     */
    _groupCommands(commands, categories) {
        const groups = [];
        for (const category of categories) {
            const categoryCommands = commands.filter(command => command.category === category.name);
            commands = commands.filter(command => command.category !== category.name);
            groups.push([category.name, categoryCommands]);
        }
        // If commands remain, it means they declared categories that didn't
        // exist. Add these categories alphabetically at the end of the list.
        const remainingCategories = [...new Set(commands.map(command => command.category))];
        for (const categoryName of remainingCategories.sort((a, b) => a.localeCompare(b))) {
            const categoryCommands = commands.filter(command => command.category === categoryName);
            groups.push([categoryName, categoryCommands]);
        }
        return groups.filter(group => group[1].length);
    }
    /**
     * Take an array of commands or categories and return a reordered copy of
     * it, based on their respective priorities.
     *
     * @param {PowerboxCommand[] | Array<{name: string, priority: number}} commandsOrCategories
     * @returns {PowerboxCommand[] | Array<{name: string, priority: number}}
     */
    _orderByPriority(commandsOrCategories) {
        return [...commandsOrCategories].sort((a, b) => b.priority - a.priority || a.name.localeCompare(b.name));
    }
    /**
     * Recompute the Powerbox's position base on the selection in the document.
     *
     * @private
     */
    _resetPosition() {
        let options = {};
        if (this.getContextFromParentRect) {
            options['parentContextRect'] = this.getContextFromParentRect();
        }
        const position = getRangePosition(this.el, this.document, options);
        if (position) {
            let { left, top } = position;
            this.el.style.left = `${left}px`;
            this.el.style.top = `${top}px`;
        } else {
            this.hide();
        }
    }
    /**
     * Add all events to their given target, based on @see _events.
     *
     * @private
     */
    _bindEvents() {
        for (const [target, eventName, callback, option] of this._events) {
            target.addEventListener(eventName, callback, option);
        }
    }
    /**
     * Remove all events from their given target, based on @see _events.
     *
     * @private
     */
    _unbindEvents() {
        for (const [target, eventName, callback, option] of this._events) {
            target.removeEventListener(eventName, callback, option);
        }
    }

    // -------------------------------------------------------------------------
    // Handlers
    // -------------------------------------------------------------------------

    /**
     * Handle keyup events to filter commands based on what was typed, and
     * prevent changing selection when using the arrow keys.
     *
     * @private
     * @param {KeyboardEvent} ev
     */
    _onKeyup(ev) {
        if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
            ev.preventDefault();
        } else {
            const diff = patienceDiff(
                this._context.initialValue.split(''),
                this._context.initialTarget.textContent.split(''),
                true,
            );
            this._context.lastText = diff.bMove.join('').replaceAll('\ufeff', '');
            const selection = this.document.getSelection();
            if (
                this._context.lastText.match(/\s/) ||
                !selection ||
                this._context.initialTarget !== closestBlock(selection.anchorNode)
            ) {
                this.close();
            } else {
                const term = this._context.lastText.toLowerCase()
                    .replaceAll(/\s/g, '\\s')
                    .replaceAll('\u200B', '')
                    .replace(REGEX_RESERVED_CHARS, '\\$&');
                if (term.length) {
                    const exactRegex = new RegExp(term, 'i');
                    const fuzzyRegex = new RegExp(term.match(/\\.|./g).join('.*'), 'i');
                    this._context.filteredCommands = this._context.commands.filter(command => {
                        const commandText = (command.category + ' ' + command.name);
                        const commandDescription = command.description.replace(/\s/g, '');
                        return commandText.match(fuzzyRegex) || commandDescription.match(exactRegex);
                    });
                } else {
                    this._context.filteredCommands = this._context.commands;
                }
                this._render(this._context.filteredCommands, this._context.categories);
            }
        }
    }
    /**
     * Handle keydown events to add keyboard interactions with the Powerbox.
     *
     * @private
     * @param {KeyboardEvent} ev
     */
    _onKeydown(ev) {
        if (ev.key === 'Enter') {
            ev.stopImmediatePropagation();
            this._pickCommand();
            ev.preventDefault();
        } else if (ev.key === 'Escape') {
            ev.stopImmediatePropagation();
            this.close();
            ev.preventDefault();
        } else if (ev.key === 'Backspace' && !this._context.lastText) {
            this.close();
        } else if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
            ev.preventDefault();
            ev.stopImmediatePropagation();

            const commandIndex = this._context.filteredCommands.findIndex(
                command => command === this._context.selectedCommand,
            );
            if (this._context.filteredCommands.length && commandIndex !== -1) {
                const nextIndex = commandIndex + (ev.key === 'ArrowDown' ? 1 : -1);
                const newIndex = cycle(nextIndex, this._context.filteredCommands.length - 1);
                this._context.selectedCommand = this._context.filteredCommands[newIndex];
            } else {
                this._context.selectedCommand = undefined;
            }
            this._render(this._context.filteredCommands, this._context.categories);
            const activeCommand = this.el.querySelector('.oe-powerbox-commandWrapper.active');
            if (activeCommand) {
                activeCommand.scrollIntoView({block: 'nearest', inline: 'nearest'});
            }
        }
    }
}

return __exports;
});
;

/*********************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/align.js  *
*  Lines: 28                                                                     *
*********************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/align', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { childNodeIndex, isBlock } = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oAlign = function (offset, mode) {
    this.parentElement.oAlign(childNodeIndex(this), mode);
};
/**
 * This does not check for command state
 * @param {*} offset
 * @param {*} mode 'left', 'right', 'center' or 'justify'
 */
HTMLElement.prototype.oAlign = function (offset, mode) {
    if (!isBlock(this)) {
        return this.parentElement.oAlign(childNodeIndex(this), mode);
    }
    const { textAlign } = getComputedStyle(this);
    const alreadyAlignedLeft = textAlign === 'start' || textAlign === 'left';
    const shouldApplyStyle = !(alreadyAlignedLeft && mode === 'left');
    if (shouldApplyStyle) {
        this.style.textAlign = mode;
    }
};

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/commands.js  *
*  Lines: 1101                                                                      *
************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/commands', ['@web_editor/js/editor/odoo-editor/src/utils/constants', '@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { REGEX_BOOTSTRAP_COLUMN } = require("@web_editor/js/editor/odoo-editor/src/utils/constants");
const {
    ancestors,
    descendants,
    childNodeIndex,
    closestBlock,
    closestElement,
    closestPath,
    DIRECTIONS,
    findNode,
    getCursors,
    getDeepRange,
    getInSelection,
    getListMode,
    getSelectedNodes,
    getTraversedNodes,
    insertAndSelectZws,
    insertText,
    isBlock,
    isColorGradient,
    isSelectionFormat,
    isShrunkBlock,
    isSelfClosingElement,
    leftLeafFirstPath,
    preserveCursor,
    rightPos,
    setSelection,
    setCursorStart,
    setTagName,
    splitAroundUntil,
    splitElement,
    splitTextNode,
    startPos,
    nodeSize,
    allowsParagraphRelatedElements,
    isUnbreakable,
    makeContentsInline,
    unwrapContents,
    getColumnIndex,
    pxToFloat,
    getRowIndex,
    parseHTML,
    formatSelection,
    getDeepestPosition,
    fillEmpty,
    isEmptyBlock,
    isWhitespace,
    isVisibleTextNode,
    getCursorDirection,
    resetOuids,
    FONT_SIZE_CLASSES,
    TEXT_STYLE_CLASSES,
    padLinkWithZws,
    isLinkEligibleForZwnbsp,
    paragraphRelatedElements,
    lastLeaf,
    firstLeaf,
    convertList,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

const TEXT_CLASSES_REGEX = /\btext-[^\s]*\b/;
const BG_CLASSES_REGEX = /\bbg-[^\s]*\b/;

function align(editor, mode) {
    const sel = editor.document.getSelection();
    const visitedBlocks = new Set();
    const traversedNode = getTraversedNodes(editor.editable);
    for (const node of traversedNode) {
        if (isVisibleTextNode(node)) {
            const block = closestBlock(node);
            if (!visitedBlocks.has(block)) {
                const hasModifier = getComputedStyle(block).textAlign === mode;
                if (!hasModifier && block.isContentEditable) {
                    block.oAlign(sel.anchorOffset, mode);
                }
                visitedBlocks.add(block);
            }
        }
    }
}

/**
 * Applies a css or class color (fore- or background-) to an element.
 * Replace the color that was already there if any.
 *
 * @param {Element} element
 * @param {string} color hexadecimal or bg-name/text-name class
 * @param {string} mode 'color' or 'backgroundColor'
 */
function colorElement(element, color, mode) {
    const newClassName = element.className
        .replace(mode === 'color' ? TEXT_CLASSES_REGEX : BG_CLASSES_REGEX, '')
        .replace(/\btext-gradient\b/g, '') // cannot be combined with setting a background
        .replace(/\s+/, ' ');
    element.className !== newClassName && (element.className = newClassName);
    element.style['background-image'] = '';
    if (mode === 'backgroundColor') {
        element.style['background'] = '';
    }
    if (color.startsWith('text') || color.startsWith('bg-')) {
        element.style[mode] = '';
        element.classList.add(color);
    } else if (isColorGradient(color)) {
        element.style[mode] = '';
        if (mode === 'color') {
            element.style['background'] = '';
            element.style['background-image'] = color;
            element.classList.add('text-gradient');
        } else {
            element.style['background-image'] = color;
        }
    } else {
        element.style[mode] = color;
    }
}

/**
 * Returns true if the given element has a visible color (fore- or
 * -background depending on the given mode).
 *
 * @param {Element} element
 * @param {string} mode 'color' or 'backgroundColor'
 * @returns {boolean}
 */
function hasColor(element, mode) {
    const style = element.style;
    const parent = element.parentNode;
    const classRegex = mode === 'color' ? TEXT_CLASSES_REGEX : BG_CLASSES_REGEX;
    if (isColorGradient(style['background-image'])) {
        if (element.classList.contains('text-gradient')) {
            if (mode === 'color') {
                return true;
            }
        } else {
            if (mode !== 'color') {
                return true;
            }
        }
    }
    return (
        (style[mode] && style[mode] !== 'inherit' && (!parent || style[mode] !== parent.style[mode])) ||
        (classRegex.test(element.className) &&
            (!parent || getComputedStyle(element)[mode] !== getComputedStyle(parent)[mode]))
    );
}

// This is a whitelist of the commands that are implemented by the
// editor itself rather than the node prototypes. It might be
// possible to switch the conditions and test if the method exist on
// `sel.anchorNode` rather than relying on an expicit whitelist, but
// the behavior would change if a method name exists both on the
// editor and on the nodes. This is too risky to change in the
// absence of a strong test suite, so the whitelist stays for now.
const editorCommands = __exports.editorCommands = {
    insert: (editor, content) => {
        if (!content) return;
        const selection = editor.document.getSelection();
        let startNode;
        let insertBefore = false;
        if (!selection.isCollapsed) {
            editor.deleteRange(selection);
        }
        const range = selection.getRangeAt(0);
        const block = closestBlock(selection.anchorNode);
        const isSelectionAtStart = firstLeaf(block) === selection.anchorNode && selection.anchorOffset === 0;
        const isSelectionAtEnd = lastLeaf(block) === selection.focusNode && selection.focusOffset === nodeSize(selection.focusNode);
        if (range.startContainer.nodeType === Node.TEXT_NODE) {
            insertBefore = !range.startOffset;
            splitTextNode(range.startContainer, range.startOffset, DIRECTIONS.LEFT);
            startNode = range.startContainer;
        }

        const container = document.createElement('fake-element');
        const containerFirstChild = document.createElement('fake-element-fc');
        const containerLastChild = document.createElement('fake-element-lc');

        if (typeof content === 'string') {
            container.textContent = content;
        } else {
            container.replaceChildren(content);
        }

        // In case the html inserted starts with a list and will be inserted within
        // a list, unwrap the list elements from the list.
        const isList = node => ['UL', 'OL'].includes(node.nodeName);
        const hasSingleChild = container.childNodes.length === 1;
        if (
            closestElement(selection.anchorNode, 'UL, OL') &&
            isList(container.firstChild)
        ) {
            unwrapContents(container.firstChild);
        }
        // Similarly if the html inserted ends with a list.
        if (
            closestElement(selection.focusNode, 'UL, OL') &&
            isList(container.lastChild) &&
            !hasSingleChild
        ) {
            unwrapContents(container.lastChild);
        }

        startNode = startNode || editor.document.getSelection().anchorNode;
        const shouldUnwrap = (node) => (
            [...paragraphRelatedElements, 'LI'].includes(node.nodeName) &&
            block.textContent !== "" && node.textContent !== "" &&
            (
                block.nodeName === node.nodeName ||
                ['BLOCKQUOTE', 'PRE', 'DIV'].includes(block.nodeName)
            ) && selection.anchorNode.oid !== 'root'
        );

        // Empty block must contain a br element to allow cursor placement.
        if (
            container.lastElementChild &&
            isBlock(container.lastElementChild) &&
            !container.lastElementChild.hasChildNodes()
        ) {
            fillEmpty(container.lastElementChild);
        }

        // In case the html inserted is all contained in a single root <p> or <li>
        // tag, we take the all content of the <p> or <li> and avoid inserting the
        // <p> or <li>. The same is true for a <pre> inside a <pre>.
        if (
            container.childElementCount === 1 &&
            (
                ['P', 'LI'].includes(container.firstChild.nodeName) ||
                shouldUnwrap(container.firstChild)
            ) && selection.anchorNode.oid !== 'root'
        ) {
            const p = container.firstElementChild;
            container.replaceChildren(...p.childNodes);
        } else if (container.childElementCount > 1) {
            // Grab the content of the first child block and isolate it.
            if (shouldUnwrap(container.firstChild) && !isSelectionAtStart) {
                // Unwrap the deepest nested first <li> element in the
                // container to extract and paste the text content of the list.
                if (container.firstChild.nodeName === 'LI') {
                    const deepestBlock = closestBlock(firstLeaf(container.firstChild));
                    splitAroundUntil(deepestBlock, container.firstChild);
                    container.firstElementChild.replaceChildren(...deepestBlock.childNodes);
                }
                containerFirstChild.replaceChildren(...container.firstElementChild.childNodes);
                container.firstElementChild.remove();
            }
            // Grab the content of the last child block and isolate it.
            if (shouldUnwrap(container.lastChild) && !isSelectionAtEnd) {
                // Unwrap the deepest nested last <li> element in the container
                // to extract and paste the text content of the list.
                if (container.lastChild.nodeName === 'LI') {
                    const deepestBlock = closestBlock(lastLeaf(container.lastChild));
                    splitAroundUntil(deepestBlock, container.lastChild);
                    container.lastElementChild.replaceChildren(...deepestBlock.childNodes);
                }
                containerLastChild.replaceChildren(...container.lastElementChild.childNodes);
                container.lastElementChild.remove();
            }
        }

        if (startNode.nodeType === Node.ELEMENT_NODE) {
            if (selection.anchorOffset === 0) {
                const textNode = editor.document.createTextNode('');
                if (isSelfClosingElement(startNode)) {
                    startNode.parentNode.insertBefore(textNode, startNode);
                } else {
                    startNode.prepend(textNode);
                }
                startNode = textNode;
            } else {
                startNode = startNode.childNodes[selection.anchorOffset - 1];
            }
        }

        // If we have isolated block content, first we split the current focus
        // element if it's a block then we insert the content in the right places.
        let currentNode = startNode;
        let lastChildNode = false;
        const currentList = currentNode && closestElement(currentNode, 'UL, OL');
        const mode = currentList && getListMode(currentList);

        const _insertAt = (reference, nodes, insertBefore) => {
            for (const child of (insertBefore ? nodes.reverse() : nodes)) {
                reference[insertBefore ? 'before' : 'after'](child);
                reference = child;
            }
        }
        const lastInsertedNodes = [...containerLastChild.childNodes];
        if (containerLastChild.hasChildNodes()) {
            const toInsert = [...containerLastChild.childNodes]; // Prevent mutation
            _insertAt(currentNode, [...toInsert], insertBefore);
            currentNode = insertBefore ? toInsert[0] : currentNode;
            lastChildNode = toInsert[toInsert.length - 1];
        }
        const firstInsertedNodes = [...containerFirstChild.childNodes];
        if (containerFirstChild.hasChildNodes()) {
            const toInsert = [...containerFirstChild.childNodes]; // Prevent mutation
            _insertAt(currentNode, [...toInsert], insertBefore);
            currentNode = toInsert[toInsert.length - 1];
            insertBefore = false;
        }

        // If all the Html have been isolated, We force a split of the parent element
        // to have the need new line in the final result
        if (!container.hasChildNodes()) {
            if (isUnbreakable(closestBlock(currentNode.nextSibling))) {
                currentNode.nextSibling.oShiftEnter(0);
            } else {
                // If we arrive here, the o_enter index should always be 0.
                const parent = currentNode.nextSibling.parentElement;
                const index = [...parent.childNodes].indexOf(currentNode.nextSibling);
                parent.oEnter(index);
            }
        }

        let nodeToInsert;
        const insertedNodes = [...container.childNodes];
        while ((nodeToInsert = container.childNodes[0])) {
            if (isBlock(nodeToInsert) && !allowsParagraphRelatedElements(currentNode)) {
                // Split blocks at the edges if inserting new blocks (preventing
                // <p><p>text</p></p> or <li><li>text</li></li> scenarios).
                while (
                    currentNode.parentElement !== editor.editable &&
                    (!allowsParagraphRelatedElements(currentNode.parentElement) ||
                        (currentNode.parentElement.nodeName === 'LI' && nodeToInsert.nodeName !== 'TABLE'))
                ) {
                    if (isUnbreakable(currentNode.parentElement)) {
                        makeContentsInline(container);
                        nodeToInsert = container.childNodes[0];
                        break;
                    }
                    let offset = childNodeIndex(currentNode);
                    if (!insertBefore) {
                        offset += 1;
                    }
                    if (offset) {
                        const [left, right] = splitElement(currentNode.parentElement, offset);
                        if (isUnbreakable(nodeToInsert) && container.childNodes.length === 1) {
                            fillEmpty(right);
                        } else if (isEmptyBlock(right)) {
                            right.remove();
                        }
                        currentNode = insertBefore ? right : left;
                    } else {
                        currentNode = currentNode.parentElement;
                    }
                }
                if (currentNode.parentElement.nodeName === 'LI' && nodeToInsert.nodeName === 'TABLE') {
                    const br = document.createElement('br');
                    currentNode[currentNode.textContent ? 'after' : 'before'](br);
                }
            }
            // Ensure that all adjacent paragraph elements are converted to
            // <li> when inserting in a list.
            if (block.nodeName === "LI" && paragraphRelatedElements.includes(nodeToInsert.nodeName)) {
                setTagName(nodeToInsert, "LI");
            }
            // Contenteditable false property changes to true after the node is
            // inserted into DOM.
            const isNodeToInsertContentEditable = nodeToInsert.isContentEditable;
            if (insertBefore) {
                currentNode.before(nodeToInsert);
                insertBefore = false;
            } else {
                currentNode.after(nodeToInsert);
            }
            if (
                ['BLOCKQUOTE', 'PRE'].includes(block.nodeName) &&
                paragraphRelatedElements.includes(nodeToInsert.nodeName)
            ) {
                nodeToInsert = setTagName(nodeToInsert, block.nodeName);
            }
            let convertedList;
            if (
                currentList &&
                (
                    (nodeToInsert.nodeName === 'LI' && nodeToInsert.classList.contains('oe-nested')) ||
                    isList(nodeToInsert)
                )
            ) {
                convertedList = convertList(nodeToInsert, mode);
            }
            if (currentNode.tagName !== 'BR' && isShrunkBlock(currentNode)) {
                currentNode.remove();
            }
            // If the first child of editable is contenteditable false element
            // a chromium bug prevents selecting the container. Prepend a
            // zero-width space so it's no longer the first child.
            if (
                !isNodeToInsertContentEditable &&
                editor.editable.firstChild === nodeToInsert &&
                nodeToInsert.nodeName === 'DIV'
            ) {
                const zws = document.createTextNode('\u200B');
                nodeToInsert.before(zws);
            }
            currentNode = convertedList || nodeToInsert;
        }

        currentNode = lastChildNode || currentNode;
        if (
            !isUnbreakable(currentNode) &&
            currentNode.nodeName !== 'BR' &&
            currentNode.nextSibling &&
            currentNode.nextSibling.nodeName === 'BR' &&
            lastLeaf(currentNode.parentNode) === currentNode.nextSibling &&
            !closestElement(currentNode, '[t-field],[t-esc],[t-out]')
        ) {
            currentNode.nextSibling.remove();
        }
        selection.removeAllRanges();
        const newRange = new Range();
        let lastPosition;
        if (currentNode.nodeName === 'A' && isLinkEligibleForZwnbsp(editor.editable, currentNode)) {
            padLinkWithZws(editor.editable, currentNode);
            currentNode = currentNode.nextSibling;
            lastPosition = getDeepestPosition(...rightPos(currentNode));
        } else {
            lastPosition = [...paragraphRelatedElements, 'LI', 'UL', 'OL'].includes(currentNode.nodeName)
                ? rightPos(lastLeaf(currentNode))
                : rightPos(currentNode);
        }
        if (!editor.options.allowInlineAtRoot && lastPosition[0] === editor.editable) {
            // Correct the position if it happens to be in the editable root.
            lastPosition = getDeepestPosition(...lastPosition);
        }
        newRange.setStart(lastPosition[0], lastPosition[1]);
        newRange.setEnd(lastPosition[0], lastPosition[1]);
        selection.addRange(newRange);
        return [...firstInsertedNodes, ...insertedNodes, ...lastInsertedNodes];
    },
    insertFontAwesome: (editor, faClass = 'fa fa-star') => {
        const insertedNode = editorCommands.insert(editor, document.createElement('i'))[0];
        insertedNode.className = faClass;
        const position = rightPos(insertedNode);
        setSelection(...position, ...position, false);
    },

    // History
    undo: editor => editor.historyUndo(),
    redo: editor => editor.historyRedo(),

    // Change tags
    setTag(editor, tagName, extraClass = "") {
        const range = getDeepRange(editor.editable, { correctTripleClick: true });
        const selectedBlocks = [...new Set(getTraversedNodes(editor.editable, range).map(closestBlock))];
        const deepestSelectedBlocks = selectedBlocks.filter(block => (
            !descendants(block).some(descendant => selectedBlocks.includes(descendant)) &&
            block.isContentEditable
        ));
        let { startContainer, startOffset, endContainer, endOffset } = range;
        const startContainerChild = startContainer.firstChild;
        const endContainerChild = endContainer.lastChild;
        for (const block of deepestSelectedBlocks) {
            if (
                ['P', 'PRE', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI', 'BLOCKQUOTE'].includes(
                    block.nodeName,
                )
            ) {
                const inLI = block.closest('li');
                if (inLI && tagName === "P") {
                    inLI.oToggleList(0);
                } else {
                    const newEl = setTagName(block, tagName);
                    newEl.classList.remove(
                        ...FONT_SIZE_CLASSES,
                        ...TEXT_STYLE_CLASSES,
                        // We want to be able to edit the case `<h2 class="h3">`
                        // but in that case, we want to display "Header 2" and
                        // not "Header 3" as it is more important to display
                        // the semantic tag being used (especially for h1 ones).
                        // This is why those are not in `TEXT_STYLE_CLASSES`.
                        "h1", "h2", "h3", "h4", "h5", "h6"
                    );
                    delete newEl.style.fontSize;
                    if (extraClass) {
                        newEl.classList.add(extraClass);
                    }
                    if (newEl.classList.length === 0) {
                        newEl.removeAttribute("class");
                    }
                }
            } else {
                // eg do not change a <div> into a h1: insert the h1
                // into it instead.
                const newBlock = editor.document.createElement(tagName);
                const children = [...block.childNodes];
                block.insertBefore(newBlock, block.firstChild);
                children.forEach(child => newBlock.appendChild(child));
            }
        }
        const isContextBlock = container => ['TD', 'DIV', 'LI'].includes(container.nodeName);
        if (!startContainer.isConnected || isContextBlock(startContainer)) {
            startContainer = startContainerChild.parentNode;
        }
        if (!endContainer.isConnected || isContextBlock(endContainer)) {
            endContainer = endContainerChild.parentNode;
        }
        const newRange = new Range();
        newRange.setStart(startContainer, startOffset);
        newRange.setEnd(endContainer, endOffset);
        getDeepRange(editor.editable, { range: newRange, select: true });
        editor.historyStep();
    },

    // Formats
    // -------------------------------------------------------------------------
    bold: editor => formatSelection(editor, 'bold'),
    italic: editor => formatSelection(editor, 'italic'),
    underline: editor => formatSelection(editor, 'underline'),
    strikeThrough: editor => formatSelection(editor, 'strikeThrough'),
    setFontSize: (editor, size) => formatSelection(editor, 'fontSize', {applyStyle: true, formatProps: {size}}),
    setFontSizeClassName: (editor, className) => formatSelection(editor, 'setFontSizeClassName', {formatProps: {className}}),
    switchDirection: editor => {
        getDeepRange(editor.editable, { splitText: true, select: true, correctTripleClick: true });
        const selection = editor.document.getSelection();
        const selectedTextNodes = [selection.anchorNode, ...getSelectedNodes(editor.editable), selection.focusNode]
            .filter(n => n.nodeType === Node.TEXT_NODE && closestElement(n).isContentEditable && n.nodeValue.trim().length);

        const changedElements = [];
        const defaultDirection = editor.options.direction;
        const shouldApplyStyle = !isSelectionFormat(editor.editable, 'switchDirection');
        let blocks = new Set(selectedTextNodes.map(textNode => closestElement(textNode, 'ul,ol') || closestBlock(textNode)));
        blocks.forEach(block => {
            blocks = [...blocks, ...block.querySelectorAll('ul,ol')];
        })
        for (const block of blocks) {
            if (!shouldApplyStyle) {
                block.removeAttribute('dir');
            } else {
                block.setAttribute('dir', defaultDirection === 'ltr' ? 'rtl' : 'ltr');
            }
            changedElements.push(block);
        }

        for (const element of changedElements) {
            const style = getComputedStyle(element);
            if (style.direction === 'ltr' && style.textAlign === 'right') {
                element.style.setProperty('text-align', 'left');
            } else if (style.direction === 'rtl' && style.textAlign === 'left') {
                element.style.setProperty('text-align', 'right');
            }
        }
    },
    removeFormat: editor => {
        const textAlignStyles = new Map();
        getTraversedNodes(editor.editable).forEach((element) => {
            const block = closestBlock(element);
            if (block.style.textAlign) {
                textAlignStyles.set(block, block.style.textAlign);
            }
        });
        // Calling `document.execCommand` will cause an input event with the
        // input type "formatRemove". This would cause a new history step to be
        // created in the middle of the process, which we prevent here.
        editor.historyPauseSteps();
        editor.document.execCommand('removeFormat');
        for (const node of getTraversedNodes(editor.editable)) {
            if (node.nodeType === Node.ELEMENT_NODE && node.hasAttribute('color')) {
                node.removeAttribute('color');
            }
            const element = closestElement(node);
            element.style.removeProperty('color');
            element.style.removeProperty('background');
        }
        textAlignStyles.forEach((textAlign, block) => {
            block.style.setProperty('text-align', textAlign);
        });
        editor.historyUnpauseSteps();
    },

    // Align
    justifyLeft: editor => align(editor, 'left'),
    justifyRight: editor => align(editor, 'right'),
    justifyCenter: editor => align(editor, 'center'),
    justifyFull: editor => align(editor, 'justify'),

    // Link
    createLink: (editor, link, content) => {
        const sel = editor.document.getSelection();
        if (content && !sel.isCollapsed) {
            editor.deleteRange(sel);
        }
        if (sel.isCollapsed) {
            insertText(sel, content || 'link');
        }
        const currentLink = closestElement(sel.focusNode, 'a');
        link = link || prompt('URL or Email', (currentLink && currentLink.href) || 'http://');
        const res = editor.document.execCommand('createLink', false, link);
        if (res) {
            setSelection(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);
            const node = findNode(closestPath(sel.focusNode), node => node.tagName === 'A');
            for (const [param, value] of Object.entries(editor.options.defaultLinkAttributes)) {
                node.setAttribute(param, `${value}`);
            }
            const pos = [node.parentElement, childNodeIndex(node) + 1];
            setSelection(...pos, ...pos, false);
        }
    },
    unlink: editor => {
        const sel = editor.document.getSelection();
        const isCollapsed = sel.isCollapsed;
        // If the selection is collapsed, unlink the whole link:
        // `<a>a[]b</a>` => `a[]b`.
        getDeepRange(editor.editable, { sel, splitText: true, select: true });
        if (!isCollapsed) {
            // If not, unlink only the part(s) of the link(s) that are selected:
            // `<a>a[b</a>c<a>d</a>e<a>f]g</a>` => `<a>a</a>[bcdef]<a>g</a>`.
            let { anchorNode, focusNode, anchorOffset, focusOffset } = sel;
            const direction = getCursorDirection(anchorNode, anchorOffset, focusNode, focusOffset);
            // Split the links around the selection.
            const [startLink, endLink] = [closestElement(anchorNode, 'a'), closestElement(focusNode, 'a')];
            if (startLink) {
                anchorNode = splitAroundUntil(anchorNode, startLink);
                anchorOffset = direction === DIRECTIONS.RIGHT ? 0 : nodeSize(anchorNode);
                setSelection(anchorNode, anchorOffset, focusNode, focusOffset, true);
            }
            // Only split the end link if it was not already done above.
            if (endLink && endLink.isConnected) {
                focusNode = splitAroundUntil(focusNode, endLink);
                focusOffset = direction === DIRECTIONS.RIGHT ? nodeSize(focusNode) : 0;
                setSelection(anchorNode, anchorOffset, focusNode, focusOffset, true);
            }
        }
        const targetedNodes = isCollapsed ? [sel.anchorNode] : getSelectedNodes(editor.editable);
        const links = new Set(targetedNodes.map(node => closestElement(node, 'a')).filter(a => a && a.isContentEditable));
        if (links.size) {
            const cr = preserveCursor(editor.document);
            for (const link of links) {
                unwrapContents(link);
            }
            cr();
        }
    },

    // List
    indentList: (editor, mode = 'indent') => {
        const [pos1, pos2] = getCursors(editor.document);
        const end = leftLeafFirstPath(...pos1).next().value;
        const li = new Set();
        for (const node of leftLeafFirstPath(...pos2)) {
            const cli = closestElement(node,'li');
            if (
                cli &&
                cli.tagName == 'LI' &&
                !li.has(cli) &&
                !cli.classList.contains('oe-nested') &&
                cli.isContentEditable &&
                !cli.classList.contains('nav-item')
            ) {
                li.add(cli);
            }
            if (node == end) break;
        }
        for (const node of li) {
            if (mode == 'indent') {
                node.oTab(0);
            } else {
                node.oShiftTab(0);
            }
        }
        return true;
    },
    toggleList: (editor, mode) => {
        const li = new Set();
        const blocks = new Set();

        const selectedBlocks = getTraversedNodes(editor.editable);
        const deepestSelectedBlocks = selectedBlocks.filter(block => (
            !descendants(block).some(descendant => selectedBlocks.includes(descendant))
        ));
        for (const node of deepestSelectedBlocks) {
            if (node.nodeType === Node.TEXT_NODE && isWhitespace(node) && closestElement(node).isContentEditable) {
                node.remove();
            } else {
                // Ensure nav-item lists are excluded from toggling
                const isNavItemList = node => node.nodeName === 'LI' && node.classList.contains('nav-item');
                let nodeToToggle = closestBlock(node);
                nodeToToggle = isNavItemList(nodeToToggle) ? node : nodeToToggle;
                if (!['OL', 'UL'].includes(nodeToToggle.tagName) && (nodeToToggle.isContentEditable || nodeToToggle.nodeType === Node.TEXT_NODE)) {
                    const closestLi = closestElement(nodeToToggle, 'li');
                    nodeToToggle = closestLi && !isNavItemList(closestLi) ? closestLi : nodeToToggle;
                    const ublock = nodeToToggle.nodeName === 'LI' && nodeToToggle.closest('ol, ul');
                    ublock && getListMode(ublock) == mode ? li.add(nodeToToggle) : blocks.add(nodeToToggle);
                }
            }
        }

        let target = [...(blocks.size ? blocks : li)];
        if (blocks.size) {
            // Remove hardcoded padding to have default padding of list element 
            for (const block of blocks) {
                if (block.style) {
                    block.style.padding = "";
                }
            }
        }
        while (target.length) {
            const node = target.pop();
            // only apply one li per ul
            if (!node.oToggleList(0, mode)) {
                target = target.filter(
                    li => li.parentNode != node.parentNode || li.tagName != 'LI',
                );
            }
        }
    },

    /**
     * Apply a css or class color on the current selection (wrapped in <font>).
     *
     * @param {string} color hexadecimal or bg-name/text-name class
     * @param {string} mode 'color' or 'backgroundColor'
     * @param {Element} [element]
     */
    applyColor: (editor, color, mode, element) => {
        const selectedTds = [...editor.editable.querySelectorAll('td.o_selected_td')].filter(
            node => closestElement(node).isContentEditable
        );
        let coloredTds = [];
        if (selectedTds.length && mode === "backgroundColor") {
            for (const td of selectedTds) {
                colorElement(td, color, mode);
            }
            coloredTds = [...selectedTds];
        } else if (element) {
            colorElement(element, color, mode);
            return [element];
        }
        const selection = editor.document.getSelection();
        let wasCollapsed = false;
        if (selection.getRangeAt(0).collapsed && !selectedTds.length) {
            insertAndSelectZws(selection);
            wasCollapsed = true;
        }
        const range = getDeepRange(editor.editable, { splitText: true, select: true });
        if (!range) return;
        const restoreCursor = preserveCursor(editor.document);
        // Get the <font> nodes to color
        const selectionNodes = getSelectedNodes(editor.editable).filter(node => closestElement(node).isContentEditable && node.nodeName !== "T");
        if (isEmptyBlock(range.endContainer)) {
            selectionNodes.push(range.endContainer, ...descendants(range.endContainer));
        }
        const selectedNodes = mode === "backgroundColor"
            ? selectionNodes.filter(node => !closestElement(node, 'table.o_selected_table'))
            : selectionNodes;
        const selectedFieldNodes = new Set(getSelectedNodes(editor.editable)
                .map(n => closestElement(n, "*[t-field],*[t-out],*[t-esc]"))
                .filter(Boolean));

        function getFonts(selectedNodes) {
            return selectedNodes.flatMap(node => {
                let font = closestElement(node, 'font') || closestElement(node, 'span');
                const children = font && descendants(font);
                if (font && (font.nodeName === 'FONT' || (font.nodeName === 'SPAN' && font.style[mode]))) {
                    // Partially selected <font>: split it.
                    const selectedChildren = children.filter(child => selectedNodes.includes(child));
                    if (selectedChildren.length) {
                        font = splitAroundUntil(selectedChildren, font);
                    } else {
                        font = [];
                    }
                } else if ((node.nodeType === Node.TEXT_NODE && !isWhitespace(node) && node.textContent !== '\ufeff')
                        || (node.nodeName === 'BR' && isEmptyBlock(node.parentNode))
                        || (node.nodeType === Node.ELEMENT_NODE &&
                            node.nodeName !== 'FIGURE' &&
                            ['inline', 'inline-block'].includes(getComputedStyle(node).display) &&
                            !isWhitespace(node.textContent) &&
                            !node.classList.contains('btn') &&
                            !node.querySelector('font')) &&
                            node.nodeName !== 'A' &&
                            !(node.nodeName === 'SPAN' && node.style['fontSize'])) {
                    // Node is a visible text or inline node without font nor a button:
                    // wrap it in a <font>.
                    const previous = node.previousSibling;
                    const classRegex = mode === 'color' ? BG_CLASSES_REGEX : TEXT_CLASSES_REGEX;
                    if (
                        previous &&
                        previous.nodeName === 'FONT' &&
                        !previous.style[mode === 'color' ? 'backgroundColor' : 'color'] &&
                        !classRegex.test(previous.className) &&
                        selectedNodes.includes(previous.firstChild) &&
                        selectedNodes.includes(previous.lastChild)
                    ) {
                        // Directly follows a fully selected <font> that isn't
                        // colored in the other mode: append to that.
                        font = previous;
                    } else {
                        // No <font> found: insert a new one.
                        font = document.createElement('font');
                        node.after(font);
                    }
                    if (node.textContent) {
                        font.appendChild(node);
                    } else {
                        fillEmpty(font);
                    }
                } else {
                    font = []; // Ignore non-text or invisible text nodes.
                }
                return font;
            });
        }

        for (const fieldNode of selectedFieldNodes) {
            colorElement(fieldNode, color, mode);
        }

        let fonts = getFonts(selectedNodes);
        // Dirty fix as the previous call could have unconnected elements
        // because of the `splitAroundUntil`. Another call should provide he
        // correct list of fonts.
        if (!fonts.every((font) => font.isConnected)) {
            fonts = getFonts(selectedNodes);
        }

        // Color the selected <font>s and remove uncolored fonts.
        const fontsSet = new Set(fonts);
        for (const font of fontsSet) {
            colorElement(font, color, mode);
            if ((!hasColor(font, 'color') && !hasColor(font,'backgroundColor')) && (!font.hasAttribute('style') || !color)) {
                for (const child of [...font.childNodes]) {
                    font.parentNode.insertBefore(child, font);
                }
                font.parentNode.removeChild(font);
                fontsSet.delete(font);
            }
        }
        restoreCursor();
        if (wasCollapsed) {
            const newSelection = editor.document.getSelection();
            const range = new Range();
            range.setStart(newSelection.anchorNode, newSelection.anchorOffset);
            range.collapse(true);
            newSelection.removeAllRanges();
            newSelection.addRange(range);
        }
        return [...fontsSet, ...coloredTds];
    },
    // Table
    insertTable: (editor, { rowNumber = 2, colNumber = 2 } = {}) => {
        const tdsHtml = new Array(colNumber).fill('<td><p><br></p></td>').join('');
        const trsHtml = new Array(rowNumber).fill(`<tr>${tdsHtml}</tr>`).join('');
        const tableHtml = `<table class="table table-bordered o_table"><tbody>${trsHtml}</tbody></table>`;
        const sel = editor.document.getSelection();
        if (!sel.isCollapsed) {
            editor.deleteRange(sel);
        }
        while (!isBlock(sel.anchorNode)) {
            const anchorNode = sel.anchorNode;
            const isTextNode = anchorNode.nodeType === Node.TEXT_NODE;
            const newAnchorNode = isTextNode
                ? splitTextNode(anchorNode, sel.anchorOffset, DIRECTIONS.LEFT) + 1 && anchorNode
                : splitElement(anchorNode, sel.anchorOffset).shift();
            const newPosition = rightPos(newAnchorNode);
            setSelection(...newPosition, ...newPosition, false);
        }
        const [table] = editorCommands.insert(editor, parseHTML(editor.document, tableHtml));
        setCursorStart(table.querySelector('p'));
    },
    addColumn: (editor, beforeOrAfter, referenceCell) => {
        if (!referenceCell) {
            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding td.
            referenceCell = getInSelection(editor.document, 'td');
            if (!referenceCell) return;
        }
        const columnIndex = getColumnIndex(referenceCell);
        const table = closestElement(referenceCell, 'table');
        const tableWidth = table.style.width ? pxToFloat(table.style.width) : table.clientWidth;
        const referenceColumn = table.querySelectorAll(`tr td:nth-of-type(${columnIndex + 1})`);
        const referenceCellWidth = referenceCell.style.width ? pxToFloat(referenceCell.style.width) : referenceCell.clientWidth;
        // Temporarily set widths so proportions are respected.
        const firstRow = table.querySelector('tr');
        const firstRowCells = [...firstRow.children].filter(child => child.nodeName === 'TD' || child.nodeName === 'TH');
        let totalWidth = 0;
        for (const cell of firstRowCells) {
            const width = cell.style.width ? pxToFloat(cell.style.width) : cell.clientWidth;
            cell.style.width = width + 'px';
            // Spread the widths to preserve proportions.
            // -1 for the width of the border of the new column.
            const newWidth = Math.max(Math.round((width * tableWidth) / (tableWidth + referenceCellWidth - 1)), 13);
            cell.style.width = newWidth + 'px';
            totalWidth += newWidth;
        }
        referenceColumn.forEach((cell, rowIndex) => {
            const newCell = document.createElement('td');
            const p = document.createElement('p');
            p.append(document.createElement('br'));
            newCell.append(p);
            cell[beforeOrAfter](newCell);
            if (rowIndex === 0) {
                newCell.style.width = cell.style.width;
                totalWidth += pxToFloat(cell.style.width);
            }
        });
        if (totalWidth !== tableWidth - 1) { // -1 for the width of the border of the new column.
            firstRowCells[firstRowCells.length - 1].style.width = pxToFloat(firstRowCells[firstRowCells.length - 1].style.width) + (tableWidth - totalWidth - 1) + 'px';
        }
        // Fix the table and row's width so it doesn't change.
        table.style.width = tableWidth + 'px';
    },
    addRow: (editor, beforeOrAfter, referenceRow) => {
        if (!referenceRow) {
            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding tr.
            referenceRow = getInSelection(editor.document, 'tr');
            if (!referenceRow) return;
        }
        const referenceRowHeight = referenceRow.style.height ? pxToFloat(referenceRow.style.height) : referenceRow.clientHeight;
        const newRow = document.createElement('tr');
        newRow.style.height = referenceRowHeight + 'px';
        const cells = referenceRow.querySelectorAll('td');
        newRow.append(...Array.from(Array(cells.length)).map(() => {
            const td = document.createElement('td');
            const p = document.createElement('p');
            p.append(document.createElement('br'));
            td.append(p);
            return td;
        }));
        referenceRow[beforeOrAfter](newRow);
        newRow.style.height = referenceRowHeight + 'px';
        if (getRowIndex(newRow) === 0) {
            let columnIndex = 0;
            for (const newColumn of newRow.children) {
                newColumn.style.width = cells[columnIndex].style.width;
                cells[columnIndex].style.width = '';
                columnIndex++;
            }
        }
    },
    removeColumn: (editor, cell) => {
        if (!cell) {
            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding td.
            cell = getInSelection(editor.document, 'td');
            if (!cell) return;
        }
        const table = closestElement(cell, 'table');
        const cells = [...closestElement(cell, 'tr').querySelectorAll('th, td')];
        const index = cells.findIndex(td => td === cell);
        const siblingCell = cells[index - 1] || cells[index + 1];
        if (table.style.width) {
            const tableRect = table.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            table.style.width = tableRect.width - cellRect.width + 'px';
        }
        table.querySelectorAll(`tr td:nth-of-type(${index + 1})`).forEach(td => td.remove());
        siblingCell ? setSelection(...startPos(siblingCell)) : editorCommands.deleteTable(editor, table);
    },
    removeRow: (editor, row) => {
        if (!row) {
            getDeepRange(editor.editable, { select: true }); // Ensure deep range for finding tr.
            row = getInSelection(editor.document, 'tr');
            if (!row) return;
        }
        const table = closestElement(row, 'table');
        const rows = [...table.querySelectorAll('tr')];
        const rowIndex = rows.findIndex(tr => tr === row);
        const siblingRow = rows[rowIndex - 1] || rows[rowIndex + 1];
        row.remove();
        siblingRow ? setSelection(...startPos(siblingRow)) : editorCommands.deleteTable(editor, table);
    },
    resetSize: (editor,table) => {
        if (!table) {
            getDeepRange(editor.editable, { select: true });
            table = getInSelection(editor.document,'table');
        }
        table.removeAttribute('style');
        const cells = [...table.querySelectorAll('tr, td')];
        cells.forEach( cell => {
            const cStyle = cell.style;
            if (cell.tagName === 'TR') {
                cStyle.height = '';
            } else {
                cStyle.width = '';
            }
        })
    },
    deleteTable: (editor, table) => {
        table = table || getInSelection(editor.document, 'table');
        if (!table) return;
        const p = document.createElement('p');
        p.appendChild(document.createElement('br'));
        table.before(p);
        table.remove();
        setSelection(p, 0);
    },
    // Structure
    columnize: (editor, numberOfColumns, addParagraphAfter=true) => {
        const sel = editor.document.getSelection();
        const anchor = sel.anchorNode;
        const hasColumns = !!closestElement(anchor, '.o_text_columns');
        if (!numberOfColumns && hasColumns) {
            // Remove columns.
            const restore = preserveCursor(editor.document);
            const container = closestElement(anchor, '.o_text_columns');
            const rows = unwrapContents(container);
            for (const row of rows) {
                const columns = unwrapContents(row);
                for (const column of columns) {
                    const columnContents = unwrapContents(column);
                    for (const node of columnContents) {
                        resetOuids(node);
                    }
                }
            }
            restore();
        } else if (numberOfColumns && !hasColumns) {
            // Create columns.
            const restore = preserveCursor(editor.document);
            const container = document.createElement('div');
            if (!closestElement(anchor, '.container')) {
                container.classList.add('container');
            }
            container.classList.add('o_text_columns');
            const row = document.createElement('div');
            row.classList.add('row');
            container.append(row);
            const block = closestBlock(anchor);
            resetOuids(block);
            const columnSize = Math.floor(12 / numberOfColumns);
            const columns = [];
            for (let i = 0; i < numberOfColumns; i++) {
                const column = document.createElement('div');
                column.classList.add(`col-${columnSize}`);
                row.append(column);
                columns.push(column);
            }
            block.before(container);
            columns.shift().append(block);
            for (const column of columns) {
                const p = document.createElement('p');
                p.append(document.createElement('br'));
                p.classList.add('oe-hint');
                p.setAttribute('placeholder', 'New column...');
                column.append(p);
            }
            restore();
            if (addParagraphAfter) {
                const p = document.createElement('p');
                p.append(document.createElement('br'));
                container.after(p);
            }
        } else if (numberOfColumns && hasColumns) {
            const row = closestElement(anchor, '.row');
            const columns = [...row.children];
            const columnSize = Math.floor(12 / numberOfColumns);
            const diff = numberOfColumns - columns.length;
            if (diff > 0) {
                // Add extra columns.
                const restore = preserveCursor(editor.document);
                for (const column of columns) {
                    column.className = column.className.replace(REGEX_BOOTSTRAP_COLUMN, `col$1-${columnSize}`);
                }
                let lastColumn = columns[columns.length - 1];
                for (let i = 0; i < diff; i++) {
                    const column = document.createElement('div');
                    column.classList.add(`col-${columnSize}`);
                    const p = document.createElement('p');
                    p.append(document.createElement('br'));
                    p.classList.add('oe-hint');
                    p.setAttribute('placeholder', 'New column...');
                    column.append(p);
                    lastColumn.after(column);
                    lastColumn = column;
                }
                restore();
            } else if (diff < 0) {
                // Remove superfluous columns.
                const restore = preserveCursor(editor.document);
                for (const column of columns) {
                    column.className = column.className.replace(REGEX_BOOTSTRAP_COLUMN, `col$1-${columnSize}`);
                }
                const contents = [];
                for (let i = diff; i < 0; i++) {
                    const column = columns.pop();
                    const columnContents = unwrapContents(column);
                    for (const node of columnContents) {
                        resetOuids(node);
                    }
                    contents.unshift(...columnContents);
                }
                columns[columns.length - 1].append(...contents);
                restore();
            }
        }
    },
    insertHorizontalRule(editor) {
        const selection = editor.document.getSelection();
        const range = selection.getRangeAt(0);
        const element = closestElement(range.startContainer, paragraphRelatedElements) || closestBlock(range.startContainer);

        if (element && ancestors(element).includes(editor.editable)) {
            element.before(editor.document.createElement('hr'));
        }
    },
};

return __exports;
});
;

/******************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/deleteBackward.js  *
*  Lines: 297                                                                             *
******************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/deleteBackward', ['@web_editor/js/editor/odoo-editor/src/utils/constants', '@web_editor/js/editor/odoo-editor/src/commands/deleteForward', '@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { UNBREAKABLE_ROLLBACK_CODE, UNREMOVABLE_ROLLBACK_CODE, REGEX_BOOTSTRAP_COLUMN } = require("@web_editor/js/editor/odoo-editor/src/utils/constants");
const {deleteText} = require("@web_editor/js/editor/odoo-editor/src/commands/deleteForward");
const {
    boundariesOut,
    childNodeIndex,
    CTGROUPS,
    CTYPES,
    DIRECTIONS,
    endPos,
    fillEmpty,
    getState,
    isBlock,
    isEmptyBlock,
    isUnbreakable,
    isUnremovable,
    isVisible,
    leftPos,
    rightPos,
    moveNodes,
    nodeSize,
    paragraphRelatedElements,
    prepareUpdate,
    setSelection,
    isMediaElement,
    isSelfClosingElement,
    isNotEditableNode,
    createDOMPathGenerator,
    closestElement,
    closestBlock,
    getOffsetAndCharSize,
    ZERO_WIDTH_CHARS,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {
    const parentElement = this.parentElement;

    if (!offset) {
        // Backspace at the beginning of a text node is not a specific case to
        // handle, let the element implementation handle it.
        parentElement.oDeleteBackward([...parentElement.childNodes].indexOf(this), alreadyMoved);
        return;
    }
    // Get the size of the unicode character to remove.
    // If the current offset split an emoji in the middle , we need to change offset to the end of the emoji
    const [newOffset, charSize] = getOffsetAndCharSize(this.nodeValue, offset, DIRECTIONS.LEFT);
    deleteText.call(this, charSize, newOffset - charSize, DIRECTIONS.LEFT, alreadyMoved);
};

const isDeletable = (node) => {
    return isMediaElement(node) || isNotEditableNode(node);
}

HTMLElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false, offsetLimit) {
    const contentIsZWS = ZERO_WIDTH_CHARS.includes(this.textContent);
    let moveDest;
    if (offset) {
        const leftNode = this.childNodes[offset - 1];
        if (isUnremovable(leftNode)) {
            throw UNREMOVABLE_ROLLBACK_CODE;
        }
        if (
            isDeletable(leftNode)
        ) {
            leftNode.remove();
            return;
        }
        if (!isBlock(leftNode) || isSelfClosingElement(leftNode)) {
            /**
             * Backspace just after an inline node, convert to backspace at the
             * end of that inline node.
             *
             * E.g. <p>abc<i>def</i>[]</p> + BACKSPACE
             * <=>  <p>abc<i>def[]</i></p> + BACKSPACE
             */
            leftNode.oDeleteBackward(nodeSize(leftNode), alreadyMoved);
            return;
        }

        /**
         * Backspace just after an block node, we have to move any inline
         * content after it, up to the next block. If the cursor is between
         * two blocks, this is a theoretical case: just do nothing.
         *
         * E.g. <p>abc</p>[]de<i>f</i><p>ghi</p> + BACKSPACE
         * <=>  <p>abcde<i>f</i></p><p>ghi</p>
         */
        alreadyMoved = true;
        moveDest = endPos(leftNode);
    } else {
        if (isUnremovable(this)) {
            throw UNREMOVABLE_ROLLBACK_CODE;
        }
        // Empty unbreakable blocks should be removed with backspace, with the
        // notable exception of Bootstrap columns.
        if (isUnbreakable(this) && (REGEX_BOOTSTRAP_COLUMN.test(this.className) || !isEmptyBlock(this))) {
            throw UNBREAKABLE_ROLLBACK_CODE;
        }
        const parentEl = this.parentElement;
        // Handle editable sub-nodes
        if (
            parentEl &&
            parentEl.getAttribute("contenteditable") === "true" &&
            parentEl.oid !== "root" &&
            parentEl.parentElement &&
            !parentEl.parentElement.isContentEditable &&
            paragraphRelatedElements.includes(this.tagName) &&
            !this.previousElementSibling
        ) {
            // The first child element of a contenteditable="true" zone which
            // itself is contained in a contenteditable="false" zone can not be
            // removed if it is paragraph-like.
            throw UNREMOVABLE_ROLLBACK_CODE;
        }
        const closestLi = closestElement(this, 'li');
        if ((closestLi && !closestLi.previousElementSibling) || !isBlock(this) || isSelfClosingElement(this)) {
            /**
             * Backspace at the beginning of an inline node, nothing has to be
             * done: propagate the backspace. If the node was empty, we remove
             * it before.
             *
             * E.g. <p>abc<b></b><i>[]def</i></p> + BACKSPACE
             * <=>  <p>abc<b>[]</b><i>def</i></p> + BACKSPACE
             * <=>  <p>abc[]<i>def</i></p> + BACKSPACE
             */
            const parentOffset = childNodeIndex(this);

            if (!nodeSize(this) || contentIsZWS) {
                const visible = isVisible(this);
                const restore = prepareUpdate(...boundariesOut(this));
                this.remove();
                restore();

                fillEmpty(parentEl);

                if (visible) {
                    // TODO this handle BR/IMG/etc removals../ to see if we
                    // prefer to have a dedicated handler for every possible
                    // HTML element or if we let this generic code handle it.
                    setSelection(parentEl, parentOffset);
                    return;
                }
            }
            parentEl.oDeleteBackward(parentOffset, alreadyMoved);
            return;
        }

        /** If we are at the beninning of a block node,
         *  And the previous node is empty, remove it.
         *
         *   E.g. (previousEl == empty)
         *        <p><br></p><h1>[]def</h1> + BACKSPACE
         *   <=>  <h1>[]def</h1>
         *
         *   E.g. (previousEl != empty)
         *        <h3>abc</h3><h1>[]def</h1> + BACKSPACE
         *   <=>  <h3>abc[]def</h3>
        */
        const previousElementSiblingClosestBlock = closestBlock(this.previousElementSibling);
        if (
            previousElementSiblingClosestBlock &&
            (isEmptyBlock(previousElementSiblingClosestBlock) ||
                previousElementSiblingClosestBlock.textContent === '\u200B') &&
            paragraphRelatedElements.includes(this.nodeName)
        ) {
            previousElementSiblingClosestBlock.remove();
            setSelection(this, 0);
            return;
        }

        /**
         * Backspace at the beginning of a block node. If it doesn't have a left
         * block and it is one of the special block formatting tags below then
         * convert the block into a P and return immediately. Otherwise, we have
         * to move the inline content at its beginning outside of the element
         * and propagate to the left block.
         *
         * E.g. (prev == block)
         *      <p>abc</p><div>[]def<p>ghi</p></div> + BACKSPACE
         * <=>  <p>abc</p>[]def<div><p>ghi</p></div> + BACKSPACE
         *
         * E.g. (prev != block)
         *      abc<div>[]def<p>ghi</p></div> + BACKSPACE
         * <=>  abc[]def<div><p>ghi</p></div>
         */
        if (
            !this.previousElementSibling &&
            paragraphRelatedElements.includes(this.nodeName) &&
            this.nodeName !== 'P' &&
            !closestLi
        ) {
            if (!this.textContent) {
                const p = document.createElement('p');
                p.replaceChildren(...this.childNodes);
                this.replaceWith(p);
                setSelection(p, offset);
            }
            return;
        } else {
            moveDest = leftPos(this);
        }
    }

    const domPathGenerator = createDOMPathGenerator(DIRECTIONS.LEFT, {
        leafOnly: true,
        stopTraverseFunction: isDeletable,
    });
    const domPath = domPathGenerator(this, offset)
    const leftNode = domPath.next().value;
    if (leftNode && isDeletable(leftNode)) {
        const [parent, offset] = rightPos(leftNode);
        return parent.oDeleteBackward(offset, alreadyMoved);
    }
    let node = this.childNodes[offset];
    const nextSibling = this.nextSibling;
    let currentNodeIndex = offset;

    // `offsetLimit` will ensure we never move nodes that were not initialy in
    // the element => when Deleting and merging an element the containing node
    // will temporarily be hosted in the common parent beside possible other
    // nodes. We don't want to touch those other nodes when merging two html
    // elements ex : <div>12<p>ab[]</p><p>cd</p>34</div> should never touch the
    // 12 and 34 text node.
    if (offsetLimit === undefined) {
        while (node && !isBlock(node)) {
            node = node.nextSibling;
            currentNodeIndex++;
        }
    } else {
        currentNodeIndex = offsetLimit;
    }
    let [cursorNode, cursorOffset] = moveNodes(...moveDest, this, offset, currentNodeIndex);
    setSelection(cursorNode, cursorOffset);

    // Propagate if this is still a block on the left of where the nodes were
    // moved.
    if (
        cursorNode.nodeType === Node.TEXT_NODE &&
        (cursorOffset === 0 || cursorOffset === cursorNode.length)
    ) {
        cursorOffset = childNodeIndex(cursorNode) + (cursorOffset === 0 ? 0 : 1);
        cursorNode = cursorNode.parentNode;
    }
    if (cursorNode.nodeType !== Node.TEXT_NODE) {
        const { cType } = getState(cursorNode, cursorOffset, DIRECTIONS.LEFT);
        if (cType & CTGROUPS.BLOCK && (!alreadyMoved || cType === CTYPES.BLOCK_OUTSIDE)) {
            cursorNode.oDeleteBackward(cursorOffset, alreadyMoved, cursorOffset + currentNodeIndex - offset);
        } else if (!alreadyMoved) {
            // When removing a block node adjacent to an inline node, we need to
            // ensure the block node induced line break are kept with a <br>.
            // ex : <div>a<span>b</span><p>[]c</p>d</div> => deleteBakward =>
            // <div>a<span>b</span>[]c<br>d</div> In this case we cannot simply
            // merge the <p> content into the div parent, or we would lose the
            // line break located after the <p>.
            const cursorNodeNode = cursorNode.childNodes[cursorOffset];
            const cursorNodeRightNode = cursorNodeNode ? cursorNodeNode.nextSibling : undefined;
            if (cursorNodeRightNode &&
                cursorNodeRightNode.nodeType === Node.TEXT_NODE &&
                nextSibling === cursorNodeRightNode) {
                moveDest[0].insertBefore(document.createElement('br'), cursorNodeRightNode);
            }
        }
    }
};

HTMLLIElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {
    // If the deleteBackward is performed at the begening of a LI element,
    // we take the current LI out of the list.
    if (offset === 0) {
        this.oToggleList(offset);
        return;
    }
    // Otherwise, call the HTMLElement deleteBackward method.
    HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);
};

HTMLBRElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {
    const parentOffset = childNodeIndex(this);
    const rightState = getState(this.parentElement, parentOffset + 1, DIRECTIONS.RIGHT).cType;
    if (rightState & CTYPES.BLOCK_INSIDE) {
        this.parentElement.oDeleteBackward(parentOffset, alreadyMoved);
    } else {
        HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);
    }
};

HTMLTableCellElement.prototype.oDeleteBackward = function (offset, alreadyMoved = false) {
    if (offset) {
        HTMLElement.prototype.oDeleteBackward.call(this, offset, alreadyMoved);
    }
};

return __exports;
});
;

/*****************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/deleteForward.js  *
*  Lines: 248                                                                            *
*****************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/deleteForward', ['@web_editor/js/editor/odoo-editor/src/utils/constants', '@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { UNREMOVABLE_ROLLBACK_CODE } = require("@web_editor/js/editor/odoo-editor/src/utils/constants");
const {
    findNode,
    isSelfClosingElement,
    nodeSize,
    rightPos,
    getState,
    DIRECTIONS,
    CTYPES,
    leftPos,
    isFontAwesome,
    rightLeafOnlyNotBlockNotEditablePath,
    rightLeafOnlyPathNotBlockNotEditablePath,
    isNotEditableNode,
    splitTextNode,
    paragraphRelatedElements,
    prepareUpdate,
    isInPre,
    fillEmpty,
    setSelection,
    isZWS,
    childNodeIndex,
    boundariesOut,
    isEditorTab,
    isVisible,
    isUnbreakable,
    isEmptyBlock,
    isWhitespace,
    isVisibleTextNode,
    getOffsetAndCharSize,
    ZERO_WIDTH_CHARS,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

/**
 * Handle text node deletion for Text.oDeleteForward and Text.oDeleteBackward.
 *
 * @param {int} charSize
 * @param {int} offset
 * @param {DIRECTIONS} direction
 * @param {boolean} alreadyMoved
 */
__exports.deleteText = deleteText; function deleteText(charSize, offset, direction, alreadyMoved) {
    const parentElement = this.parentElement;
    // Split around the character where the deletion occurs.
    const firstSplitOffset = splitTextNode(this, offset);
    const secondSplitOffset = splitTextNode(parentElement.childNodes[firstSplitOffset], charSize);
    const middleNode = parentElement.childNodes[firstSplitOffset];

    // Do remove the character, then restore the state of the surrounding parts.
    const restore = prepareUpdate(parentElement, firstSplitOffset, parentElement, secondSplitOffset);
    const isSpace = isWhitespace(middleNode) && !isInPre(middleNode);
    const isZWS = ZERO_WIDTH_CHARS.includes(middleNode.nodeValue);
    middleNode.remove();
    restore();

    // If the removed element was not visible content, propagate the deletion.
    const parentState = getState(parentElement, firstSplitOffset, direction);
    if (
        isZWS ||
        (isSpace &&
            (parentState.cType !== CTYPES.CONTENT || parentState.node === undefined))
    ) {
        if (direction === DIRECTIONS.LEFT) {
            parentElement.oDeleteBackward(firstSplitOffset, alreadyMoved);
        } else {
            if (isSpace && parentState.node == undefined) {
                // multiple invisible space at the start of the node
                this.oDeleteForward(offset, alreadyMoved);
            } else {
                parentElement.oDeleteForward(firstSplitOffset, alreadyMoved);
            }
        }
        if (isZWS && parentElement.isConnected) {
            fillEmpty(parentElement);
        }
        return;
    }
    fillEmpty(parentElement);
    setSelection(parentElement, firstSplitOffset);
}

Text.prototype.oDeleteForward = function (offset, alreadyMoved = false) {
    const parentElement = this.parentElement;

    if (offset === this.nodeValue.length) {
        // Delete at the end of a text node is not a specific case to handle,
        // let the element implementation handle it.
        parentElement.oDeleteForward([...parentElement.childNodes].indexOf(this) + 1);
        return;
    }
    // Get the size of the unicode character to remove.
    const [newOffset, charSize] = getOffsetAndCharSize(this.nodeValue, offset + 1, DIRECTIONS.RIGHT);
    deleteText.call(this, charSize, newOffset, DIRECTIONS.RIGHT, alreadyMoved);
};

HTMLElement.prototype.oDeleteForward = function (offset) {
    const filterFunc = node =>
        isSelfClosingElement(node) || isVisibleTextNode(node) || isNotEditableNode(node);

    const firstLeafNode = findNode(rightLeafOnlyNotBlockNotEditablePath(this, offset), filterFunc);
    if (firstLeafNode &&
        isZWS(firstLeafNode) &&
        this.parentElement.hasAttribute('data-oe-zws-empty-inline')
    ) {
        const grandparent = this.parentElement.parentElement;
        if (!grandparent) {
            return;
        }

        const parentIndex = childNodeIndex(this.parentElement);
        const restore = prepareUpdate(...boundariesOut(this.parentElement));
        this.parentElement.remove();
        restore();
        HTMLElement.prototype.oDeleteForward.call(grandparent, parentIndex);
        return;
    } else if (
        firstLeafNode &&
        firstLeafNode.nodeType === Node.TEXT_NODE &&
        firstLeafNode.textContent === '\ufeff'
    ) {
        firstLeafNode.oDeleteForward(1);
        return;
    }
    if (
        this.hasAttribute &&
        this.hasAttribute('data-oe-zws-empty-inline') &&
        (
            isZWS(this) ||
            (this.textContent === '' && this.childNodes.length === 0)
        )
    ) {
        const parent = this.parentElement;
        if (!parent) {
            return;
        }

        const index = childNodeIndex(this);
        const restore = prepareUpdate(...boundariesOut(this));
        this.remove();
        restore();
        HTMLElement.prototype.oDeleteForward.call(parent, index);
        return;
    }

    if (firstLeafNode && (isFontAwesome(firstLeafNode) || isNotEditableNode(firstLeafNode))) {
        const nextSibling = firstLeafNode.nextSibling;
        const nextSiblingText = nextSibling ? nextSibling.textContent : '';
        firstLeafNode.remove();
        if (isEditorTab(firstLeafNode) && nextSiblingText[0] === '\u200B') {
            // When deleting an editor tab, we need to ensure it's related ZWS
            // il deleted as well.
            nextSibling.textContent = nextSiblingText.replace('\u200B', '');
        }
        return;
    }
    if (
        firstLeafNode &&
        (firstLeafNode.nodeName !== 'BR' ||
            getState(...rightPos(firstLeafNode), DIRECTIONS.RIGHT).cType !== CTYPES.BLOCK_INSIDE)
    ) {
        firstLeafNode.oDeleteBackward(Math.min(1, nodeSize(firstLeafNode)));
        return;
    }

    const nextSibling = this.nextSibling;
    if (
        (
            offset === this.childNodes.length ||
            (this.childNodes.length === 1 && this.childNodes[0].tagName === 'BR')
        ) &&
        this.parentElement &&
        nextSibling &&
        ['LI', 'UL', 'OL'].includes(nextSibling.tagName)
    ) {
        const nextSiblingNestedLi = nextSibling.querySelector('li:first-child');
        if (nextSiblingNestedLi) {
            // Add the first LI from the next sibbling list to the current list.
            this.after(nextSiblingNestedLi);
            // Remove the next sibbling list if it's empty.
            if (!isVisible(nextSibling, false) || nextSibling.textContent === '') {
                nextSibling.remove();
            }
            HTMLElement.prototype.oDeleteBackward.call(nextSiblingNestedLi, 0, true);
        } else {
            HTMLElement.prototype.oDeleteBackward.call(nextSibling, 0);
        }
        return;
    }

    // Remove the nextSibling if it is a non-editable element.
    if (
        nextSibling &&
        nextSibling.nodeType === Node.ELEMENT_NODE &&
        !nextSibling.isContentEditable
    ) {
        nextSibling.remove();
        return;
    }
    const parentEl = this.parentElement;
    // Prevent the deleteForward operation since it is done at the end of an
    // enclosed editable zone (inside a non-editable zone in the editor).
    if (
        parentEl &&
        parentEl.getAttribute("contenteditable") === "true" &&
        parentEl.oid !== "root" &&
        parentEl.parentElement &&
        !parentEl.parentElement.isContentEditable &&
        paragraphRelatedElements.includes(this.tagName) &&
        !this.nextElementSibling
    ) {
        throw UNREMOVABLE_ROLLBACK_CODE;
    }
    const firstOutNode = findNode(
        rightLeafOnlyPathNotBlockNotEditablePath(
            ...(firstLeafNode ? rightPos(firstLeafNode) : [this, offset]),
        ),
        filterFunc,
    );
    if (firstOutNode) {
        // If next sibblings is an unbreadable node, and current node is empty, we
        // delete the current node and put the selection at the beginning of the
        // next sibbling.
        if (nextSibling && isUnbreakable(nextSibling) && isEmptyBlock(this)) {
            const restore = prepareUpdate(...boundariesOut(this));
            this.remove();
            restore();
            setSelection(firstOutNode, 0);
            return;
        }
        const [node, offset] = leftPos(firstOutNode);
        // If the next node is a <LI> we call directly the htmlElement
        // oDeleteBackward : because we don't want the special cases of
        // deleteBackward for LI when we comme from a deleteForward.
        if (node.tagName === 'LI') {
            HTMLElement.prototype.oDeleteBackward.call(node, offset);
            return;
        }
        node.oDeleteBackward(offset);
        return;
    }
};

return __exports;
});
;

/*********************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/enter.js  *
*  Lines: 183                                                                    *
*********************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/enter', ['@web_editor/js/editor/odoo-editor/src/utils/constants', '@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { UNBREAKABLE_ROLLBACK_CODE } = require("@web_editor/js/editor/odoo-editor/src/utils/constants");

const {
    childNodeIndex,
    fillEmpty,
    isBlock,
    isUnbreakable,
    prepareUpdate,
    setCursorStart,
    setCursorEnd,
    setTagName,
    splitTextNode,
    toggleClass,
    isVisible,
    descendants,
    isVisibleTextNode,
    nodeSize,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oEnter = function (offset) {
    this.parentElement.oEnter(splitTextNode(this, offset), true);
};
/**
 * The whole logic can pretty much be described by this example:
 *
 *     <p><span><b>[]xt</b>ab</span>cd</p> + ENTER
 * <=> <p><span><b><br></b>[]<b>xt</b>ab</span>cd</p> + ENTER
 * <=> <p><span><b><br></b></span>[]<span><b>xt</b>ab</span>cd</p> + ENTER
 * <=> <p><span><b><br></b></span></p><p><span><b>[]xt</b>ab</span>cd</p> + SANITIZE
 * <=> <p><br></p><p><span><b>[]xt</b>ab</span>cd</p>
 *
 * Propagate the split for as long as we split an inline node, then refocus the
 * beginning of the first split node
 */
HTMLElement.prototype.oEnter = function (offset, firstSplit = true) {
    let didSplit = false;
    if (isUnbreakable(this)) {
        throw UNBREAKABLE_ROLLBACK_CODE;
    }
    let restore;
    if (firstSplit) {
        restore = prepareUpdate(this, offset);
    }

    // First split the node in two and move half the children in the clone.
    let splitEl = this.cloneNode(false);
    while (offset < this.childNodes.length) {
        splitEl.appendChild(this.childNodes[offset]);
    }
    if (isBlock(this) || splitEl.hasChildNodes()) {
        this.after(splitEl);
        if (isBlock(splitEl) || isVisible(splitEl) || splitEl.textContent === '\u200B') {
            didSplit = true;
        } else {
            splitEl.remove();
        }
    }

    // Propagate the split until reaching a block element (or continue to the
    // closest list item element if there is one).
    if (!isBlock(this) || (this.nodeName !== 'LI' && this.closest('LI'))) {
        if (this.parentElement) {
            this.parentElement.oEnter(childNodeIndex(this) + 1, !didSplit);
        } else {
            // There was no block parent element in the original chain, consider
            // this unsplittable, like an unbreakable.
            throw UNBREAKABLE_ROLLBACK_CODE;
        }
    }

    // All split have been done, place the cursor at the right position, and
    // fill/remove empty nodes.
    if (firstSplit && didSplit) {
        restore();

        let node = this;
        while (!isBlock(node) && !isVisible(node)) {
            const toRemove = node;
            node = node.parentNode;
            toRemove.remove();
        }
        fillEmpty(node);
        fillEmpty(splitEl);
        if (splitEl.tagName === 'A') {
            while (!isBlock(splitEl) && !isVisible(splitEl)) {
                const toRemove = splitEl;
                splitEl = splitEl.parentNode;
                toRemove.remove();
            }
        }
        setCursorStart(splitEl);
    }
    return splitEl;
};
/**
 * Specific behavior for headings: do not split in two if cursor at the end but
 * instead create a paragraph.
 * Cursor end of line: <h1>title[]</h1> + ENTER <=> <h1>title</h1><p>[]<br/></p>
 * Cursor in the line: <h1>tit[]le</h1> + ENTER <=> <h1>tit</h1><h1>[]le</h1>
 */
HTMLHeadingElement.prototype.oEnter = function () {
    const newEl = HTMLElement.prototype.oEnter.call(this, ...arguments);
    if (!descendants(newEl).some(isVisibleTextNode)) {
        const node = setTagName(newEl, 'P');
        node.replaceChildren(document.createElement('br'));
        setCursorStart(node);
    }
};
const isAtEdgeofLink = (link, offset) => {
    const childNodes = [...link.childNodes];
    let firstVisibleIndex = childNodes.findIndex(isVisible);
    firstVisibleIndex = firstVisibleIndex === -1 ? 0 : firstVisibleIndex;
    if (offset <= firstVisibleIndex) {
        return 'start';
    }
    let lastVisibleIndex = childNodes.reverse().findIndex(isVisible);
    lastVisibleIndex = lastVisibleIndex === -1 ? 0 : childNodes.length - lastVisibleIndex;
    if (offset >= lastVisibleIndex) {
        return 'end';
    }
    return false;
}
HTMLAnchorElement.prototype.oEnter = function (offset) {
    const edge = isAtEdgeofLink(this, offset);
    if (edge === 'start') {
        // Do not break the link at the edge: break before it.
        if (this.previousSibling) {
            return HTMLElement.prototype.oEnter.call(this.previousSibling, nodeSize(this.previousSibling));
        } else {
            const index = childNodeIndex(this);
            return HTMLElement.prototype.oEnter.call(this.parentElement, index ? index - 1 : 0);
        }
    } else if (edge === 'end') {
        // Do not break the link at the edge: break after it.
        if (this.nextSibling) {
            return HTMLElement.prototype.oEnter.call(this.nextSibling, 0);
        } else {
            return HTMLElement.prototype.oEnter.call(this.parentElement, childNodeIndex(this));
        }
    } else {
        HTMLElement.prototype.oEnter.call(this, ...arguments);
    }
}
/**
 * Same specific behavior as headings elements.
 */
HTMLQuoteElement.prototype.oEnter = HTMLHeadingElement.prototype.oEnter;
/**
 * Specific behavior for list items: deletion and unindentation when empty.
 */
HTMLLIElement.prototype.oEnter = function () {
    // If not empty list item, regular block split
    if (this.textContent || this.querySelector('table')) {
        const node = HTMLElement.prototype.oEnter.call(this, ...arguments);
        if (node.classList.contains('o_checked')) {
            toggleClass(node, 'o_checked');
        }
        return node;
    }
    this.oShiftTab();
};
/**
 * Specific behavior for pre: insert newline (\n) in text or insert p at end.
 */
HTMLPreElement.prototype.oEnter = function (offset) {
    if (offset < this.childNodes.length) {
        const lineBreak = document.createElement('br');
        this.insertBefore(lineBreak, this.childNodes[offset]);
        setCursorEnd(lineBreak);
    } else {
        const node = document.createElement('p');
        this.parentNode.insertBefore(node, this.nextSibling);
        fillEmpty(node);
        setCursorStart(node);
    }
};

return __exports;
});
;

/**************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/shiftEnter.js  *
*  Lines: 74                                                                          *
**************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/shiftEnter', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const {
    CTYPES,
    DIRECTIONS,
    isFakeLineBreak,
    prepareUpdate,
    rightPos,
    setSelection,
    getState,
    leftPos,
    splitTextNode,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oShiftEnter = function (offset) {
    return this.parentElement.oShiftEnter(splitTextNode(this, offset));
};

HTMLElement.prototype.oShiftEnter = function (offset) {
    const restore = prepareUpdate(this, offset);

    const brEl = document.createElement('br');
    const brEls = [brEl];
    if (offset >= this.childNodes.length) {
        this.appendChild(brEl);
    } else {
        this.insertBefore(brEl, this.childNodes[offset]);
    }
    if (isFakeLineBreak(brEl) && getState(...leftPos(brEl), DIRECTIONS.LEFT).cType !== CTYPES.BR) {
        const brEl2 = document.createElement('br');
        brEl.before(brEl2);
        brEls.unshift(brEl2);
    }

    restore();

    for (const el of brEls) {
        if (el.parentNode) {
            setSelection(...rightPos(el));
            break;
        }
    }

    return brEls;
};

/**
 * Special behavior for links: do not add a line break at its edges, but rather
 * move the line break outside the link.
 */
HTMLAnchorElement.prototype.oShiftEnter = function () {
    const brs = HTMLElement.prototype.oShiftEnter.call(this, ...arguments);
    const anchor = brs[0].parentElement;
    let firstChild = anchor.firstChild;
    if (firstChild && firstChild.nodeType === Node.TEXT_NODE && firstChild.textContent === '\uFEFF') {
        firstChild = anchor.childNodes[1];
    }
    let lastChild = anchor.lastChild;
    if (lastChild && lastChild.nodeType === Node.TEXT_NODE && lastChild.textContent === '\uFEFF') {
        lastChild = anchor.childNodes.length > 1 && anchor.childNodes[anchor.childNodes.length - 2];
    }
    if (brs.includes(firstChild)) {
        brs.forEach(br => anchor.before(br));
        setSelection(...rightPos(brs[brs.length - 1]));
    } else if (brs.includes(lastChild)) {
        brs.forEach(br => anchor.after(br));
        setSelection(...rightPos(brs[0]));
    }
}

return __exports;
});
;

/************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/shiftTab.js  *
*  Lines: 90                                                                        *
************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/shiftTab', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { isUnbreakable, preserveCursor, toggleClass, isBlock, isVisible } = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oShiftTab = function () {
    return this.parentElement.oShiftTab(0);
};

HTMLElement.prototype.oShiftTab = function (offset = undefined) {
    if (!isUnbreakable(this)) {
        return this.parentElement.oShiftTab(offset);
    }
    return false;
};

// returns: is still in a <LI> nested list
HTMLLIElement.prototype.oShiftTab = function () {
    const li = this;
    if (li.nextElementSibling) {
        const ul = li.parentElement.cloneNode(false);
        while (li.nextSibling) {
            ul.append(li.nextSibling);
        }
        if (li.parentNode.parentNode.tagName === 'LI') {
            const lip = document.createElement('li');
            toggleClass(lip, 'oe-nested');
            lip.append(ul);
            li.parentNode.parentNode.after(lip);
        } else {
            li.parentNode.after(ul);
        }
    }

    const restoreCursor = preserveCursor(this.ownerDocument);
    if (
        li.parentNode.parentNode.tagName === 'LI' &&
        !li.parentNode.parentNode.classList.contains('nav-item')
    ) {
        const ul = li.parentNode;
        const shouldRemoveParentLi = !li.previousElementSibling && !ul.previousElementSibling;
        const toremove = shouldRemoveParentLi ? ul.parentNode : null;
        ul.parentNode.after(li);
        if (toremove) {
            if (toremove.classList.contains('oe-nested')) {
                // <li>content<ul>...</ul></li>
                toremove.remove();
            } else {
                // <li class="oe-nested"><ul>...</ul></li>
                ul.remove();
            }
        }
        restoreCursor();
        return li;
    } else {
        const ul = li.parentNode;
        const dir = ul.getAttribute('dir');
        let p;
        while (li.firstChild) {
            if (isBlock(li.firstChild)) {
                if (p && isVisible(p)) {
                    ul.after(p);
                }
                p = undefined;
                ul.after(li.firstChild);
            } else {
                p = p || document.createElement('P');
                if (dir) {
                    p.setAttribute('dir', dir);
                    p.style.setProperty('text-align', ul.style.getPropertyValue('text-align'));
                }
                p.append(li.firstChild);
            }
        }
        if (p && isVisible(p)) {
            ul.after(p)
        }

        restoreCursor(new Map([[li, ul.nextSibling]]));
        li.remove();
        if (!ul.firstElementChild) {
            ul.remove();
        }
    }
    return false;
};

return __exports;
});
;

/*******************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/tab.js  *
*  Lines: 37                                                                   *
*******************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/tab', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { createList, getListMode, isBlock, preserveCursor, toggleClass } = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oTab = function () {
    return this.parentElement.oTab(0);
};

HTMLElement.prototype.oTab = function (offset) {
    if (!isBlock(this)) {
        return this.parentElement.oTab(offset);
    }
    return false;
};

HTMLLIElement.prototype.oTab = function () {
    const lip = document.createElement('li');
    const destul =
        (this.previousElementSibling && this.previousElementSibling.querySelector('ol, ul')) ||
        (this.nextElementSibling && this.nextElementSibling.querySelector('ol, ul')) ||
        this.closest('ul, ol');

    const ul = createList(getListMode(destul));
    lip.append(ul);

    const cr = preserveCursor(this.ownerDocument);
    toggleClass(lip, 'oe-nested');
    this.before(lip);
    ul.append(this);
    cr();
    return true;
};

return __exports;
});
;

/**************************************************************************************
*  Filepath: /web_editor/static/src/js/editor/odoo-editor/src/commands/toggleList.js  *
*  Lines: 86                                                                          *
**************************************************************************************/
odoo.define('@web_editor/js/editor/odoo-editor/src/commands/toggleList', ['@web_editor/js/editor/odoo-editor/src/utils/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const {
    childNodeIndex,
    isBlock,
    preserveCursor,
    insertListAfter,
    getAdjacents,
    closestElement,
    toggleList,
} = require("@web_editor/js/editor/odoo-editor/src/utils/utils");

Text.prototype.oToggleList = function (offset, mode) {
    // Create a new list if textNode is inside a nav-item list
    if (closestElement(this, 'li').classList.contains('nav-item')) {
        const restoreCursor = preserveCursor(this.ownerDocument);
        insertListAfter(this, mode, [this]);
        restoreCursor();
    } else {
        this.parentElement.oToggleList(childNodeIndex(this), mode);
    }
};

HTMLElement.prototype.oToggleList = function (offset, mode = 'UL') {
    if (!isBlock(this)) {
        return this.parentElement.oToggleList(childNodeIndex(this));
    }
    const closestLi = this.closest('li');
    // Do not toggle nav-item list as they don't behave like regular list items
    if (closestLi && !closestLi.classList.contains('nav-item')) {
        return closestLi.oToggleList(0, mode);
    }
    const restoreCursor = preserveCursor(this.ownerDocument);
    if (this.oid === 'root') {
        const callingNode = this.childNodes[offset];
        const group = getAdjacents(callingNode, n => !isBlock(n));
        insertListAfter(callingNode, mode, [group]);
        restoreCursor();
    } else {
        const list = insertListAfter(this, mode, [this]);
        if (this.hasAttribute('dir')) {
            list.setAttribute('dir', this.getAttribute('dir'));
        }
        restoreCursor(new Map([[this, list.firstElementChild]]));
    }
};

HTMLParagraphElement.prototype.oToggleList = function (offset, mode = 'UL') {
    const restoreCursor = preserveCursor(this.ownerDocument);
    const list = insertListAfter(this, mode, [[...this.childNodes]]);
    const classList = [...list.classList];
    for (const attribute of this.attributes) {
        if (attribute.name === 'class' && attribute.value && list.className) {
            list.className = `${list.className} ${attribute.value}`;
        } else {
            list.setAttribute(attribute.name, attribute.value);
        }
    }
    for (const className of classList) {
        list.classList.toggle(className, true); // restore list classes
    }
    this.remove();

    restoreCursor(new Map([[this, list.firstChild]]));
    return true;
};

HTMLLIElement.prototype.oToggleList = function (offset, mode) {
    const restoreCursor = preserveCursor(this.ownerDocument);
    toggleList(this, mode, offset);
    restoreCursor();
    return false;
};

HTMLTableCellElement.prototype.oToggleList = function (offset, mode) {
    const restoreCursor = preserveCursor(this.ownerDocument);
    const callingNode = this.childNodes[offset];
    const group = getAdjacents(callingNode, n => !isBlock(n));
    insertListAfter(callingNode, mode, [group]);
    restoreCursor();
};

return __exports;
});
;

/****************************************************************
*  Filepath: /web_editor/static/src/js/editor/drag_and_drop.js  *
*  Lines: 214                                                   *
****************************************************************/
odoo.define('@web_editor/js/editor/drag_and_drop', ['@web/core/utils/draggable_hook_builder', '@web/core/utils/objects', '@odoo/owl', '@web/core/utils/timing', '@web/core/utils/ui'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { makeDraggableHook } = require("@web/core/utils/draggable_hook_builder");
const { pick } = require("@web/core/utils/objects");
const { reactive } = require("@odoo/owl");
const { throttleForAnimation } = require("@web/core/utils/timing");
const { closest, touching } = require("@web/core/utils/ui");

/** @typedef {import("@web/core/utils/draggable_hook_builder").DraggableHandlerParams} DraggableHandlerParams */
/** @typedef {import("@web/core/utils/draggable_hook_builder").DraggableBuilderParams} DraggableBuilderParams */
/** @typedef {import("@web/core/utils/draggable").DraggableParams} DraggableParams */

/** @typedef {DraggableHandlerParams & { dropzone: HTMLElement | null, helper: HTMLElement }} DragAndDropHandlerParams */
/** @typedef {DraggableHandlerParams & { helper: HTMLElement }} DragAndDropStartParams */
/** @typedef {DraggableHandlerParams & { dropzone: HTMLElement }} DropzoneHandlerParams */
/**
 * @typedef DragAndDropParams
 * @extends {DraggableParams}
 *
 * MANDATORY
 * @property {(() => Array)} dropzones a function that returns the available dropzones
 * @property {(() => HTMLElement)} helper a function that returns a helper element
 * that will follow the cursor when dragging
 * @property {HTMLElement || (() => HTMLElement)} scrollingElement the element on
 * which a scroll should be triggered
 *
 * HANDLERS (Optional)
 * @property {(params: DragAndDropStartParams) => any} [onDragStart]
 * called when a dragging sequence is initiated
 * @property {(params: DropzoneHandlerParams) => any} [dropzoneOver]
 * called when an element is over a dropzone
 * @property {(params: DropzoneHandlerParams) => any} [dropzoneOut]
 * called when an element is leaving a dropzone
 * @property {(params: DragAndDropHandlerParams) => any} [onDrag]
 * called when an element is being dragged
 * @property {(params: DragAndDropHandlerParams) => any} [onDragEnd]
 * called when the dragging sequence is over
 */
/**
 * @typedef NativeDraggableState
 * @property {(params: DraggableParams) => any} update
 * method to update the params of the draggable
 * @property {import("@web/core/utils/draggable").DraggableState} state
 * state of the draggable component
 * @property {() => any} destroy
 * method to destroy and unbind the draggable component
 */
/**
 * Utility function to create a native draggable component
 *
 * @param {DraggableBuilderParams} hookParams
 * @param {DraggableParams} initialParams
 * @returns {NativeDraggableState}
 */
__exports.useNativeDraggable = useNativeDraggable; function useNativeDraggable(hookParams, initialParams) {
    const setupFunctions = new Map();
    const cleanupFunctions = [];
    const currentParams = { ...initialParams };
    const setupHooks = {
        wrapState: reactive,
        throttle: throttleForAnimation,
        addListener: (el, type, callback, options) => {
            el.addEventListener(type, callback, options);
            cleanupFunctions.push(() => el.removeEventListener(type, callback));
        },
        setup: (setupFn, depsFn) => setupFunctions.set(setupFn, depsFn),
        teardown: (cleanupFn) => {
            cleanupFunctions.push(cleanupFn);
        }
    };
    // Compatibility for tests
    const el = initialParams.ref.el;
    // TODO this is probably to be removed in master: the received params
    // contain the selector that should be checked and it will be transferred
    // to the makeDraggableHook function. There should not be any need to add
    // the default selector class here.
    el.classList.add("o_draggable");
    cleanupFunctions.push(() => el.classList.remove("o_draggable"));

    const draggableState = makeDraggableHook({ setupHooks, ...hookParams})(currentParams);
    draggableState.enable = true;
    const draggableComponent = {
        state: draggableState,
        update: (newParams) => {
            Object.assign(currentParams, newParams);
            setupFunctions.forEach((depsFn, setupFn) => setupFn(...depsFn()));
        },
        destroy: () => {
            cleanupFunctions.forEach((cleanupFn) => cleanupFn());
        }
    };
    draggableComponent.update({});
    return draggableComponent;
}

function updateElementPosition(el, { x, y }, styleFn, offset = { x: 0, y: 0 }) {
    return styleFn(el, { top: `${y - offset.y}px`, left: `${x - offset.x}px`});
}
/** @type DraggableBuilderParams */
const dragAndDropHookParams = {
    name: "useDragAndDrop",
    acceptedParams: {
        dropzones: [Function],
        scrollingElement: [Object, Function],
        helper: [Function],
        extraWindow: [Object, Function],
    },
    edgeScrolling: { enabled: true },
    onComputeParams({ ctx, params }) {
        // The helper is mandatory and will follow the cursor instead
        ctx.followCursor = false;
        ctx.scrollingElement = params.scrollingElement;
        ctx.getHelper = params.helper;
        ctx.getDropZones = params.dropzones;
    },
    onWillStartDrag: ({ ctx }) => {
        ctx.current.container = ctx.scrollingElement;
        ctx.current.helperOffset = { x: 0, y: 0 };
    },
    onDragStart: ({ ctx, addStyle, addCleanup }) => {
        // Use the helper as the tracking element to properly update scroll values.
        ctx.current.element = ctx.getHelper({ ...ctx.current, ...ctx.pointer });
        ctx.current.helper = ctx.current.element;
        ctx.current.helper.style.position = "fixed";
        // We want the pointer events on the helper so that the cursor
        // is properly displayed.
        ctx.current.helper.classList.remove("o_dragged");
        ctx.current.helper.style.cursor = ctx.cursor;
        ctx.current.helper.style.pointerEvents = "auto";

        // If the helper is inside the iframe, we want pointer events on the
        // frame element so that they reach the window and properly apply
        // the cursor.
        const frameElement = ctx.current.helper.ownerDocument.defaultView.frameElement;
        if (frameElement) {
            addStyle(frameElement, { pointerEvents: "auto" });
        }

        addCleanup(() => ctx.current.helper.remove());

        updateElementPosition(ctx.current.helper, ctx.pointer, addStyle, ctx.current.helperOffset);

        return pick(ctx.current, "element", "helper");
    },
    onDrag: ({ ctx, addStyle, callHandler }) => {
        ctx.current.helper.classList.add("o_draggable_dragging");

        updateElementPosition(ctx.current.helper, ctx.pointer, addStyle, ctx.current.helperOffset);
        // Unfortunately, DOMRect is not an Object, so spreading operator from
        // `touching` does not work, so convert DOMRect to plain object.
        let helperRect = ctx.current.helper.getBoundingClientRect();
        helperRect = {
            x: helperRect.x,
            y: helperRect.y,
            width: helperRect.width,
            height: helperRect.height,
        };
        const dropzoneEl = closest(touching(ctx.getDropZones(), helperRect), helperRect);
        // Update the drop zone if it's in grid mode
        if (ctx.current.dropzone?.el && ctx.current.dropzone.el.classList.contains("oe_grid_zone")) {
            ctx.current.dropzone.rect = ctx.current.dropzone.el.getBoundingClientRect();
        }
        if (
            ctx.current.dropzone &&
            (
                ctx.current.dropzone.el === dropzoneEl
                || (
                    !dropzoneEl
                    && touching([ctx.current.helper], ctx.current.dropzone.rect).length > 0
                )
            )
        ) {
            // If no new dropzone but old one is still valid, return early.
            return pick(ctx.current, "element", "dropzone", "helper");
        }

        if (ctx.current.dropzone && dropzoneEl !== ctx.current.dropzone.el) {
            callHandler("dropzoneOut", { dropzone: ctx.current.dropzone });
            delete ctx.current.dropzone;
        }

        if (dropzoneEl) {
            // Save rect information prior to calling the over function
            // to keep a consistent dropzone even if content was added.
            const rect = DOMRect.fromRect(dropzoneEl.getBoundingClientRect());
            ctx.current.dropzone = {
                el: dropzoneEl,
                rect: {
                    x: rect.x, y: rect.y, width: rect.width, height: rect.height
                }
            };
            callHandler("dropzoneOver", { dropzone: ctx.current.dropzone });
        }
        return pick(ctx.current, "element", "dropzone", "helper");
    },
    onDragEnd({ ctx }) {
        return pick(ctx.current, "element", "dropzone", "helper");
    }
};
/**
 * Function to start a drag and drop handler
 *
 * @param {DragAndDropParams} initialParams params given to the drag and drop
 * component
 * @returns {NativeDraggableState}
 */
__exports.useDragAndDrop = useDragAndDrop; function useDragAndDrop(initialParams) {
    return useNativeDraggable(dragAndDropHookParams, initialParams);
}

return __exports;
});
;

/*********************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/linkDialogCommand.js  *
*  Lines: 60                                                         *
*********************************************************************/
odoo.define('@web_editor/js/wysiwyg/linkDialogCommand', ['@web/core/registry', '@web/core/commands/default_providers', '@web_editor/js/wysiwyg/wysiwyg'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require('@web/core/registry')
const { HotkeyCommandItem } = require('@web/core/commands/default_providers')
const { Wysiwyg } = require('@web_editor/js/wysiwyg/wysiwyg');

// The only way to know if an editor is under focus when the command palette
// open is to look if there in a selection within a wysiwyg editor in the page.
// As the selection changes after the command palette is open, we need to save
// the action (that have the range and editor in the closure) as well as the
// label to use.
let sessionActionLabel = [];

const commandProviderRegistry = registry.category("command_provider");
commandProviderRegistry.add("link dialog", {
    async provide(env, { sessionId }) {
        let [lastSessionId, action, label] = sessionActionLabel;
        if (lastSessionId !== sessionId) {
            const wysiwyg = [...Wysiwyg.activeWysiwygs].find((wysiwyg) => {
                return wysiwyg.isSelectionInEditable();
            });
            const selection = wysiwyg && wysiwyg.odooEditor && wysiwyg.odooEditor.document.getSelection();
            const range = selection && selection.rangeCount && selection.getRangeAt(0);
            if (range) {
                label = !wysiwyg.getInSelection('a') ? 'Create link' : 'Edit link';
                action = () => {
                    const selection = wysiwyg.odooEditor.document.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);

                    wysiwyg.openLinkToolsFromSelection();
                }
                sessionActionLabel = [sessionId, action, label]
            } else {
                sessionActionLabel = [sessionId];
            }
        }
        [lastSessionId, action, label] = sessionActionLabel;

        if (action) {
            return [
                {
                    Component: HotkeyCommandItem,
                    action: action,
                    category: 'shortcut_conflict',
                    name: label,
                    props: { hotkey: 'control+k' },
                }
            ]
        } else {
            return [];
        }
    },
});

return __exports;
});
;

/******************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/MoveNodePlugin.js  *
*  Lines: 449                                                     *
******************************************************************/
odoo.define('@web_editor/js/wysiwyg/MoveNodePlugin', ['@web_editor/js/editor/odoo-editor/src/OdooEditor', '@web_editor/js/editor/drag_and_drop'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const {
    ancestors,
    closestElement,
    resetOuids,
    setSelection,
} = require('@web_editor/js/editor/odoo-editor/src/OdooEditor');
const { useNativeDraggable } = require("@web_editor/js/editor/drag_and_drop");

const simpleDraggableHook = {
    acceptedParams: {
        helper: [Function],
    },
    edgeScrolling: { enable: true },
    onComputeParams({ ctx, params }) {
        ctx.helper = params.helper;
        ctx.followCursor = false;
        ctx.tolerance = 0;
    },
    onDragStart({ ctx }) {
        ctx.current.element = ctx.helper();
        ctx.current.element.style.left = `${ctx.pointer.x + 10}px`;
        ctx.current.element.style.top = `${ctx.pointer.y + 10}px`;
        ctx.current.element.style.position = "fixed";
        // makeDraggableHook disables pointer events, we want them in this case
        document.body.classList.remove("pe-none");
        return ctx.current;
    },
    onDrag({ ctx }) {
        ctx.current.element.style.left = `${ctx.pointer.x}px`;
        ctx.current.element.style.top = `${ctx.pointer.y}px`;
    },
    onDragEnd({ ctx }) {
        ctx.current.element.remove();
        return ctx.current;
    },
};

const WIDGET_CONTAINER_WIDTH = 25;
const WIDGET_MOVE_SIZE = 20;

const ALLOWED_ELEMENTS = 'h1, h2, h3, p, hr, pre, blockquote, ul, ol, table, .o_knowledge_behavior_anchor, .o_text_columns, .o_editor_banner, .oe_movable';

const MoveNodePlugin = __exports.MoveNodePlugin = class MoveNodePlugin {
    constructor(options = {}) {
        this._options = options;

        this._intersectionObserver = new IntersectionObserver(
            this._intersectionObserverCallback.bind(this),
            {
                root: document,
            }
        );
        this._visibleMovableElements = new Set();
    }

    start() {
        this._editor = this._options.editor;
        this._editable = this._options.editor.editable;
        this._document = this._options.editor.document;
        this._elementHookMap = new Map();

        this._editor.addDomListener(this._editable, 'mousemove', this._onMousemove.bind(this), true);
        this._editor.addDomListener(this._editor.document, 'keydown', this._onDocumentKeydown.bind(this), true);
        this._editor.addDomListener(this._editor.document, 'mousemove', this._onDocumentMousemove.bind(this), true);

        const avatarContainer = this._editor.mainAbsoluteContainer.querySelector('[data-oe-absolute-container-id="oe-avatars-counters-container"]');

        // This container help to add zone into which the mouse can activate the move widget.
        this._widgetHookContainer = this._editor.makeAbsoluteContainer('oe-widget-hooks-container');
        avatarContainer.before(this._widgetHookContainer);
        // This container contains the differents widgets.
        this._widgetContainer = this._editor.makeAbsoluteContainer('oe-widgets-container');
        avatarContainer.before(this._widgetContainer);
        // This container contains the jquery helper element.
        this._dragHelperContainer = this._editor.makeAbsoluteContainer('oe-movenode-helper-container');
        avatarContainer.before(this._dragHelperContainer);
        // This container contains drop zones. They are the zones that handle where the drop should happen.
        this._dropzonesContainer = this._editor.makeAbsoluteContainer('oe-dropzones-container');
        avatarContainer.before(this._dropzonesContainer);
        // This container contains drop hint. The final rectangle showed to the user.
        this._dropzoneHintContainer = this._editor.makeAbsoluteContainer('oe-dropzone-hint-container');
        avatarContainer.before(this._dropzoneHintContainer);

        // Uncomment line for debugging tranparent zones
        // this._widgetHookContainer.classList.add('debug');
        // this._dropzonesContainer.classList.add('debug');

        this._scrollableElement = closestElement(this._editable.parentElement);
        while (this._scrollableElement && getComputedStyle(this._scrollableElement).overflowY !== 'auto') {
            this._scrollableElement = this._scrollableElement.parentElement;
        }
        this._scrollableElement = this._scrollableElement || this._editable;

        this._resetHooksNextMousemove = true;
        this.mutationObserver = new MutationObserver(() => {
            this._resetHooksNextMousemove = true;
            this._removeMoveWidget();
        });
        this.mutationObserver.observe(this._editable, {
            childList: true,
            subtree: true,
            characterData: true,
            characterDataOldValue: true,
        });
        this._editor.addDomListener(window, 'resize', this._updateHooks.bind(this));
        if (this._editor.document.defaultView !== window) {
            this._editor.addDomListener(this._editor.document.defaultView, 'resize', this._updateHooks.bind(this));
        }
    }
    destroy() {
        this._intersectionObserver.disconnect();
        this.mutationObserver.disconnect();
        this.smoothScrollOnDrag && this.smoothScrollOnDrag.destroy();
    }
    _intersectionObserverCallback(entries) {
        for (const entry of entries) {
            const element = entry.target;
            if (entry.isIntersecting) {
                this._visibleMovableElements.add(element);
                this._resetHooksNextMousemove = true;
            } else {
                this._visibleMovableElements.delete(element);
                const hookElement = this._elementHookMap.get(element);
                if (hookElement) {
                    // If hookElement is undefined, it means that this callback
                    // was called after a new element was inserted in the
                    // editable, but before the next _updateHooks. The hook will
                    // be created when that happens.
                    hookElement.style.display = `none`;
                }
            }
        }
    }
    _updateHooks() {
        const editableStyles = getComputedStyle(this._editable);
        this._editableRect = this._editable.getBoundingClientRect();
        const paddingLeft = parseInt(editableStyles.paddingLeft, 10) || 0;
        this._editableRect.x = this._editableRect.x + paddingLeft - (WIDGET_CONTAINER_WIDTH + 5);
        this._editableRect.width = this._editableRect.width - paddingLeft + (WIDGET_CONTAINER_WIDTH + 5);
        const containerRect = this._widgetHookContainer.getBoundingClientRect();
        const elements = this._getMovableElements();

        const elementsToGarbageCollect = new Set(this._elementHookMap.keys());
        for (const index in elements) {
            const element = elements[index];
            elementsToGarbageCollect.delete(element);
            let hookElement = this._elementHookMap.get(element);
            if (!hookElement) {
                hookElement = document.createElement('div');
                this._elementHookMap.set(element, hookElement);
                hookElement.classList.add('oe-dropzone-hook');
                hookElement.addEventListener('mouseenter', () => {
                    if (element !== this._currentMovableElement) {
                        this._setMovableElement(element);
                    }
                });
                this._widgetHookContainer.append(hookElement);
                hookElement.style.display = `none`;

                this._intersectionObserver.observe(element);
            }
            hookElement.style.zIndex = index;
        }
        // For all the elements that are not in the dom, remove their
        // corresponding hook.
        for (const element of elementsToGarbageCollect) {
            this._visibleMovableElements.delete(element);
            this._elementHookMap.get(element).remove();
            this._intersectionObserver.unobserve(element);
            this._elementHookMap.delete(element);
        }

        const visibleElements = [...this._visibleMovableElements];
        // Prevent layout thrashing by computing all the rects in advance.
        const elementRects = visibleElements.map((element) => element.getBoundingClientRect());
        for (const index in visibleElements) {
            const element = visibleElements[index];
            const elementRect = elementRects[index];
            const hookElement = this._elementHookMap.get(element);

            const style = getComputedStyle(element);
            const marginTop = parseInt(style.marginTop, 10) || 0;
            const marginBottom = parseInt(style.marginBottom, 10) || 0;
            let hookBox;
            if (element.tagName === 'HR') {
                hookBox = new DOMRect(
                    elementRect.x - containerRect.left - WIDGET_CONTAINER_WIDTH,
                    elementRect.y - containerRect.top - marginTop,
                    elementRect.width + WIDGET_CONTAINER_WIDTH,
                    elementRect.height + marginTop + marginBottom,
                );
            } else {
                hookBox = new DOMRect(
                    elementRect.x - containerRect.left - WIDGET_CONTAINER_WIDTH,
                    elementRect.y - containerRect.top - marginTop,
                    WIDGET_CONTAINER_WIDTH,
                    elementRect.height + marginTop + marginBottom,
                );
            }

            hookElement.style.left = `${hookBox.x}px`;
            hookElement.style.top = `${hookBox.y}px`;
            hookElement.style.width = `${hookBox.width}px`;
            hookElement.style.height = `${hookBox.height}px`;
            hookElement.style.display = `block`;
        }
    }
    _updateAnchorWidgets(newAnchorWidget) {
        let movableElement = newAnchorWidget && closestElement(newAnchorWidget, (node) => {
            return isNodeMovable(node) && node.matches(ALLOWED_ELEMENTS);
        });
        // Retrive the first list container from the ancestors.
        const listContainer = movableElement && ancestors(movableElement, this._editable)
            .reverse()
            .find(n => ['UL', 'OL'].includes(n.tagName));
        movableElement = listContainer || movableElement;
        if (movableElement && (movableElement !== this._currentMovableElement)) {
            this._setMovableElement(movableElement);
        }
    }
    _getMovableElements() {
        return [...new Set([...this._editable.querySelectorAll(ALLOWED_ELEMENTS)])]
            .filter((node) => isNodeMovable(node));
    }
    _getDroppableElements(draggableNode) {
        return this._getMovableElements().filter((node) =>
            !closestElement(node.parentElement, (n) => n === draggableNode)
        );
    }
    _setMovableElement(movableElement) {
        this._removeMoveWidget();
        this._currentMovableElement = movableElement;
        this._editor.disableAvatarForElement(movableElement);

        const containerRect = this._widgetContainer.getBoundingClientRect();
        const anchorBlockRect = this._currentMovableElement.getBoundingClientRect();
        const closestList = closestElement(this._currentMovableElement, 'ul, ol'); // Prevent overlap bullets.
        const anchorX = closestList ? closestList.getBoundingClientRect().x : anchorBlockRect.x;
        let anchorY = anchorBlockRect.y;
        if (this._currentMovableElement.tagName.match(/H[1-6]/)) {
            anchorY += (anchorBlockRect.height - WIDGET_MOVE_SIZE) / 2;
        }

        this._moveWidget = this._document.createElement('div');
        this._moveWidget.className = 'oe-sidewidget-move fa fa-sort';
        this._widgetContainer.append(this._moveWidget);

        let moveWidgetOffsetTop = 0;
        if (movableElement.tagName === 'HR') {
            const style = getComputedStyle(movableElement);
            moveWidgetOffsetTop = parseInt(style.marginTop, 10) || 0;
        }

        this._moveWidget.style.width = `${WIDGET_MOVE_SIZE}px`;
        this._moveWidget.style.height = `${WIDGET_MOVE_SIZE}px`;
        this._moveWidget.style.top = `${anchorY - containerRect.y - moveWidgetOffsetTop}px`;
        this._moveWidget.style.left = `${anchorX - containerRect.x - WIDGET_CONTAINER_WIDTH}px`;

        if (this._scrollableElement) {
            this.smoothScrollOnDrag && this.smoothScrollOnDrag.destroy();
            // TODO: This should be made more generic, one hook for the entire
            // editable with each element handled.
            this.smoothScrollOnDrag = useNativeDraggable(simpleDraggableHook, {
                ref: { el: this._widgetContainer },
                elements: ".oe-sidewidget-move",
                onDragStart: () => this._startDropzones(movableElement, containerRect),
                onDragEnd: () => this._stopDropzones(movableElement),
                helper: () => {
                    const container = document.createElement('div');
                    container.append(movableElement.cloneNode(true));
                    const style = getComputedStyle(movableElement);
                    container.style.height = style.height;
                    container.style.width = style.width;
                    container.style.paddingLeft = '25px';
                    container.style.opacity = '0.4';
                    this._dragHelperContainer.append(container);
                    return container;
                }
            });
        }
    }
    _removeMoveWidget() {
        this._editor.enableAvatars();
        this._moveWidget?.remove();
        this._moveWidget = undefined;
        this._currentMovableElement = undefined;
    }
    _startDropzones(movableElement, containerRect, directions = ['north', 'south']) {
        this._removeMoveWidget();
        const elements = this._getDroppableElements(movableElement);

        this._dropzonesContainer.replaceChildren();
        this._editable.classList.add('oe-editor-dragging');

        for (const element of elements) {
            const originalRect = element.getBoundingClientRect();
            const style = getComputedStyle(element);
            const marginTop = parseInt(style.marginTop, 10);
            const marginBottom = parseInt(style.marginBottom, 10);
            const marginLeft = parseInt(style.marginLeft, 10);
            const marginRight = parseInt(style.marginRight, 10);

            const dropzoneRect = new DOMRect(
                originalRect.left - marginLeft - WIDGET_CONTAINER_WIDTH,
                originalRect.top - marginTop,
                originalRect.width + marginLeft + marginRight + WIDGET_CONTAINER_WIDTH,
                originalRect.height + marginTop + marginBottom,
            );
            const dropzoneHintRect = new DOMRect(
                originalRect.left - marginLeft,
                originalRect.top - marginTop,
                originalRect.width + marginLeft + marginRight,
                originalRect.height + marginTop + marginBottom,
            );

            const dropzoneBox = document.createElement('div');
            dropzoneBox.className = `oe-dropzone-box`;
            dropzoneBox.style.top = `${dropzoneRect.top - containerRect.top}px`;
            dropzoneBox.style.left = `${dropzoneRect.left - containerRect.left}px`;
            dropzoneBox.style.width = `${dropzoneRect.width}px`;
            dropzoneBox.style.height = `${dropzoneRect.height}px`;

            const dropzoneHintBox = document.createElement('div');
            dropzoneHintBox.className = `oe-dropzone-box`;
            dropzoneHintBox.style.top = `${dropzoneHintRect.top - containerRect.top}px`;
            dropzoneHintBox.style.left = `${dropzoneHintRect.left - containerRect.left}px`;
            dropzoneHintBox.style.width = `${dropzoneHintRect.width}px`;
            dropzoneHintBox.style.height = `${dropzoneHintRect.height}px`;

            const sideElements = {};
            for (const direction of directions) {
                const sideElement = document.createElement('div');
                sideElement.className = `oe-dropzone-box-side oe-dropzone-box-side-${direction}`;
                sideElements[direction] = sideElement;
                dropzoneBox.append(sideElement);
                sideElement.addEventListener('mouseenter', () => {
                    this._currentZone = [direction];

                    removeDropHint();
                    this._currentDropHint = document.createElement('div');
                    this._currentDropHint.className = `oe-current-drop-hint`;
                    const currentDropHintSize = 4;
                    const currentDropHintSizeHalf = currentDropHintSize / 2;

                    if (direction === 'north') {
                        this._currentDropHint.style['top'] = `-${currentDropHintSizeHalf}px`;
                        this._currentDropHint.style['width'] = `100%`;
                        this._currentDropHint.style['height'] = `${currentDropHintSize}px`;
                        dropzoneHintBox.append(this._currentDropHint);
                        this._currentDropHintElementPosition = ['top', element];
                    } else if (direction === 'south') {
                        this._currentDropHint.style['bottom'] = `-${currentDropHintSizeHalf}px`;
                        this._currentDropHint.style['width'] = `100%`;
                        this._currentDropHint.style['height'] = `${currentDropHintSize}px`;
                        dropzoneHintBox.append(this._currentDropHint);
                        this._currentDropHintElementPosition = ['bottom', element];
                    } else if (direction === 'west') {
                        this._currentDropHint.style['left'] = `-${currentDropHintSizeHalf}px`;
                        this._currentDropHint.style['height'] = `100%`;
                        this._currentDropHint.style['width'] = `${currentDropHintSize}px`;
                        dropzoneHintBox.append(this._currentDropHint);
                        this._currentDropHintElementPosition = ['left', element];
                    } else if (direction === 'east') {
                        this._currentDropHint.style['right'] = `-${currentDropHintSizeHalf}px`;
                        this._currentDropHint.style['height'] = `100%`;
                        this._currentDropHint.style['width'] = `${currentDropHintSize}px`;
                        dropzoneHintBox.append(this._currentDropHint);
                        this._currentDropHintElementPosition = ['right', element];
                    }
                });
                const removeDropHint = () => {
                    if (this._currentDropHint) {
                        this._currentDropHint.remove();
                        this._currentDropHint = null;
                    }
                    this._currentDropHintCommand = null;
                }
                dropzoneBox.addEventListener('mouseleave', removeDropHint);
            }

            this._dropzonesContainer.append(dropzoneBox);
            this._dropzoneHintContainer.append(dropzoneHintBox);
        }
    }
    _stopDropzones(movableElement) {
        this._editable.classList.remove('oe-editor-dragging');
        this._dropzonesContainer.replaceChildren();
        this._dropzoneHintContainer.replaceChildren();

        if (this._currentDropHintElementPosition) {
            const [position, focusElelement] = this._currentDropHintElementPosition;
            this._currentDropHintElementPosition = undefined;
            const previousParent = movableElement.parentElement;
            if (position === 'top') {
                focusElelement.before(movableElement);
            } else if (position === 'bottom') {
                focusElelement.after(movableElement);
            }
            if (previousParent.innerHTML.trim() === '') {
                const p = document.createElement('p');
                const br = document.createElement('br');
                p.append(br);
                previousParent.append(p);
            }
            setSelection(
                movableElement,
                movableElement.childNodes.length
            );
            resetOuids(movableElement);
            this._editor.historyStep();
        }
    }
    _onMousemove(e) {
        this._updateAnchorWidgets(e.target);
    }
    _onDocumentKeydown() {
        // Hide the move widget upon keystroke for visual clarity and provide
        // visibility to a collaborative avatar.
        this._removeMoveWidget();
    }
    _onDocumentMousemove(e) {
        if(this._resetHooksNextMousemove) {
            this._resetHooksNextMousemove = false;
            this._removeMoveWidget();
            this._updateHooks();
        }
        if (this._editableRect && !isPointInside(this._editableRect, e.clientX, e.clientY)) {
            this._removeMoveWidget();
        }
    }
}

function isNodeMovable(node) {
    return node.parentElement?.getAttribute('contentEditable') === 'true' && !node.parentElement.closest('.o_editor_banner');
}

function isPointInside(rect, x, y) {
    return rect.left <= x &&
        rect.right >= x &&
        rect.top <= y &&
        rect.bottom >= y;
};

return __exports;
});
;

/**************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/PeerToPeer.js  *
*  Lines: 679                                                 *
**************************************************************/
odoo.define('@web_editor/js/wysiwyg/PeerToPeer', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const urlParams = new URLSearchParams(window.location.search);
const collaborationDebug = urlParams.get('collaborationDebug');
const COLLABORATION_LOCALSTORAGE_KEY = 'odoo_editor_collaboration_debug';
if (typeof collaborationDebug === 'string') {
    if (collaborationDebug === 'false') {
        localStorage.removeItem(
            COLLABORATION_LOCALSTORAGE_KEY,
            urlParams.get('collaborationDebug'),
        );
    } else {
        localStorage.setItem(COLLABORATION_LOCALSTORAGE_KEY, urlParams.get('collaborationDebug'));
    }
}
const debugValue = localStorage.getItem(COLLABORATION_LOCALSTORAGE_KEY);

const debugShowLog = ['', 'true', 'all'].includes(debugValue);
const debugShowNotifications = debugValue === 'all';

const baseNotificationMethods = {
    ptp_request: async function(notification) {
        const { requestId, requestName, requestPayload, requestTransport } =
            notification.notificationPayload;
        this._onRequest(
            notification.fromClientId,
            requestId,
            requestName,
            requestPayload,
            requestTransport,
        );
    },
    ptp_request_result: function(notification) {
        const { requestId, result } = notification.notificationPayload;
        // If not in _pendingRequestResolver, it means it has timeout.
        if (this._pendingRequestResolver[requestId]) {
            clearTimeout(this._pendingRequestResolver[requestId].rejectTimeout);
            this._pendingRequestResolver[requestId].resolve(result);
            delete this._pendingRequestResolver[requestId];
        }
    },

    ptp_join: async function (notification) {
        const clientId = notification.fromClientId;
        if (this.clientsInfos[clientId] && this.clientsInfos[clientId].peerConnection) {
            return this.clientsInfos[clientId];
        }
        this._createClient(clientId);
    },

    rtc_signal_icecandidate: async function (notification) {
        if (debugShowLog) console.log(`%creceive candidate`, 'background: darkgreen; color: white;');
        const clientInfos = this.clientsInfos[notification.fromClientId];
        if (
            !clientInfos ||
            !clientInfos.peerConnection ||
            clientInfos.peerConnection.connectionState === 'closed'
        ) {
            console.groupCollapsed('=== ERROR: Handle Ice Candidate from undefined|closed ===');
            console.trace(clientInfos);
            console.groupEnd();
            return;
        }
        if (!clientInfos.peerConnection.remoteDescription) {
            clientInfos.iceCandidateBuffer.push(notification.notificationPayload);
        } else {
            this._addIceCandidate(clientInfos, notification.notificationPayload);
        }
    },
    rtc_signal_description: async function (notification) {
        const description = notification.notificationPayload;
        if (debugShowLog)
            console.log(
                `%cdescription received:`,
                'background: blueviolet; color: white;',
                description,
            );

        const clientInfos =
            this.clientsInfos[notification.fromClientId] ||
            this._createClient(notification.fromClientId);
        const pc = clientInfos.peerConnection;

        if (!pc || pc.connectionState === 'closed') {
            if (debugShowLog) {
                console.groupCollapsed('=== ERROR: handle offer ===');
                console.log(
                    'An offer has been received for a non-existent peer connection - client: ' +
                        notification.fromClientId,
                );
                console.trace(pc && pc.connectionState);
                console.groupEnd();
            }
            return;
        }

        // Skip if we already have an offer.
        if (pc.signalingState === 'have-remote-offer') {
            return;
        }

        // If there is a racing conditing with the signaling offer (two
        // being sent at the same time). We need one client that abort by
        // rollbacking to a stable signaling state where the other is
        // continuing the process. The client that is polite is the one that
        // will rollback.
        const isPolite =
            ('' + notification.fromClientId).localeCompare('' + this._currentClientId) === 1;
        if (debugShowLog)
            console.log(
                `%cisPolite: %c${isPolite}`,
                'background: deepskyblue;',
                `background:${isPolite ? 'green' : 'red'}`,
            );

        const isOfferRacing =
            description.type === 'offer' &&
            (clientInfos.makingOffer || pc.signalingState !== 'stable');
        // If there is a racing conditing with the signaling offer and the
        // client is impolite, we must not process this offer and wait for
        // the answer for the signaling process to continue.
        if (isOfferRacing && !isPolite) {
            if (debugShowLog)
                console.log(
                    `%creturn because isOfferRacing && !isPolite. pc.signalingState: ${pc.signalingState}`,
                    'background: red;',
                );
            return;
        }
        if (debugShowLog) {
            console.log(`%cisOfferRacing: ${isOfferRacing}`, 'background: red;');
            console.log(`%c SETREMOTEDESCRIPTION`, 'background: navy; color:white;');
        }
        try {
            await pc.setRemoteDescription(description);
        } catch (e) {
            if (e instanceof DOMException && e.name === 'InvalidStateError') {
                console.error(e);
                return;
            } else {
                throw e;
            }
        }
        if (clientInfos.iceCandidateBuffer.length) {
            for (const candidate of clientInfos.iceCandidateBuffer) {
                await this._addIceCandidate(clientInfos, candidate);
            }
            clientInfos.iceCandidateBuffer.splice(0);
        }
        if (description.type === 'offer') {
            const answerDescription = await pc.createAnswer();
            try {
                await pc.setLocalDescription(answerDescription);
            } catch (e) {
                if (e instanceof DOMException && e.name === 'InvalidStateError') {
                    console.error(e);
                    return;
                } else {
                    throw e;
                }
            }
            this.notifyClient(
                notification.fromClientId,
                'rtc_signal_description',
                pc.localDescription,
            );
        }
    },
};

const PeerToPeer = __exports.PeerToPeer = class PeerToPeer {
    constructor(options) {
        this.options = options;
        this._currentClientId = this.options.currentClientId;
        if (debugShowLog)
            console.log(
                `%c currentClientId:${this._currentClientId}`,
                'background: blue; color: white;',
            );

        // clientId -> ClientInfos
        this.clientsInfos = {};
        this._lastRequestId = -1;
        this._pendingRequestResolver = {};
        this._stopped = false;
    }

    stop() {
        this.closeAllConnections();
        this._stopped = true;
    }

    getConnectedClientIds() {
        return Object.entries(this.clientsInfos)
            .filter(
                ([id, infos]) =>
                    infos.peerConnection && infos.peerConnection.iceConnectionState === 'connected' &&
                    infos.dataChannel && infos.dataChannel.readyState === 'open',
            )
            .map(([id]) => id);
    }

    removeClient(clientId) {
        if (debugShowLog) console.log(`%c REMOVE CLIENT ${clientId}`, 'background: chocolate;');
        this.notifySelf('ptp_remove', clientId);
        const clientInfos = this.clientsInfos[clientId];
        if (!clientInfos) return;
        clearTimeout(clientInfos.fallbackTimeout);
        clearTimeout(clientInfos.zombieTimeout);
        clientInfos.dataChannel && clientInfos.dataChannel.close();
        clientInfos.peerConnection && clientInfos.peerConnection.close();
        delete this.clientsInfos[clientId];
    }

    closeAllConnections() {
        for (const clientId of Object.keys(this.clientsInfos)) {
            this.notifyAllClients('ptp_disconnect');
            this.removeClient(clientId);
        }
    }

    async notifyAllClients(notificationName, notificationPayload, { transport = 'server' } = {}) {
        if (this._stopped) {
            return;
        }
        const transportPayload = {
            fromClientId: this._currentClientId,
            notificationName,
            notificationPayload,
        };
        if (transport === 'server') {
            await this.options.broadcastAll(transportPayload);
        } else if (transport === 'rtc') {
            for (const cliendId of Object.keys(this.clientsInfos)) {
                this._channelNotify(cliendId, transportPayload);
            }
        } else {
            throw new Error(
                `Transport "${transport}" is not supported. Use "server" or "rtc" transport.`,
            );
        }
    }

    notifyClient(clientId, notificationName, notificationPayload, { transport = 'server' } = {}) {
        if (this._stopped) {
            return;
        }
        if (debugShowNotifications) {
            if (notificationName === 'ptp_request_result') {
                console.log(
                    `%c${Date.now()} - REQUEST RESULT SEND: %c${transport}:${
                        notificationPayload.requestId
                    }:${this._currentClientId.slice('-5')}:${clientId.slice('-5')}`,
                    'color: #aaa;font-weight:bold;',
                    'color: #aaa;font-weight:normal',
                );
            } else if (notificationName === 'ptp_request') {
                console.log(
                    `%c${Date.now()} - REQUEST SEND: %c${transport}:${
                        notificationPayload.requestName
                    }|${notificationPayload.requestId}:${this._currentClientId.slice(
                        '-5',
                    )}:${clientId.slice('-5')}`,
                    'color: #aaa;font-weight:bold;',
                    'color: #aaa;font-weight:normal',
                );
            } else {
                console.log(
                    `%c${Date.now()} - NOTIFICATION SEND: %c${transport}:${notificationName}:${this._currentClientId.slice(
                        '-5',
                    )}:${clientId.slice('-5')}`,
                    'color: #aaa;font-weight:bold;',
                    'color: #aaa;font-weight:normal',
                );
            }
        }
        const transportPayload = {
            fromClientId: this._currentClientId,
            toClientId: clientId,
            notificationName,
            notificationPayload,
        };
        if (transport === 'server') {
            this.options.broadcastAll(transportPayload);
        } else if (transport === 'rtc') {
            this._channelNotify(clientId, transportPayload);
        } else {
            throw new Error(
                `Transport "${transport}" is not supported. Use "server" or "rtc" transport.`,
            );
        }
    }

    notifySelf(notificationName, notificationPayload) {
        if (this._stopped) {
            return;
        }
        return this.handleNotification({ notificationName, notificationPayload });
    }

    handleNotification(notification) {
        if (this._stopped) {
            return;
        }
        const isInternalNotification =
            typeof notification.fromClientId === 'undefined' &&
            typeof notification.toClientId === 'undefined';
        if (
            isInternalNotification ||
            (notification.fromClientId !== this._currentClientId && !notification.toClientId) ||
            notification.toClientId === this._currentClientId
        ) {
            if (debugShowNotifications) {
                if (notification.notificationName === 'ptp_request_result') {
                    console.log(
                        `%c${Date.now()} - REQUEST RESULT RECEIVE: %c${
                            notification.notificationPayload.requestId
                        }:${notification.fromClientId.slice('-5')}:${notification.toClientId.slice(
                            '-5',
                        )}`,
                        'color: #aaa;font-weight:bold;',
                        'color: #aaa;font-weight:normal',
                    );
                } else if (notification.notificationName === 'ptp_request') {
                    console.log(
                        `%c${Date.now()} - REQUEST RECEIVE: %c${
                            notification.notificationPayload.requestName
                        }|${
                            notification.notificationPayload.requestId
                        }:${notification.fromClientId.slice('-5')}:${notification.toClientId.slice(
                            '-5',
                        )}`,
                        'color: #aaa;font-weight:bold;',
                        'color: #aaa;font-weight:normal',
                    );
                } else {
                    console.log(
                        `%c${Date.now()} - NOTIFICATION RECEIVE: %c${
                            notification.notificationName
                        }:${notification.fromClientId}:${notification.toClientId}`,
                        'color: #aaa;font-weight:bold;',
                        'color: #aaa;font-weight:normal',
                    );
                }
            }
            try {
                const baseMethod = baseNotificationMethods[notification.notificationName];
                if (baseMethod) {
                    return baseMethod.call(this, notification);
                }
                if (this.options.onNotification) {
                    return this.options.onNotification(notification);
                }
            } catch (error) {
                console.groupCollapsed('=== ERROR: On notification in collaboration ===');
                console.error(error);
                console.groupEnd();
            }
        }
    }

    requestClient(clientId, requestName, requestPayload, { transport = 'server' } = {}) {
        if (this._stopped) {
            return;
        }
        return new Promise((resolve, reject) => {
            const requestId = this._getRequestId();

            const abort = (reason) => {
                clearTimeout(rejectTimeout);
                delete this._pendingRequestResolver[requestId];
                reject(new RequestError(reason || 'Request was aborted.'));
            };
            const rejectTimeout = setTimeout(
                () => abort('Request took too long (more than 10 seconds).'),
                10000
            );

            this._pendingRequestResolver[requestId] = {
                resolve,
                rejectTimeout,
                abort,
            };

            this.notifyClient(
                clientId,
                'ptp_request',
                {
                    requestId,
                    requestName,
                    requestPayload,
                    requestTransport: transport,
                },
                { transport },
            );
        });
    }
    abortCurrentRequests() {
        for (const { abort } of Object.values(this._pendingRequestResolver)) {
            abort();
        }
    }
    _createClient(clientId, { makeOffer = true } = {}) {
        if (this._stopped) {
            return;
        }
        if (debugShowLog) console.log('CREATE CONNECTION with client id:', clientId);
        this.clientsInfos[clientId] = {
            makingOffer: false,
            iceCandidateBuffer: [],
            backoffFactor: 0,
        };

        if (!navigator.onLine) {
            return this.clientsInfos[clientId];
        }
        const pc = new RTCPeerConnection(this.options.peerConnectionConfig);

        if (makeOffer) {
            pc.onnegotiationneeded = async () => {
                if (debugShowLog)
                    console.log(
                        `%c NEGONATION NEEDED: ${pc.connectionState}`,
                        'background: deeppink;',
                    );
                try {
                    this.clientsInfos[clientId].makingOffer = true;
                    if (debugShowLog)
                        console.log(
                            `%ccreating and sending an offer`,
                            'background: darkmagenta; color: white;',
                        );
                    const offer = await pc.createOffer();
                    // Avoid race condition.
                    if (pc.signalingState !== 'stable') {
                        return;
                    }
                    await pc.setLocalDescription(offer);
                    this.notifyClient(clientId, 'rtc_signal_description', pc.localDescription);
                } catch (err) {
                    console.error(err);
                } finally {
                    this.clientsInfos[clientId].makingOffer = false;
                }
            };
        }
        pc.onicecandidate = async event => {
            if (event.candidate) {
                this.notifyClient(clientId, 'rtc_signal_icecandidate', event.candidate);
            }
        };
        pc.oniceconnectionstatechange = async () => {
            if (debugShowLog) console.log('ICE STATE UPDATE: ' + pc.iceConnectionState);

            switch (pc.iceConnectionState) {
                case 'failed':
                case 'closed':
                    this.removeClient(clientId);
                    break;
                case 'disconnected':
                    if (navigator.onLine) {
                        await this._recoverConnection(clientId, {
                            delay: 3000,
                            reason: 'ice connection disconnected',
                        });
                    }
                    break;
                case 'connected':
                    this.clientsInfos[clientId].backoffFactor = 0;
                    break;
            }
        };
        // This event does not work in FF. Let's try with oniceconnectionstatechange if it is sufficient.
        pc.onconnectionstatechange = async () => {
            if (debugShowLog) console.log('CONNECTION STATE UPDATE:' + pc.connectionState);

            switch (pc.connectionState) {
                case 'failed':
                case 'closed':
                    this.removeClient(clientId);
                    break;
                case 'disconnected':
                    if (navigator.onLine) {
                        await this._recoverConnection(clientId, {
                            delay: 3000,
                            reason: 'connection disconnected',
                        });
                    }
                    break;
                case 'connected':
                case 'completed':
                    this.clientsInfos[clientId].backoffFactor = 0;
                    break;
            }
        };
        pc.onicecandidateerror = async error => {
            if (debugShowLog) {
                console.groupCollapsed('=== ERROR: onIceCandidate ===');
                console.log(
                    'connectionState: ' +
                        pc.connectionState +
                        ' - iceState: ' +
                        pc.iceConnectionState,
                );
                console.trace(error);
                console.groupEnd();
            }
            this._recoverConnection(clientId, { delay: 3000, reason: 'ice candidate error' });
        };
        const dataChannel = pc.createDataChannel('notifications', { negotiated: true, id: 1 });
        let message = [];
        dataChannel.onmessage = event => {
            if (event.data !== '-') {
                message.push(event.data);
            } else {
                this.handleNotification(JSON.parse(message.join('')));
                message = [];
            }
        };
        dataChannel.onopen = event => {
            this.notifySelf('rtc_data_channel_open', {
                connectionClientId: clientId,
            });
        };

        this.clientsInfos[clientId].peerConnection = pc;
        this.clientsInfos[clientId].dataChannel = dataChannel;

        return this.clientsInfos[clientId];
    }
    async _addIceCandidate(clientInfos, candidate) {
        const rtcIceCandidate = new RTCIceCandidate(candidate);
        try {
            await clientInfos.peerConnection.addIceCandidate(rtcIceCandidate);
        } catch (error) {
            // Ignored.
            console.groupCollapsed('=== ERROR: ADD ICE CANDIDATE ===');
            console.trace(error);
            console.groupEnd();
        }
    }

    _channelNotify(clientId, transportPayload) {
        if (this._stopped) {
            return;
        }
        const clientInfo = this.clientsInfos[clientId];
        const dataChannel = clientInfo && clientInfo.dataChannel;

        if (!dataChannel || dataChannel.readyState !== 'open') {
            if (clientInfo && !clientInfo.zombieTimeout) {
                if (debugShowLog) console.warn(
                    `Impossible to communicate with client ${clientId}. The connection will be killed in 10 seconds if the datachannel state has not changed.`,
                );
                this._killPotentialZombie(clientId);
            }
        } else {
            const str = JSON.stringify(transportPayload);
            const size = str.length;
            const maxStringLength = 5000;
            let from = 0;
            let to = maxStringLength;
            while (from < size) {
                dataChannel.send(str.slice(from, to));
                from = to;
                to = to += maxStringLength;
            }
            dataChannel.send('-');
        }
    }

    _getRequestId() {
        this._lastRequestId++;
        return this._lastRequestId;
    }

    async _onRequest(fromClientId, requestId, requestName, requestPayload, requestTransport) {
        if (this._stopped) {
            return;
        }
        const requestFunction = this.options.onRequest && this.options.onRequest[requestName];
        const result = await requestFunction({
            fromClientId,
            requestId,
            requestName,
            requestPayload,
        });
        this.notifyClient(
            fromClientId,
            'ptp_request_result',
            { requestId, result },
            { transport: requestTransport },
        );
    }
    /**
     * Attempts a connection recovery by updating the tracks, which will start
     * a new transaction: negotiationneeded -> offer -> answer -> ...
     *
     * @private
     * @param {Object} [param1]
     * @param {number} [param1.delay] in ms
     * @param {string} [param1.reason]
     */
    _recoverConnection(clientId, { delay = 0, reason = '' } = {}) {
        if (this._stopped) {
            this.removeClient(clientId);
            return;
        }
        const clientInfos = this.clientsInfos[clientId];
        if (!clientInfos || clientInfos.fallbackTimeout) return;
        const backoffFactor = this.clientsInfos[clientId].backoffFactor;
        const backoffDelay = delay * Math.pow(2, backoffFactor);
        // Stop trying to recover the connection after 10 attempts.
        if (backoffFactor > 10) {
            if (debugShowLog) {
                console.log(
                    `%c STOP RTC RECOVERY: impossible to connect to client ${clientId}: ${reason}`,
                    'background: darkred; color: white;',
                );
            }
            return;
        }

        clientInfos.fallbackTimeout = setTimeout(async () => {
            clientInfos.fallbackTimeout = undefined;
            const pc = clientInfos.peerConnection;
            if (!pc || pc.iceConnectionState === 'connected') {
                return;
            }
            if (['connected', 'closed'].includes(pc.connectionState)) {
                return;
            }
            // hard reset: recreating a RTCPeerConnection
            if (debugShowLog)
                console.log(
                    `%c RTC RECOVERY: calling back client ${clientId} to salvage the connection ${pc.iceConnectionState} after ${backoffDelay}ms, reason: ${reason}`,
                    'background: darkorange; color: white;',
                );
            this.removeClient(clientId);
            const newClientInfos = this._createClient(clientId);
            newClientInfos.backoffFactor = backoffFactor + 1;
        }, backoffDelay);
    }
    // todo: do we try to salvage the connection after killing the zombie ?
    // Maybe the salvage should be done when the connection is dropped.
    _killPotentialZombie(clientId) {
        if (this._stopped) {
            this.removeClient(clientId);
            return;
        }
        const clientInfos = this.clientsInfos[clientId];
        if (!clientInfos || clientInfos.zombieTimeout) {
            return;
        }

        // If there is no connection after 10 seconds, terminate.
        clientInfos.zombieTimeout = setTimeout(() => {
            if (clientInfos && clientInfos.dataChannel && clientInfos.dataChannel.readyState !== 'open') {
                if (debugShowLog) console.log(`%c KILL ZOMBIE ${clientId}`, 'background: red;');
                this.removeClient(clientId);
            } else {
                if (debugShowLog) console.log(`%c NOT A ZOMBIE ${clientId}`, 'background: green;');
            }
        }, 10000);
    }
}

const RequestError = __exports.RequestError = class RequestError extends Error {
  constructor(message) {
    super(message);
    this.name = "RequestError";
  }
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/conflict_dialog.js  *
*  Lines: 16                                                       *
*******************************************************************/
odoo.define('@web_editor/js/wysiwyg/conflict_dialog', ['@odoo/owl', '@web/core/dialog/dialog'], function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { Component } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");

const ConflictDialog = __exports.ConflictDialog = class ConflictDialog extends Component {
    static components = { Dialog };
    static props = ["close","content"];
    static template = 'web_editor.ConflictDialog';
}

return __exports;
});
;

/*************************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/get_color_picker_template_service.js  *
*  Lines: 27                                                                         *
*************************************************************************************/
odoo.define('@web_editor/js/wysiwyg/get_color_picker_template_service', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};

/** @odoo-module **/
const { registry } = require("@web/core/registry");

let colorPickerTemplatePromise;
const getColorPickerTemplateService = __exports.getColorPickerTemplateService = {
    dependencies: ["orm"],
    async: true,
    start(env, { orm }) {
        return () => {
            colorPickerTemplatePromise ??= orm.call(
                'ir.ui.view',
                'render_public_asset',
                ['web_editor.colorpicker', {}]
            );
            return colorPickerTemplatePromise;
        };
    },
};

registry.category("services").add("get_color_picker_template", getColorPickerTemplateService);

return __exports;
});
;

/********************************************************************
*  Filepath: /web_editor/static/src/js/editor/perspective_utils.js  *
*  Lines: 104                                                       *
********************************************************************/
odoo.define('@web_editor/js/editor/perspective_utils', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

/**
 * Transform a 2D point using a projective transformation matrix. Note that
 * this method is only well behaved for points that don't map to infinity!
 *
 * @param {number[][]} matrix - A projective transformation matrix
 * @param {number[]} point - A 2D point
 * @returns The transformed 2D point
 */
__exports.transform = transform; function transform([[a, b, c], [d, e, f], [g, h, i]], [x, y]) {
    let z = g * x + h * y + i;
    return [(a * x + b * y + c) / z, (d * x + e * y + f) / z];
}

/**
 * Calculate the inverse of a 3x3 matrix assuming it is invertible.
 *
 * @param {number[][]} matrix - A 3x3 matrix
 * @returns The resulting 3x3 matrix
 */
function invert([[a, b, c], [d, e, f], [g, h, i]]) {
    const determinant = a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    return [
        [(e * i - h * f) / determinant, (h * c - b * i) / determinant, (b * f - e * c) / determinant],
        [(g * f - d * i) / determinant, (a * i - g * c) / determinant, (d * c - a * f) / determinant],
        [(d * h - g * e) / determinant, (g * b - a * h) / determinant, (a * e - d * b) / determinant],
    ];
}

/**
 * Multiply two 3x3 matrices.
 *
 * @param {number[][]} a - A 3x3 matrix
 * @param {number[][]} b - A 3x3 matrix
 * @returns The resulting 3x3 matrix
 */
function multiply(a, b) {
    const [[a0, a1, a2], [a3, a4, a5], [a6, a7, a8]] = a;
    const [[b0, b1, b2], [b3, b4, b5], [b6, b7, b8]] = b;
    return [
        [a0 * b0 + a1 * b3 + a2 * b6, a0 * b1 + a1 * b4 + a2 * b7, a0 * b2 + a1 * b5 + a2 * b8],
        [a3 * b0 + a4 * b3 + a5 * b6, a3 * b1 + a4 * b4 + a5 * b7, a3 * b2 + a4 * b5 + a5 * b8],
        [a6 * b0 + a7 * b3 + a8 * b6, a6 * b1 + a7 * b4 + a8 * b7, a6 * b2 + a7 * b5 + a8 * b8],
    ];
}

/**
 * Find a projective transformation mapping a rectangular area at origin (0,0)
 * with a given width and height to a certain quadrilateral.
 *
 * @param {number} width - The width of the rectangular area
 * @param {number} height - The height of the rectangular area
 * @param {number[][]} quadrilateral - The vertices of the quadrilateral
 * @returns A projective transformation matrix
 */
__exports.getProjective = getProjective; function getProjective(width, height, [[x0, y0], [x1, y1], [x2, y2], [x3, y3]]) {
    // Calculate a set of homogeneous coordinates a, b, c of the first
    // point using the other three points as basis vectors in the
    // underlying vector space.
    const denominator = x3 * (y1 - y2) + x1 * (y2 - y3) + x2 * (y3 - y1);
    const a = (x0 * (y2 - y3) + x2 * (y3 - y0) + x3 * (y0 - y2)) / denominator;
    const b = (x0 * (y3 - y1) + x3 * (y1 - y0) + x1 * (y0 - y3)) / denominator;
    const c = (x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) / denominator;

    // The reverse transformation maps the homogeneous coordinates of
    // the last three corners of the original image onto the basis vectors
    // while mapping the first corner onto (1, 1, 1). The forward
    // transformation maps those basis vectors in addition to (1, 1, 1)
    // onto homogeneous coordinates of the corresponding corners of the
    // projective image. Combining these together yields the projective
    // transformation we are looking for.
    const reverse = invert([[width, -width, 0], [0, -height, height], [1, -1, 1]]);
    const forward = [[a * x1, b * x2, c * x3], [a * y1, b * y2, c * y3], [a, b, c]];

    return multiply(forward, reverse);
}

/**
 * Find an affine transformation matrix that exactly maps the vertices of a
 * triangle to their corresponding images of a projective transformation. The
 * resulting transformation will be an approximation of the projective
 * transformation for the area inside the triangle.
 *
 * @param {number[][]} projective - A projective transformation matrix
 * @param {number[][]} triangle - The vertices of a triangle
 * @returns - An affine transformation matrix
 */
__exports.getAffineApproximation = getAffineApproximation; function getAffineApproximation(projective, [[x0, y0], [x1, y1], [x2, y2]]) {
    const a = transform(projective, [x0, y0]);
    const b = transform(projective, [x1, y1]);
    const c = transform(projective, [x2, y2]);

    return multiply(
        [[a[0], b[0], c[0]], [a[1], b[1], c[1]], [1, 1, 1]],
        invert([[x0, x1, x2], [y0, y1, y2], [1, 1, 1]]),
    );
}

return __exports;
});
;

/*******************************************************************
*  Filepath: /web_editor/static/src/js/editor/image_processing.js  *
*  Lines: 623                                                      *
*******************************************************************/
odoo.define('@web_editor/js/editor/image_processing', ['@web/core/utils/objects', '@web_editor/js/editor/perspective_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { pick } = require("@web/core/utils/objects");
const {getAffineApproximation, getProjective} = require("@web_editor/js/editor/perspective_utils");

// Fields returned by cropperjs 'getData' method, also need to be passed when
// initializing the cropper to reuse the previous crop.
const cropperDataFields = __exports.cropperDataFields = ['x', 'y', 'width', 'height', 'rotate', 'scaleX', 'scaleY'];
const modifierFields = [
    'filter',
    'quality',
    'mimetype',
    'glFilter',
    'originalId',
    'originalSrc',
    'resizeWidth',
    'aspectRatio',
    "bgSrc",
    "mimetypeBeforeConversion",
];
const isGif = __exports.isGif = (mimetype) => mimetype === 'image/gif';

// webgl color filters
const _applyAll = (result, filter, filters) => {
    filters.forEach(f => {
        if (f[0] === 'blend') {
            const cv = f[1];
            const ctx = result.getContext('2d');
            ctx.globalCompositeOperation = f[2];
            ctx.globalAlpha = f[3];
            ctx.drawImage(cv, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
        } else {
            filter.addFilter(...f);
        }
    });
};
let applyAll;

const glFilters = {
    blur: filter => filter.addFilter('blur', 10),

    '1977': (filter, cv) => {
        const ctx = cv.getContext('2d');
        ctx.fillStyle = 'rgb(243, 106, 188)';
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'screen', .3],
            ['brightness', .1],
            ['contrast', .1],
            ['saturation', .3],
        ]);
    },

    aden: (filter, cv) => {
        const ctx = cv.getContext('2d');
        ctx.fillStyle = 'rgb(66, 10, 14)';
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'darken', .2],
            ['brightness', .2],
            ['contrast', -.1],
            ['saturation', -.15],
            ['hue', 20],
        ]);
    },

    brannan: (filter, cv) => {
        const ctx = cv.getContext('2d');
        ctx.fillStyle = 'rgb(161, 44, 191)';
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'lighten', .31],
            ['sepia', .5],
            ['contrast', .4],
        ]);
    },

    earlybird: (filter, cv) => {
        const ctx = cv.getContext('2d');
        const gradient = ctx.createRadialGradient(
            cv.width / 2, cv.height / 2, 0,
            cv.width / 2, cv.height / 2, Math.hypot(cv.width, cv.height) / 2
        );
        gradient.addColorStop(.2, '#D0BA8E');
        gradient.addColorStop(1, '#1D0210');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'overlay', .2],
            ['sepia', .2],
            ['contrast', -.1],
        ]);
    },

    inkwell: (filter, cv) => {
        applyAll(filter, [
            ['sepia', .3],
            ['brightness', .1],
            ['contrast', -.1],
            ['desaturateLuminance'],
        ]);
    },

    // Needs hue blending mode for perfect reproduction. Close enough?
    maven: (filter, cv) => {
        applyAll(filter, [
            ['sepia', .25],
            ['brightness', -.05],
            ['contrast', -.05],
            ['saturation', .5],
        ]);
    },

    toaster: (filter, cv) => {
        const ctx = cv.getContext('2d');
        const gradient = ctx.createRadialGradient(
            cv.width / 2, cv.height / 2, 0,
            cv.width / 2, cv.height / 2, Math.hypot(cv.width, cv.height) / 2
        );
        gradient.addColorStop(0, '#0F4E80');
        gradient.addColorStop(1, '#3B003B');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'screen', .5],
            ['brightness', -.1],
            ['contrast', .5],
        ]);
    },

    walden: (filter, cv) => {
        const ctx = cv.getContext('2d');
        ctx.fillStyle = '#CC4400';
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'screen', .3],
            ['sepia', .3],
            ['brightness', .1],
            ['saturation', .6],
            ['hue', 350],
        ]);
    },

    valencia: (filter, cv) => {
        const ctx = cv.getContext('2d');
        ctx.fillStyle = '#3A0339';
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'exclusion', .5],
            ['sepia', .08],
            ['brightness', .08],
            ['contrast', .08],
        ]);
    },

    xpro: (filter, cv) => {
        const ctx = cv.getContext('2d');
        const gradient = ctx.createRadialGradient(
            cv.width / 2, cv.height / 2, 0,
            cv.width / 2, cv.height / 2, Math.hypot(cv.width, cv.height) / 2
        );
        gradient.addColorStop(.4, '#E0E7E6');
        gradient.addColorStop(1, '#2B2AA1');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, cv.width, cv.height);
        applyAll(filter, [
            ['blend', cv, 'color-burn', .7],
            ['sepia', .3],
        ]);
    },

    custom: (filter, cv, filterOptions) => {
        const options = Object.assign({
            blend: 'normal',
            filterColor: '',
            blur: '0',
            desaturateLuminance: '0',
            saturation: '0',
            contrast: '0',
            brightness: '0',
            sepia: '0',
        }, JSON.parse(filterOptions || "{}"));
        const filters = [];
        if (options.filterColor) {
            const ctx = cv.getContext('2d');
            ctx.fillStyle = options.filterColor;
            ctx.fillRect(0, 0, cv.width, cv.height);
            filters.push(['blend', cv, options.blend, 1]);
        }
        delete options.blend;
        delete options.filterColor;
        filters.push(...Object.entries(options).map(([filter, amount]) => [filter, parseInt(amount) / 100]));
        applyAll(filter, filters);
    },
};
/**
 * Applies data-attributes modifications to an img tag and returns a dataURL
 * containing the result. This function does not modify the original image.
 *
 * @param {HTMLImageElement} img the image to which modifications are applied
 * @returns {string} dataURL of the image with the applied modifications
 */
__exports.applyModifications = applyModifications; async function applyModifications(img, dataOptions = {}) {
    const data = Object.assign({
        glFilter: '',
        filter: '#0000',
        quality: '75',
        forceModification: false,
    }, img.dataset, dataOptions);
    let {
        width,
        height,
        resizeWidth,
        quality,
        filter,
        mimetype,
        originalSrc,
        glFilter,
        filterOptions,
        forceModification,
        perspective,
        svgAspectRatio,
        imgAspectRatio,
    } = data;
    [width, height, resizeWidth] = [width, height, resizeWidth].map(s => parseFloat(s));
    quality = parseInt(quality);

    // Skip modifications (required to add shapes on animated GIFs).
    if (isGif(mimetype) && !forceModification) {
        return await _loadImageDataURL(originalSrc);
    }

    // Crop
    const container = document.createElement('div');
    const original = await loadImage(originalSrc);
    // loadImage may have ended up loading a different src (see: LOAD_IMAGE_404)
    originalSrc = original.getAttribute('src');
    container.appendChild(original);
    await activateCropper(original, 0, data);
    let croppedImg = $(original).cropper('getCroppedCanvas', {width, height});
    $(original).cropper('destroy');

    // Aspect Ratio
    if (imgAspectRatio) {
        document.createElement('div').appendChild(croppedImg);
        imgAspectRatio = imgAspectRatio.split(':');
        imgAspectRatio = parseFloat(imgAspectRatio[0]) / parseFloat(imgAspectRatio[1]);
        await activateCropper(croppedImg, imgAspectRatio, {y: 0});
        croppedImg = $(croppedImg).cropper('getCroppedCanvas');
        $(croppedImg).cropper('destroy');
    }

    // Width
    const result = document.createElement('canvas');
    result.width = resizeWidth || croppedImg.width;
    result.height = perspective ? result.width / svgAspectRatio : croppedImg.height * result.width / croppedImg.width;
    const ctx = result.getContext('2d');
    ctx.imageSmoothingQuality = "high";
    ctx.mozImageSmoothingEnabled = true;
    ctx.webkitImageSmoothingEnabled = true;
    ctx.msImageSmoothingEnabled = true;
    ctx.imageSmoothingEnabled = true;

    // Perspective 3D
    if (perspective) {
        // x, y coordinates of the corners of the image as a percentage
        // (relative to the width or height of the image) needed to apply
        // the 3D effect.
        const points = JSON.parse(perspective);
        const divisions = 10;
        const w = croppedImg.width, h = croppedImg.height;

        const project = getProjective(w, h, [
            [(result.width / 100) * points[0][0], (result.height / 100) * points[0][1]], // Top-left [x, y]
            [(result.width / 100) * points[1][0], (result.height / 100) * points[1][1]], // Top-right [x, y]
            [(result.width / 100) * points[2][0], (result.height / 100) * points[2][1]], // bottom-right [x, y]
            [(result.width / 100) * points[3][0], (result.height / 100) * points[3][1]], // bottom-left [x, y]
        ]);

        for (let i = 0; i < divisions; i++) {
            for (let j = 0; j < divisions; j++) {
                const [dx, dy] = [w / divisions, h / divisions];

                const upper = {origin: [i * dx, j * dy], sides: [dx, dy], flange: 0.1, overlap: 0};
                const lower = {origin: [i * dx + dx, j * dy + dy], sides: [-dx, -dy], flange: 0, overlap: 0.1};

                for (let {origin, sides, flange, overlap} of [upper, lower]) {
                    const [[a, c, e], [b, d, f]] = getAffineApproximation(project, [
                        origin, [origin[0] + sides[0], origin[1]], [origin[0], origin[1] + sides[1]]
                    ]);

                    const ox = (i !== divisions ? overlap * sides[0] : 0) + flange * sides[0];
                    const oy = (j !== divisions ? overlap * sides[1] : 0) + flange * sides[1];

                    origin[0] += flange * sides[0];
                    origin[1] += flange * sides[1];

                    sides[0] -= flange * sides[0];
                    sides[1] -= flange * sides[1];

                    ctx.save();
                    ctx.setTransform(a, b, c, d, e, f);

                    ctx.beginPath();
                    ctx.moveTo(origin[0] - ox, origin[1] - oy);
                    ctx.lineTo(origin[0] + sides[0], origin[1] - oy);
                    ctx.lineTo(origin[0] + sides[0], origin[1]);
                    ctx.lineTo(origin[0], origin[1] + sides[1]);
                    ctx.lineTo(origin[0] - ox, origin[1] + sides[1]);
                    ctx.closePath();
                    ctx.clip();
                    ctx.drawImage(croppedImg, 0, 0);

                    ctx.restore();
                }
            }
        }
    } else {
        ctx.drawImage(croppedImg, 0, 0, croppedImg.width, croppedImg.height, 0, 0, result.width, result.height);
    }

    // GL filter
    if (glFilter) {
        const glf = new window.WebGLImageFilter();
        const cv = document.createElement('canvas');
        cv.width = result.width;
        cv.height = result.height;
        applyAll = _applyAll.bind(null, result);
        glFilters[glFilter](glf, cv, filterOptions);
        const filtered = glf.apply(result);
        ctx.drawImage(filtered, 0, 0, filtered.width, filtered.height, 0, 0, result.width, result.height);
    }

    // Color filter
    ctx.fillStyle = filter || '#0000';
    ctx.fillRect(0, 0, result.width, result.height);

    // Quality
    const dataURL = result.toDataURL(mimetype, quality / 100);
    const newSize = getDataURLBinarySize(dataURL);
    const originalSize = _getImageSizeFromCache(originalSrc);
    const isChanged = !!perspective || !!glFilter ||
        original.width !== result.width || original.height !== result.height ||
        original.width !== croppedImg.width || original.height !== croppedImg.height;
    return (isChanged || originalSize >= newSize) ? dataURL : await _loadImageDataURL(originalSrc);
}

/**
 * Loads an src into an HTMLImageElement.
 *
 * @param {String} src URL of the image to load
 * @param {HTMLImageElement} [img] img element in which to load the image
 * @returns {Promise<HTMLImageElement>} Promise that resolves to the loaded img
 *     or a placeholder image if the src is not found.
 */
__exports.loadImage = loadImage; function loadImage(src, img = new Image()) {
    const handleImage = (source, resolve, reject) => {
        img.addEventListener("load", () => resolve(img), {once: true});
        img.addEventListener("error", reject, {once: true});
        img.src = source;
    };
    // The server will return a placeholder image with the following src.
    // grep: LOAD_IMAGE_404
    const placeholderHref = "/web/image/__odoo__unknown__src__/";

    return new Promise((resolve, reject) => {
        fetch(src)
            .then(response => {
                if (!response.ok) {
                    src = placeholderHref;
                }
                handleImage(src, resolve, reject);
            })
            .catch(error => {
                src = placeholderHref;
                handleImage(src, resolve, reject);
            });
    });
}

// Because cropperjs acquires images through XHRs on the image src and we don't
// want to load big images over the network many times when adjusting quality
// and filter, we create a local cache of the images using object URLs.
const imageCache = new Map();
/**
 * Loads image object URL into cache if not already set and returns it.
 *
 * @param {String} src
 * @returns {Promise}
 */
function _loadImageObjectURL(src) {
    return _updateImageData(src);
}
/**
 * Gets image dataURL from cache in the same way as object URL.
 *
 * @param {String} src
 * @returns {Promise}
 */
function _loadImageDataURL(src) {
    return _updateImageData(src, 'dataURL');
}
/**
 * @param {String} src used as a key on the image cache map.
 * @param {String} [key='objectURL'] specifies the image data to update/return.
 * @returns {Promise<String>} resolves with either dataURL/objectURL value.
 */
async function _updateImageData(src, key = 'objectURL') {
    const currentImageData = imageCache.get(src);
    if (currentImageData && currentImageData[key]) {
        return currentImageData[key];
    }
    let value = '';
    const blob = await fetch(src).then(res => res.blob());
    if (key === 'dataURL') {
        value = await createDataURL(blob);
    } else {
        value = URL.createObjectURL(blob);
    }
    imageCache.set(src, Object.assign(currentImageData || {}, {[key]: value, size: blob.size}));
    return value;
}
/**
 * Returns the size of a cached image.
 * Warning: this supposes that the image is already in the cache, i.e. that
 * _updateImageData was called before.
 *
 * @param {String} src used as a key on the image cache map.
 * @returns {Number} size of the image in bytes.
 */
function _getImageSizeFromCache(src) {
    return imageCache.get(src).size;
}
/**
 * Activates the cropper on a given image.
 *
 * @param {jQuery} $image the image on which to activate the cropper
 * @param {Number} aspectRatio the aspectRatio of the crop box
 * @param {DOMStringMap} dataset dataset containing the cropperDataFields
 */
__exports.activateCropper = activateCropper; async function activateCropper(image, aspectRatio, dataset) {
    const oldSrc = image.src;
    const newSrc = await _loadImageObjectURL(image.getAttribute('src'));
    image.src = newSrc;
    $(image).cropper({
        viewMode: 2,
        dragMode: 'move',
        autoCropArea: 1.0,
        aspectRatio: aspectRatio,
        data: Object.fromEntries(Object.entries(pick(dataset, ...cropperDataFields))
            .map(([key, value]) => [key, parseFloat(value)])),
        // Can't use 0 because it's falsy and cropperjs will then use its defaults (200x100)
        minContainerWidth: 1,
        minContainerHeight: 1,
    });
    if (oldSrc === newSrc && image.complete) {
        return;
    }
    return new Promise(resolve => image.addEventListener('ready', resolve, {once: true}));
}
/**
 * Marks an <img> with its attachment data (originalId, originalSrc, mimetype)
 *
 * @param {HTMLImageElement} img the image whose attachment data should be found
 * @param {Function} rpc a function that can be used to make the RPC. Typically
 *   this would be passed as 'this._rpc.bind(this)' from widgets.
 * @param {string} [attachmentSrc=''] specifies the URL of the corresponding
 * attachment if it can't be found in the 'src' attribute.
 */
__exports.loadImageInfo = loadImageInfo; async function loadImageInfo(img, rpc, attachmentSrc = '') {
    const src = attachmentSrc || img.getAttribute('src');
    // If there is a marked originalSrc, the data is already loaded.
    // If the image does not have the "mimetypeBeforeConversion" attribute, it
    // has to be added.
    if ((img.dataset.originalSrc && img.dataset.mimetypeBeforeConversion) || !src) {
        return;
    }
    // In order to be robust to absolute, relative and protocol relative URLs,
    // the src of the img is first converted to an URL object. To do so, the URL
    // of the document in which the img is located is used as a base to build
    // the URL object if the src of the img is a relative or protocol relative
    // URL. The original attachment linked to the img is then retrieved thanks
    // to the path of the built URL object.
    let docHref = img.ownerDocument.defaultView.location.href;
    if (docHref === "about:srcdoc") {
        docHref = window.location.href;
    }

    const srcUrl = new URL(src, docHref);
    const relativeSrc = srcUrl.pathname;

    const {original} = await rpc('/web_editor/get_image_info', {src: relativeSrc});
    // If src was an absolute "external" URL, we consider unlikely that its
    // relative part matches something from the DB and even if it does, nothing
    // bad happens, besides using this random image as the original when using
    // the options, instead of having no option. Note that we do not want to
    // check if the image is local or not here as a previous bug converted some
    // local (relative src) images to absolute URL... and that before users had
    // setup their website domain. That means they can have an absolute URL that
    // looks like "https://mycompany.odoo.com/web/image/123" that leads to a
    // "local" image even if the domain name is now "mycompany.be".
    //
    // The "redirect" check is for when it is a redirect image attachment due to
    // an external URL upload.
    if (original && original.image_src && !/\/web\/image\/\d+-redirect\//.test(original.image_src)) {
        if (!img.dataset.mimetype) {
            // The mimetype has to be added only if it is not already present as
            // we want to avoid to reset a mimetype set by the user.
            img.dataset.mimetype = original.mimetype;
        }
        img.dataset.originalId = original.id;
        img.dataset.originalSrc = original.image_src;
        img.dataset.mimetypeBeforeConversion = original.mimetype;
    }
}

/**
 * @param {String} mimetype
 * @param {Boolean} [strict=false] if true, even partially supported images (GIFs)
 *     won't be accepted.
 * @returns {Boolean}
 */
__exports.isImageSupportedForProcessing = isImageSupportedForProcessing; function isImageSupportedForProcessing(mimetype, strict = false) {
    if (isGif(mimetype)) {
        return !strict;
    }
    return ['image/jpeg', 'image/png', 'image/webp'].includes(mimetype);
}
/**
 * @param {HTMLImageElement} img
 * @returns {Boolean}
 */
__exports.isImageSupportedForStyle = isImageSupportedForStyle; function isImageSupportedForStyle(img) {
    if (!img.parentElement) {
        return false;
    }

    // See also `[data-oe-type='image'] > img` added as data-exclude of some
    // snippet options.
    const isTFieldImg = ('oeType' in img.parentElement.dataset);

    // Editable root elements are technically *potentially* supported here (if
    // the edited attributes are not computed inside the related view, they
    // could technically be saved... but as we cannot tell the computed ones
    // apart from the "static" ones, we choose to not support edition at all in
    // those "root" cases).
    // See also `[data-oe-xpath]` added as data-exclude of some snippet options.
    const isEditableRootElement = ('oeXpath' in img.dataset);

    return !isTFieldImg && !isEditableRootElement;
}
/**
 * @param {HTMLImageElement} img
 * @returns {Promise<Boolean>}
 */
__exports.isImageCorsProtected = isImageCorsProtected; async function isImageCorsProtected(img) {
    const src = img.getAttribute('src');
    if (!src) {
        return false;
    }
    let isCorsProtected = false;
    if (!src.startsWith("/") || /\/web\/image\/\d+-redirect\//.test(src)) {
        // The `fetch()` used later in the code might fail if the image is
        // CORS protected. We check upfront if it's the case.
        // Two possible cases:
        // 1. the `src` is an absolute URL from another domain.
        //    For instance, abc.odoo.com vs abc.com which are actually the
        //    same database behind.
        // 2. A "attachment-url" which is just a redirect to the real image
        //    which could be hosted on another website.
        isCorsProtected = await fetch(src, {method: 'HEAD'})
            .then(() => false)
            .catch(() => true);
    }
    return isCorsProtected;
}

/**
 * @param {Blob} blob
 * @returns {Promise}
 */
__exports.createDataURL = createDataURL; function createDataURL(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener('load', () => resolve(reader.result));
        reader.addEventListener('abort', reject);
        reader.addEventListener('error', reject);
        reader.readAsDataURL(blob);
    });
}

/**
 * @param {String} dataURL
 * @returns {Number} number of bytes represented with base64
 */
__exports.getDataURLBinarySize = getDataURLBinarySize; function getDataURLBinarySize(dataURL) {
    // Every 4 bytes of base64 represent 3 bytes.
    return dataURL.split(',')[1].length / 4 * 3;
}

const removeOnImageChangeAttrs = __exports.removeOnImageChangeAttrs = [...cropperDataFields, ...modifierFields];

__exports[Symbol.for("default")] = {
    applyModifications,
    cropperDataFields,
    activateCropper,
    loadImageInfo,
    loadImage,
    removeOnImageChangeAttrs,
    isImageSupportedForProcessing,
    isImageSupportedForStyle,
    createDataURL,
    isGif,
    getDataURLBinarySize,
};

return __exports;
});
;

/****************************************************************
*  Filepath: /web_editor/static/src/js/editor/custom_colors.js  *
*  Lines: 20                                                    *
****************************************************************/
odoo.define('@web_editor/js/editor/custom_colors', [], function (require) {
'use strict';
let __exports = {};

/** @odoo-module **/

// These colors are already normalized as per normalizeCSSColor in @web/legacy/js/widgets/colorpicker
__exports[Symbol.for("default")] = [
    ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],
    ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
    ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
    ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
    ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
    ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
    ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
    ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
];

return __exports;
});
;

/**********************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/alt_dialog.js  *
*  Lines: 53                                                          *
**********************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/alt_dialog', ['@odoo/owl', '@web/core/dialog/dialog'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Component, useRef, onMounted } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");

const AltDialog = __exports.AltDialog = class AltDialog extends Component {
    static components = { Dialog };
    static props = {
        confirm: Function,
        close: Function,
        alt: String,
        tag_title: String,
    };
    static template = 'web_edior.AltDialog';
    altRef = useRef("alt");
    tagTitleRef = useRef("tag_title");

    setup() {
        this.isConfirmedOrCancelled = false; // ensures we do not confirm and/or cancel twice
        onMounted(() => {
            this.altRef.el.focus();
        });
    }
    async _cancel() {
        if (this.isConfirmedOrCancelled) {
            return;
        }
        this.isConfirmedOrCancelled = true;
        this.props.close();
    }
    async _confirm() {
        if (this.isConfirmedOrCancelled) {
            return;
        }
        this.isConfirmedOrCancelled = true;
        try {
            const allNonEscQuots = /"/g;
            const alt = this.altRef.el.value.replace(allNonEscQuots, "&quot;");
            const title = this.tagTitleRef.el.value.replace(allNonEscQuots, "&quot;");
            await this.props.confirm(alt, title);
        } catch (e) {
            this.props.close();
            throw e;
        }
        this.props.close();
    }
}

return __exports;
});
;

/***************************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/chatgpt_alternatives_dialog.js  *
*  Lines: 126                                                                          *
***************************************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/chatgpt_alternatives_dialog', ['@web_editor/js/wysiwyg/widgets/chatgpt_dialog', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { ChatGPTDialog } = require('@web_editor/js/wysiwyg/widgets/chatgpt_dialog');
const { useState, status } = require("@odoo/owl");

const ChatGPTAlternativesDialog = __exports.ChatGPTAlternativesDialog = class ChatGPTAlternativesDialog extends ChatGPTDialog {
    static template = 'web_edior.ChatGPTAlternativesDialog';
    static props = {
        ...super.props,
        originalText: String,
        alternativesModes: { type: Object, optional: true },
        numberOfAlternatives: { type: Number, optional: true },
    };
    static defaultProps = {
        alternativesModes: {
            correct: 'Correct',
            short: 'Shorten',
            long: 'Lengthen',
            friendly: 'Friendly',
            professional: 'Professional',
            persuasive: 'Persuasive',
        },
        numberOfAlternatives: 3,
    };

    setup() {
        super.setup();
        this.state = useState({
            ...this.state,
            conversationHistory: [{
                role: 'system',
                content: 'The user wrote the following text:\n' +
                    '<generated_text>' + this.props.originalText + '</generated_text>\n' +
                    'Your goal is to help the user write alternatives to that text.\n' +
                    'Conditions:\n' +
                    '- You must respect the format (wrapping the alternative between <generated_text> and </generated_text>)\n' +
                    '- You must detect the language of the text given to you and respond in that language\n' +
                    '- Do not write HTML\n' +
                    '- You must suggest one and only one alternative per answer\n' +
                    '- Your answer must be different every time, never repeat yourself\n' +
                    '- You must respect whatever extra conditions the user gives you\n',
            }],
            messages: [],
            alternativesMode: '',
            messagesInProgress: 0,
            currentBatchId: null,
        });
        this._generationIndex = 0;
        this._generateAlternatives();
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    switchAlternativesMode(ev) {
        this.state.alternativesMode = ev.currentTarget.getAttribute('data-mode');
        this._generateAlternatives(1);
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    async _generateAlternatives(numberOfAlternatives = this.props.numberOfAlternatives) {
        this.state.messagesInProgress = numberOfAlternatives;
        const batchId = new Date().getTime();
        this.state.currentBatchId = batchId;
        let wasError = false;
        let messageIndex = 0;
        while (!wasError && messageIndex < numberOfAlternatives && this.state.currentBatchId === batchId) {
            this._generationIndex += 1;
            let query = messageIndex ? 'Write one alternative version of the original text.' : 'Try again another single version of the original text.';
            if (this.state.alternativesMode && !messageIndex) {
                query += ` Make it more ${this.state.alternativesMode} than your last answer.`;
            }
            if (this.state.alternativesMode === 'correct') {
                query = 'Simply correct the text, without altering its meaning in any way. Preserve whatever language the user wrote their text in.';
            }
            await this._generate(query, (content, isError) => {
                if (this.state.currentBatchId === batchId) {
                    const alternative = content.replace(/^[\s\S]*<generated_text>/, '').replace(/<\/generated_text>[\s\S]*$/, '');
                    if (isError) {
                        wasError = true;
                    } else {
                        this.state.conversationHistory.push({
                            role: 'user',
                            content: query,
                        }, {
                            role: 'assistant',
                            content,
                        });
                    }
                    this.state.messages.push({
                        author: 'assistant',
                        text: alternative,
                        isError,
                        batchId,
                        mode: this.state.alternativesMode,
                        id: new Date().getTime(),
                    });
                }
            }).catch(() => {
                if (this.state.currentBatchId === batchId) {
                    wasError = true;
                    this.state.messages = [];
                }
            });
            if (status(this) === 'destroyed') {
                return;
            }
            messageIndex += 1;
            this.state.messagesInProgress -= 1;
            if (wasError) {
                break;
            }
        }
        this.state.messagesInProgress = 0;
    }
}

return __exports;
});
;

/**************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/chatgpt_dialog.js  *
*  Lines: 124                                                             *
**************************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/chatgpt_dialog', ['@odoo/owl', '@web/core/utils/hooks', '@web/core/dialog/dialog', '@web/core/utils/strings', '@web/core/l10n/translation'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Component, useState, markup, onWillDestroy, status } = require("@odoo/owl");
const { useService } = require("@web/core/utils/hooks");
const { Dialog } = require("@web/core/dialog/dialog");
const { escape } = require("@web/core/utils/strings");
const { _t } = require("@web/core/l10n/translation");

/**
 * General component for common logic between different dialogs.
 */
const ChatGPTDialog = __exports.ChatGPTDialog = class ChatGPTDialog extends Component {
    static components = { Dialog };
    static props = {
        close: Function,
        insert: Function,
    };

    setup() {
        this.rpc = useService('rpc');
        this.state = useState({ selectedMessageId: null });
        onWillDestroy(() => this.pendingRpcPromise?.abort());
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    selectMessage(ev) {
        this.state.selectedMessageId = +ev.currentTarget.getAttribute('data-message-id');
    }
    insertMessage(ev) {
        this.selectMessage(ev);
        this._confirm();
    }
    formatContent(content) {
        return markup([...this._postprocessGeneratedContent(content).childNodes].map(child => {
            // Escape all text.
            const nodes = new Set([...child.querySelectorAll('*')].flatMap(node => node.childNodes));
            nodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    node.textContent = escape(node.textContent);
                }
            });
            return child.outerHTML;
        }).join(''));
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    _postprocessGeneratedContent(content) {
        const lines = content.split('\n').filter(line => line.trim().length);
        const fragment = document.createDocumentFragment();
        let parentUl, parentOl;
        let lineIndex = 0;
        for (const line of lines) {
            if (line.trim().startsWith('- ')) {
                // Create or continue an unordered list.
                parentUl = parentUl || document.createElement('ul');
                const li = document.createElement('li');
                li.innerText = line.trim().slice(2);
                parentUl.appendChild(li);
            } else if (
                (parentOl && line.startsWith(`${parentOl.children.length + 1}. `)) ||
                (!parentOl && line.startsWith('1. ') && lines[lineIndex + 1]?.startsWith('2. '))
            ) {
                // Create or continue an ordered list (only if the line starts
                // with the next number in the current ordered list (or 1 if no
                // ordered list was in progress and it's followed by a 2).
                parentOl = parentOl || document.createElement('ol');
                const li = document.createElement('li');
                li.innerText = line.slice(line.indexOf('.') + 2);
                parentOl.appendChild(li);
            } else {
                // Insert any list in progress, and a new block for the current
                // line.
                [parentUl, parentOl].forEach(list => list && fragment.appendChild(list));
                parentUl = parentOl = undefined;
                const block = document.createElement(line.startsWith('Title: ') ? 'h2' : 'p');
                block.innerText = line;
                fragment.appendChild(block);
            }
            lineIndex += 1;
        }
        [parentUl, parentOl].forEach(list => list && fragment.appendChild(list));
        return fragment;
    }
    _cancel() {
        this.props.close();
    }
    _confirm() {
        try {
            this.props.close();
            const text = this.state.messages.find(message => message.id === this.state.selectedMessageId)?.text;
            this.props.insert(this._postprocessGeneratedContent(text || ''));
        } catch (e) {
            this.props.close();
            throw e;
        }
    }
    _generate(prompt, callback) {
        const protectedCallback = (...args) => {
            if (status(this) !== 'destroyed') {
                delete this.pendingRpcPromise;
                return callback(...args);
            }
        }
        this.pendingRpcPromise = this.rpc('/web_editor/generate_text', {
            prompt,
            conversation_history: this.state.conversationHistory,
        }, { shadow: true });
        return this.pendingRpcPromise
            .then(content => protectedCallback(content))
            .catch(error => protectedCallback(_t(error.data?.message || error.message), true));
    }
}

return __exports;
});
;

/*********************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/chatgpt_prompt_dialog.js  *
*  Lines: 114                                                                    *
*********************************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/chatgpt_prompt_dialog', ['@web_editor/js/wysiwyg/widgets/chatgpt_dialog', '@odoo/owl', '@web/core/utils/hooks', '@web/session', '@web/core/browser/browser'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { ChatGPTDialog } = require('@web_editor/js/wysiwyg/widgets/chatgpt_dialog');
const { useState, useEffect, useRef } = require("@odoo/owl");
const { useAutofocus } = require("@web/core/utils/hooks");
const { session } = require("@web/session");
const { browser } = require("@web/core/browser/browser");

const ChatGPTPromptDialog = __exports.ChatGPTPromptDialog = class ChatGPTPromptDialog extends ChatGPTDialog {
    static template = 'web_edior.ChatGPTPromptDialog';
    static props = {
        ...super.props,
        initialPrompt: { type: String, optional: true },
    };
    static defaultProps = {
        initialPrompt: '',
    };

    setup() {
        super.setup();
        this.assistantAvatarUrl = `${browser.location.origin}/web_editor/static/src/img/odoobot_transparent.png`;
        this.userAvatarUrl = `${browser.location.origin}/web/image?model=res.users&field=avatar_128&id=${encodeURIComponent(session.uid)}`;
        this.state = useState({
            ...this.state,
            prompt: this.props.initialPrompt,
            conversationHistory: [{
                role: 'system',
                content: 'You are a helpful assistant, your goal is to help the user write their document.',
            },
            {
                role: 'assistant',
                content: 'What do you need ?',
            }],
            messages: [],
        });
        this.promptInputRef = useRef('promptInput');
        useAutofocus({ refName: 'promptInput' });
        useEffect(() => {
            // Resize the textarea to fit its content.
            this.promptInputRef.el.style.height = 0;
            this.promptInputRef.el.style.height = this.promptInputRef.el.scrollHeight + 'px';
        }, () => [this.state.prompt]);
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    onTextareaKeydown(ev) {
        if (ev.key === 'Enter' && !ev.shiftKey) {
            this.submitPrompt(ev);
        }
    }
    submitPrompt(ev) {
        this._freezeInput();
        ev.preventDefault();
        const prompt = this.state.prompt;
        this.state.messages.push({ author: 'user', text: prompt });
        const messageId = new Date().getTime();
        const conversation = { role: 'user', content: prompt };
        this.state.conversationHistory.push(conversation);
        this.state.messages.push({ author: 'assistant', id: messageId });
        this.state.prompt = '';
        this._generate(prompt, (content, isError) => {
            if (isError) {
                // There was an error, remove the prompt from the history.
                this.state.conversationHistory = this.state.conversationHistory.filter(c => c !== conversation);
            } else {
                // There was no error, add the response to the history.
                this.state.conversationHistory.push({ role: 'assistant', content });
            }
            const messageIndex = this.state.messages.findIndex(m => m.id === messageId);
            this.state.messages[messageIndex] = {
                author: 'assistant',
                text: content,
                isError,
                id: messageId,
            };
            this._unfreezeInput();
        });
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    _freezeInput() {
        this.promptInputRef.el.setAttribute('disabled', '');
    }
    _unfreezeInput() {
        this.promptInputRef.el.removeAttribute('disabled');
        this.promptInputRef.el.focus();
    }
    /**
     * @override
     */
    _cancel() {
        this._freezeInput();
        super._cancel();
    }
    /**
     * @override
     */
     _confirm() {
        this._freezeInput();
        super._confirm();
    }
}

return __exports;
});
;

/*************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/color_palette.js  *
*  Lines: 1066                                                           *
*************************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/color_palette', ['@web/core/colorpicker/colorpicker', '@web_editor/js/editor/custom_colors', '@web_editor/js/common/utils', '@web/core/utils/colors', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Colorpicker } = require("@web/core/colorpicker/colorpicker");
const customColors = require("@web_editor/js/editor/custom_colors")[Symbol.for("default")];
const weUtils = require("@web_editor/js/common/utils")[Symbol.for("default")];
const {
    isCSSColor,
    normalizeCSSColor,
    convertCSSColorToRgba,
} = require('@web/core/utils/colors');
const {
    Component,
    useRef,
    useState,
    onWillStart,
    onMounted,
    onWillUpdateProps,
} = require("@odoo/owl");

const ColorPalette = __exports.ColorPalette = class ColorPalette extends Component {
    static template = 'web_editor.ColorPalette';
    static props = {
        document: { type: true, optional: true },
        resetTabCount: { type: Number, optional: true },
        selectedCC: { type: String, optional: true },
        selectedColor: { type: String, optional: true },
        resetButton: { type: Boolean, optional: true },
        excluded: { type: Array, optional: true },
        excludeSectionOf: { type: Array, optional: true },
        withCombinations: { type: Boolean, optional: true },
        noTransparency: { type: Boolean, optional: true },
        opacity: { type: Number, optional: true },
        selectedTab: { type: String, optional: true },
        withGradients: { type: Boolean, optional: true },
        getTemplate: { type: Function,  optional: true },
        onSetColorNames: { type: Function, optional: true },
        onColorHover: { type: Function, optional: true },
        onColorPicked: { type: Function, optional: true },
        onCustomColorPicked: { type: Function, optional: true },
        onColorLeave: { type: Function, optional: true },
        onInputEnter: { type: Function, optional: true },
        getCustomColors: { type: Function, optional: true },
        getEditableCustomColors: { type: Function, optional: true },
        onColorpaletteTabChange: { type: Function, optional: true },
    };
    static defaultProps = {
        document: window.document,
        resetTabCount: 0,
        resetButton: true,
        excluded: [],
        excludeSectionOf: null,
        withCombinations: false,
        noTransparency: false,
        opacity: 1,
        selectedTab: 'theme-colors',
        withGradients: false,
        onSetColorNames: () => {},
        onColorHover: () => {},
        onColorPicked: () => {},
        onCustomColorPicked: () => {},
        onColorLeave: () => {},
        onInputEnter: () => {},
        getCustomColors: () => [],
        getEditableCustomColors: () => [],
        onColorpaletteTabChange: () => {},
    }
    static components = { Colorpicker };
    elRef = useRef('el');
    state = useState({
        showGradientPicker: false,
    });
    setup() {
        this.init();
        onWillStart(async () => {
            if (this.props.getTemplate) {
                this.colorpickerTemplate = await this.props.getTemplate();
            }
        });
        onMounted(async () => {
            if (!this.elRef.el) {
                // There is legacy code that can trigger the instantiation of the
                // link tool when one of it's parent component is not in the dom. If
                // that parent element is not in the dom, owl will not return
                // `this.linkComponentWrapperRef.el` because of a check (see
                // `inOwnerDocument`).
                // Todo: this workaround should be removed when the snippet menu is
                // converted to owl.
                await new Promise(resolve => {
                    const observer = new MutationObserver(() => {
                        if (this.elRef.el) {
                            observer.disconnect();
                            resolve();
                        }
                    });
                    observer.observe(document.body, { childList: true, subtree: true });
                });
            }
            this.el = this.elRef.el;
            const $el = $(this.el);
            this.$ = $el.find.bind($el);

            $el.on('click', '.o_we_color_btn', this._onColorButtonClick.bind(this));
            $el.on('mouseenter', '.o_we_color_btn', this._onColorButtonEnter.bind(this));
            $el.on('mouseleave', '.o_we_color_btn', this._onColorButtonLeave.bind(this));

            $el.on('click', '.o_custom_gradient_editor .o_custom_gradient_btn', this._onGradientCustomButtonClick.bind(this));
            $el.on('click', '.o_custom_gradient_editor', this._onPanelClick.bind(this));
            $el.on('change', '.o_custom_gradient_editor input[type="text"]', this._onGradientInputChange.bind(this));
            $el.on('keypress', '.o_custom_gradient_editor input[type="text"]', this._onGradientInputKeyPress.bind(this));
            $el.on('click', '.o_custom_gradient_editor we-button:not(.o_remove_color)', this._onGradientButtonClick.bind(this));
            $el.on('mouseenter', '.o_custom_gradient_editor we-button:not(.o_remove_color)', this._onGradientButtonEnter.bind(this));
            $el.on('mouseleave', '.o_custom_gradient_editor we-button:not(.o_remove_color)', this._onGradientButtonLeave.bind(this));

            $el.on('click', '.o_custom_gradient_scale', this._onGradientPreviewClick.bind(this));
            // Note: _onGradientSliderClick on slider is attached at slider creation.
            $el.on('click', '.o_custom_gradient_editor .o_remove_color', this._onGradientDeleteClick.bind(this));

            await this.start();
        });
        onWillUpdateProps((newProps) => {
            this._updateColorToColornames();
            if (this.props.resetTabCount !== newProps.resetTabCount) {
                this._selectDefaultTab();
            }
            if (this.props.selectedCC !== newProps.selectedCC || this.props.selectedColor !== newProps.selectedColor) {
                this._selectColor({
                    ccValue: newProps.selectedCC,
                    color: newProps.selectedColor,
                });
            }
            this._buildCustomColors();
            this._markSelectedColor();
        });
    }
    init() {
        const editableDocument = this.props.document;
        this.style = editableDocument.defaultView.getComputedStyle(editableDocument.documentElement);
        this.selectedColor = '';
        this.resetButton = this.props.resetButton;
        this.withCombinations = this.props.withCombinations;
        this.selectedTab = this.props.selectedTab;

        this.tabs = [{
            id: 'theme-colors',
            pickers: [
                'theme',
                'common',
            ],
        },
        {
            id: 'custom-colors',
            pickers: [
                'custom',
                'transparent_grayscale',
                'common_grays',
            ],
        },
        {
            id: 'gradients',
            pickers: this.props.withGradients ? [
                'predefined_gradients',
                'custom_gradient',
            ] : [],
        }];

        this.sections = {};
        this.pickers = {};
    }
    /**
     * @override
     */
    async start() {
        const switchPaneButtons = this.el.querySelectorAll('.o_we_colorpicker_switch_pane_btn');

        let colorpickerEl;
        if (this.colorpickerTemplate) {
            colorpickerEl = $(this.colorpickerTemplate)[0];
        } else {
            colorpickerEl = document.createElement("colorpicker");
            const sectionEl = document.createElement('DIV');
            sectionEl.classList.add('o_colorpicker_section');
            sectionEl.dataset.name = 'common';
            colorpickerEl.appendChild(sectionEl);
        }
        colorpickerEl.querySelectorAll('button').forEach(el => el.classList.add('o_we_color_btn'));

        // Populate tabs based on the tabs configuration indicated in this.tabs
        this.tabs.forEach((tab, index) => {
            // Append pickers to section
            let sectionEl = this.el.querySelector(`.o_colorpicker_sections[data-color-tab="${tab.id}"]`);
            const container = sectionEl.querySelector('.o_colorpicker_section_container');
            if (container) {
                sectionEl = container;
            }
            let sectionIsEmpty = true;
            tab.pickers.forEach((pickerId) => {
                let pickerEl;
                switch (pickerId) {
                    case 'common_grays':
                        pickerEl = colorpickerEl.querySelector('[data-name="common"]').cloneNode(true);
                        break;
                    case 'custom':
                        pickerEl = document.createElement('DIV');
                        pickerEl.classList.add("o_colorpicker_section");
                        pickerEl.dataset.name = 'custom';
                        break;
                    default:
                        pickerEl = colorpickerEl.querySelector(`[data-name="${pickerId}"]`);
                        pickerEl = pickerEl && pickerEl.cloneNode(true);
                }
                if (pickerEl) {
                    sectionEl.appendChild(pickerEl);

                    if (!this.props.excluded.includes(pickerId)) {
                        sectionIsEmpty = false;
                    }

                    this.pickers[pickerId] = pickerEl;
                }
            });

            // If the section is empty, hide it and
            // select the next tab if none is given in the options
            if (sectionIsEmpty) {
                sectionEl.classList.add('d-none');
                switchPaneButtons[index].classList.add('d-none');
                if (this.selectedTab === tab.id) {
                    this.selectedTab = this.tabs[(index + 1) % this.tabs.length].id;
                }
            }
            this.sections[tab.id] = sectionEl;
        });

        // Predefined gradient opacity
        if (this.props.withGradients && this.props.opacity !== 1) {
            this.pickers['predefined_gradients'].querySelectorAll('button').forEach(elem => {
                let gradient = elem.dataset.color;
                gradient = gradient.replaceAll(/rgba?(\(\s*\d+\s*,\s*\d+\s*,\s*\d+)(?:\s*,.+?)?\)/g,
                    `rgba$1, ${this.props.opacity})`);
                elem.dataset.color = gradient.replaceAll(/\s+/g, '');
            });
        }

        // Palette for gradient
        if (this.pickers['custom_gradient']) {
            const editor = this.pickers['custom_gradient'];
            this.gradientEditorParts = {
                'customButton': editor.querySelector('.o_custom_gradient_btn'),
                'customContent': editor.querySelector('.o_color_picker_inputs'),
                'linearButton': editor.querySelector('we-button[data-gradient-type="linear-gradient"]'),
                'angleRow': editor.querySelector('.o_angle_row'),
                'angle': editor.querySelector('input[data-name="angle"]'),
                'radialButton': editor.querySelector('we-button[data-gradient-type="radial-gradient"]'),
                'positionRow': editor.querySelector('.o_position_row'),
                'positionX': editor.querySelector('input[data-name="positionX"]'),
                'positionY': editor.querySelector('input[data-name="positionY"]'),
                'sizeRow': editor.querySelector('.o_size_row'),
                'scale': editor.querySelector('.o_custom_gradient_scale div'),
                'sliders': editor.querySelector('.o_slider_multi'),
                'deleteButton': editor.querySelector('.o_remove_color'),
            };
            const gradient = weUtils.isColorGradient(this.props.selectedColor) && this.props.selectedColor;
            this._selectGradient(gradient);
            const resizeObserver = new window.ResizeObserver(() => {
                this._adjustActiveSliderDelete();
            });
            resizeObserver.observe(this.gradientEditorParts.sliders);
        }

        // Switch to the correct tab
        const selectedButtonIndex = this.tabs.map(tab => tab.id).indexOf(this.selectedTab);
        this._selectTabFromButton(this.el.querySelectorAll('button')[selectedButtonIndex]);

        // Remove the buttons display if there is only one
        const visibleButtons = Array.from(switchPaneButtons).filter(button => !button.classList.contains('d-none'));
        if (visibleButtons.length === 1) {
            visibleButtons[0].classList.add('d-none');
        }

        // Remove excluded palettes (note: only hide them to still be able
        // to remove their related colors on the DOM target)
        this.props.excluded.forEach((exc) => {
            this.$('[data-name="' + exc + '"]').addClass('d-none');
        });
        if (this.props.excludeSectionOf) {
            this.$('[data-name]:has([data-color="' + this.props.excludeSectionOf + '"])').addClass('d-none');
        }

        this.el.querySelectorAll('.o_colorpicker_section').forEach(elem => {
            $(elem).prepend('<div>' + (elem.dataset.display || '') + '</div>');
        });

        // Render common colors
        if (!this.props.excluded.includes('common')) {
            customColors.forEach((colorRow, i) => {
                if (i === 0) {
                    return; // Ignore the wysiwyg gray palette and use ours
                }
                const $div = $('<div/>', {class: 'clearfix'}).appendTo(this.pickers['common']);
                colorRow.forEach(color => {
                    $div.append(this._createColorButton(color, ['o_common_color']));
                });
            });
        }

        // Compute class colors

        this.colorNames = [...weUtils.COLOR_PALETTE_COMPATIBILITY_COLOR_NAMES];
        this._updateColorToColornames();
        this.props.onSetColorNames([...this.colorNames]);

        // Select selected Color and build customColors.
        // If no color is selected selectedColor is an empty string (transparent is interpreted as no color)
        if (this.props.selectedCC) {
            this.selectedCC = this.props.selectedCC;
        }
        this._setSelectedColor(this.props.selectedColor);
        this._buildCustomColors();
        this._markSelectedColor();

        // Colorpicker
        if (!this.props.excluded.includes('custom')) {
            let defaultColor = this.selectedColor;
            if (defaultColor && !isCSSColor(defaultColor)) {
                defaultColor = weUtils.getCSSVariableValue(defaultColor, this.style);
            }
            if (!defaultColor && this.props.opacity !== 1) {
                defaultColor = 'rgba(0, 0, 0, ' + this.props.opacity + ')';
            }
            this.state.customDefaultColor = defaultColor;
        }
    }
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Gets the currently selected colors.
     *
     * @private
     * @returns {Object} ccValue and color (plain color or gradient).
     */
    _getSelectedColors() {
        return {
            ccValue: this.selectedCC,
            color: this.selectedColor,
        };
    }
    /**
     * @private
     */
    _setSelectedColor(color) {
        if (color) {
            if (color === 'rgba(0, 0, 0, 0)' && this.props.opacity !== 1) {
                color = 'rgba(0, 0, 0, ' + this.props.opacity + ')';
            }
            let selectedColor = color;
            if (weUtils.COLOR_PALETTE_COMPATIBILITY_COLOR_NAMES.includes(selectedColor)) {
                selectedColor = weUtils.getCSSVariableValue(selectedColor, this.style) || selectedColor;
            }
            selectedColor = normalizeCSSColor(selectedColor);
            if (selectedColor !== 'rgba(0, 0, 0, 0)') {
                this.selectedColor = this.colorToColorNames[selectedColor] || selectedColor;
            }
        }
    }
    /**
     * @private
     */
    _buildCustomColors() {
        if (this.props.excluded.includes('custom')) {
            return;
        }
        this.el.querySelectorAll('.o_custom_color').forEach(el => el.remove());
        const existingColors = new Set(Object.keys(this.colorToColorNames));
        for (const color of this.props.getCustomColors()) {
            this._addCustomColor(existingColors, color);
        }
        weUtils.getCSSVariableValue('custom-colors', this.style).split(' ').forEach(v => {
            const color = weUtils.getCSSVariableValue(v.substring(1, v.length - 1), this.style);
            if (isCSSColor(color)) {
                this._addCustomColor(existingColors, color);
            }
        });
        for (const color of this.props.getEditableCustomColors()) {
            this._addCustomColor(existingColors, color);
        }
        if (this.selectedColor) {
            this._addCustomColor(existingColors, this.selectedColor);
        }
    }
    /**
     * Add the color to the custom color section if it is not in the existingColors.
     *
     * @param {string[]} existingColors Colors currently in the colorpicker
     * @param {string} color Color to add to the cuustom colors
     */
    _addCustomColor(existingColors, color) {
        if (!color) {
            return;
        }
        if (!isCSSColor(color)) {
            color = weUtils.getCSSVariableValue(color, this.style);
        }
        const normColor = normalizeCSSColor(color);
        if (!existingColors.has(normColor)) {
            this._addCustomColorButton(normColor);
            existingColors.add(normColor);
        }
    }
    /**
     * Add a custom button in the coresponding section.
     *
     * @private
     * @param {string} color
     * @param {string[]} classes - classes added to the button
     * @returns {jQuery}
     */
    _addCustomColorButton(color, classes = []) {
        classes.push('o_custom_color');
        const $button = this._createColorButton(color, classes);
        return $button.appendTo(this.pickers['custom']);
    }
    /**
     * Return a color button.
     *
     * @param {string} color
     * @param {string[]} classes - classes added to the button
     * @returns {jQuery}
     */
    _createColorButton(color, classes) {
        return $('<button/>', {
            class: 'o_we_color_btn ' + classes.join(' '),
            style: 'background-color:' + color + ';',
        });
    }
    /**
     * Gets normalized information about a color button.
     *
     * @private
     * @param {HTMLElement} buttonEl
     * @returns {Object}
     */
    _getButtonInfo(buttonEl) {
        const bgColor = buttonEl.style.backgroundColor;
        const value = buttonEl.dataset.color || (bgColor && bgColor !== 'initial' ? normalizeCSSColor(bgColor) : '') || '';
        const info = {
            target: buttonEl,
        };
        if (!value) {
            info.ccValue = '';
            info.color = '';
        } else if (weUtils.isColorCombinationName(value)) {
            info.ccValue = value;
        } else {
            info.color = value;
        }
        return info;
    }
    /**
     * Set the selectedColor and trigger an event
     *
     * @param {Object} colorInfo
     * @param {string} [colorInfo.ccValue]
     * @param {string} [colorInfo.color]
     * @param {Function} [eventCallback]
     */
    _selectColor(colorInfo, eventCallback) {
        this.selectedCC = colorInfo.ccValue;
        this.selectedColor = colorInfo.color = this.colorToColorNames[colorInfo.color] || colorInfo.color;
        if (eventCallback) {
            eventCallback(colorInfo);
        }
        this._buildCustomColors();
        this.state.customSelectedColor = colorInfo.color;
        const customGradient = weUtils.isColorGradient(colorInfo.color) ? colorInfo.color : false;
        if (this.pickers['custom_gradient']) {
            this._selectGradient(customGradient);
        }
        this._markSelectedColor();
    }
    /**
     * Populates the gradient editor.
     *
     * @private
     * @param {string} gradient CSS string
     */
    _selectGradient(gradient) {
        const editor = this.gradientEditorParts;
        this.state.showGradientPicker = false;
        const colorSplits = [];
        if (gradient) {
            gradient = gradient.toLowerCase();
            // Extract colors and their positions: colors can either be in the #rrggbb format or in the
            // rgb/rgba(...) format, positions are expected to be expressed as percentages
            // (lengths are not supported).
            for (const entry of gradient.matchAll(/(#[0-9a-f]{6}|rgba?\(\s*[0-9]+\s*,\s*[0-9]+\s*,\s*[0-9]+\s*[,\s*[0-9.]*]?\s*\))\s*([[0-9]+%]?)/g)) {
                colorSplits.push([entry[1], entry[2].replace('%', '')]);
            }
        }
        // Consider unsupported gradients as not gradients.
        if (!gradient || colorSplits.length < 2) {
            $(editor.customContent).addClass('d-none');
            editor.customButton.style['background-image'] = '';
            editor.customButton.dataset.color = false;
            return;
        }
        $(editor.customContent).removeClass('d-none');
        editor.customButton.style['background-image'] = gradient;
        editor.customButton.dataset.color = gradient;
        // The scale display shows the gradient colors horizontally by canceling the type and angle
        // which are before the first comma.
        const scaleGradient = gradient.replace(/[^,]+,/, 'linear-gradient(90deg,');
        editor.scale.style['background-image'] = scaleGradient;

        const isLinear = gradient.startsWith('linear-gradient(');
        // Keep track of last selected slider's position.
        let lastSliderPosition;
        const activeSlider = editor.sliders.querySelector('input.active');
        if (activeSlider) {
            lastSliderPosition = activeSlider.value;
        }
        let $lastSlider;
        // Rebuild sliders for each color milestone of the gradient.
        editor.sliders.replaceChildren();
        for (const index in colorSplits) {
            const colorSplit = colorSplits[index];
            let color = colorSplit[0];
            const position = colorSplit[1] || 100 * index / colorSplits.length;
            const $slider = this._createGradientSlider(position, color);
            if (position === lastSliderPosition) {
                $lastSlider = $slider;
            }
        }

        editor.deleteButton.classList.add('d-none');
        // Update form elements related to type.
        if (isLinear) {
            editor.linearButton.classList.add('active');
            editor.radialButton.classList.remove('active');

            let angle = gradient.match(/([0-9]+)deg/);
            angle = angle ? angle[1] : 0;
            editor.angle.value = angle;
        } else {
            editor.linearButton.classList.remove('active');
            editor.radialButton.classList.add('active');

            const sizeMatch = gradient.match(/(closest|farthest)-(side|corner)/);
            const size = sizeMatch ? sizeMatch[0] : 'farthest-corner';
            const $buttons = $(editor.sizeRow).find('we-button');
            $buttons.removeClass('active');
            $(editor.sizeRow).find("we-button[data-gradient-size='" + size + "']").addClass('active');

            const position = gradient.match(/ at ([0-9]+)% ([0-9]+)%/) || ['', '50', '50'];
            editor.positionX.value = position[1];
            editor.positionY.value = position[2];
        }
        this._updateGradientVisibility(isLinear);
        this._activateGradientSlider($lastSlider || $(this.pickers['custom_gradient'].querySelector('.o_slider_multi input')));
    }
    /**
     * Adjusts the visibility of the gradient editor elements.
     *
     * @private
     * @param {boolean} isLinear
     */
    _updateGradientVisibility(isLinear) {
        const editor = this.gradientEditorParts;
        if (isLinear) {
            editor.angleRow.classList.remove('d-none');
            editor.angleRow.classList.add('d-flex');
            editor.positionRow.classList.add('d-none');
            editor.positionRow.classList.remove('d-flex');
            editor.sizeRow.classList.add('d-none');
            editor.sizeRow.classList.remove('d-flex');
        } else {
            editor.angleRow.classList.add('d-none');
            editor.angleRow.classList.remove('d-flex');
            editor.positionRow.classList.remove('d-none');
            editor.positionRow.classList.add('d-flex');
            editor.sizeRow.classList.remove('d-none');
            editor.sizeRow.classList.add('d-flex');
        }
    }
    /**
     * Removes the transparency from an rgba color.
     *
     * @private
     * @param {string} color rgba CSS color string
     * @returns {string} rgb CSS color string
     */
    _opacifyColor(color) {
        if (color.startsWith('rgba')) {
            return color.replace('rgba', 'rgb').replace(/,\s*[0-9.]+\s*\)/, ')');
        }
        return color;
    }
    /**
     * Creates and adds a slider for the gradient color definition.
     *
     * @private
     * @param {int} position between 0 and 100
     * @param {string} color
     * @returns {jQuery} created slider
     */
    _createGradientSlider(position, color) {
        const $slider = $('<input class="w-100" type="range" min="0" max="100"/>');
        $slider.attr('value', position);
        $slider.attr('data-color', color);
        $slider.css('color', this._opacifyColor(color));
        $slider.on('click', this._onGradientSliderClick.bind(this));
        $slider.appendTo(this.gradientEditorParts.sliders);
        this._sortGradientSliders();
        return $slider;
    }
    /**
     * Activates a slider of the gradient color definition.
     *
     * @private
     * @param {jQuery} $slider
     */
    _activateGradientSlider($slider) {
        const $sliders = $(this.gradientEditorParts.sliders).find('input');
        $sliders.removeClass('active');
        $slider.addClass('active');

        const color = $slider.data('color');
        this.state.showGradientPicker = true;
        this.state.gradientSelectedColor = color;
        this._sortGradientSliders();
        this._adjustActiveSliderDelete();
    }
    /**
     * Adjusts the position of the slider delete button.
     *
     * @private
     */
    _adjustActiveSliderDelete() {
        const $sliders = $(this.gradientEditorParts.sliders).find('input');
        const $activeSlider = $(this.gradientEditorParts.sliders).find('input.active');
        if ($sliders.length > 2 && $activeSlider.length) {
            this.gradientEditorParts.deleteButton.classList.remove('d-none');
            const sliderWidth = $activeSlider.width();
            const thumbWidth = 12; // TODO find a way to access it in CSS
            const deleteWidth = $(this.gradientEditorParts.deleteButton).width();
            const pixelOffset = (sliderWidth - thumbWidth) * $activeSlider[0].value / 100 + (thumbWidth - deleteWidth) / 2;
            this.gradientEditorParts.deleteButton.style['margin-left'] = `${pixelOffset}px`;
            this.gradientEditorParts.deleteButton.style['margin-right'] = `-${deleteWidth / 2}px`;
        } else {
            this.gradientEditorParts.deleteButton.classList.add('d-none');
        }
    }
    /**
     * Reorders the sliders of the gradient color definition by their position.
     *
     * @private
     */
    _sortGradientSliders() {
        const $sliderInputs = $(this.gradientEditorParts.sliders).find('input');
        for (const slider of $sliderInputs.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10))) {
            this.gradientEditorParts.sliders.appendChild(slider);
        }
    }
    /**
     * Computes the customized gradient from the custom gradient editor.
     *
     * @private
     * @returns {string} gradient string corresponding to the currently selected options.
     */
    _computeGradient() {
        const editor = this.gradientEditorParts;

        const $picker = $(this.pickers['custom_gradient']);

        const colors = [];
        for (const slider of $(editor.sliders).find('input')) {
            const color = convertCSSColorToRgba($(slider).data('color'));
            const colorText = color.opacity !== 100 ? `rgba(${color.red}, ${color.green}, ${color.blue}, ${color.opacity / 100})`
                : `rgb(${color.red}, ${color.green}, ${color.blue})`;
            const position = slider.value;
            colors.push(`${colorText} ${position}%`);
        }

        const type = $picker.find('.o_type_row we-button.active').data('gradientType');
        const isLinear = type === 'linear-gradient';
        let typeParam;
        if (isLinear) {
            const angle = editor.angle.value || 0;
            typeParam = `${angle}deg`;
        } else {
            const positionX = editor.positionX.value || 50;
            const positionY = editor.positionY.value || 50;
            const size = $picker.find('.o_size_row we-button.active').data('gradientSize');
            typeParam = `circle ${size} at ${positionX}% ${positionY}%`;
        }

        return `${type}(${typeParam}, ${colors.join(', ')})`;
    }
    /**
     * Computes the customized gradient from the custom gradient editor and displays it.
     *
     * @private
     * @param {boolean} isPreview
     */
    _updateGradient(isPreview) {
        const gradient = this._computeGradient();
        // Avoid updating an unchanged gradient.
        if (weUtils.areCssValuesEqual(gradient, this.selectedColor) && !isPreview) {
            return;
        }
        const params = {
            ...this._getSelectedColors(),
            color: gradient,
        };
        if (isPreview) {
            this.props.onColorHover(params);
        } else {
            this.props.onColorPicked(params);
        }
    }
    /**
     * Marks the selected colors.
     *
     * @private
     */
    _markSelectedColor() {
        for (const buttonEl of this.el.querySelectorAll('button')) {
            // TODO buttons should only be search by data-color value
            // instead of style but seems necessary for custom colors right
            // now...
            const value = buttonEl.dataset.color || buttonEl.style.backgroundColor;
            // Buttons in the theme-colors tab of the palette have
            // no opacity, hence they should be searched by removing
            // opacity of 0.6 (which was applied by default) from
            // the selected color.
            const isCommonColor = buttonEl.classList.contains('o_common_color');
            const selectedColor = isCommonColor ? this._opacifyColor(this.selectedColor) : this.selectedColor;
            buttonEl.classList.toggle('selected', value
                && (this.selectedCC === value || weUtils.areCssValuesEqual(selectedColor, value)));
        }
    }

    /**
     * Select the default tab.
     *
     * @private
     */
    _selectDefaultTab() {
        const selectedButtonIndex = this.tabs.map(tab => tab.id).indexOf(this.selectedTab);
        this._selectTabFromButton(this.el.querySelectorAll('button')[selectedButtonIndex]);
    }
    /**
     * Display button element as selected
     *
     * @private
     * @param {HTMLElement} buttonEl
     */
    _selectTabFromButton(buttonEl) {
        this.el.querySelectorAll('.o_we_colorpicker_switch_pane_btn').forEach(el => {
            el.classList.remove('active');
        });
        buttonEl.classList.add('active');
        this.el.querySelectorAll('.o_colorpicker_sections').forEach(el => {
            el.classList.toggle('d-none', el.dataset.colorTab !== buttonEl.dataset.target);
        });
        this.props.onColorpaletteTabChange(buttonEl.dataset.target);
    }
    /**
     * Updates a gradient color from a selection in the color picker.
     *
     * @private
     * @param {String} colorInfo.cssColor
     * @param {Boolean} isPreview
     */
    _updateGradientColor(colorInfo, isPreview) {
        const $slider = $(this.gradientEditorParts.sliders).find('input.active');
        if (!weUtils.areCssValuesEqual(colorInfo.cssColor, $slider.data('color'))) {
            const previousColor = $slider.data('color');
            $slider.data('color', colorInfo.cssColor);
            this._updateGradient(isPreview);
            if (isPreview) {
                $slider.data('color', previousColor);
            }
        }
    }
    /**
     * @private
     */
    _updateColorToColornames() {
        this.colorToColorNames = {};
        this.el.querySelectorAll('button[data-color]:not(.o_custom_gradient_btn)').forEach(elem => {
            const colorName = elem.dataset.color;
            if (weUtils.isColorGradient(colorName)) {
                return;
            }
            const $color = $(elem);
            const isCCName = weUtils.isColorCombinationName(colorName);
            if (isCCName) {
                $color.find('.o_we_cc_preview_wrapper').addClass(`o_cc o_cc${colorName}`);
            } else if (weUtils.EDITOR_COLOR_CSS_VARIABLES.includes(colorName)) {
                elem.style.backgroundColor = `var(--we-cp-${colorName})`;
            } else {
                elem.classList.add(`bg-${colorName}`);
            }
            this.colorNames.push(colorName);
            if (!isCCName && !elem.classList.contains('d-none')) {
                const color = weUtils.getCSSVariableValue(colorName, this.style);
                this.colorToColorNames[color] = colorName;
            }
        });
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Called when a color button is clicked.
     *
     * @private
     * @param {Event} ev
     */
    _onColorButtonClick(ev) {
        const buttonEl = ev.currentTarget;
        const colorInfo = {
            ...this._getSelectedColors(),
            ...this._getButtonInfo(buttonEl)
        };
        this._selectColor(colorInfo, this.props.onColorPicked);
    }
    /**
     * Called when a color button is entered.
     *
     * @private
     * @param {Event} ev
     */
    _onColorButtonEnter(ev) {
        this.props.onColorHover({
            ...this._getSelectedColors(),
            ...this._getButtonInfo(ev.currentTarget)
        });
    }
    /**
     * Called when a color button is left the data color is the color currently selected.
     *
     * @private
     * @param {Event} ev
     */
    _onColorButtonLeave(ev) {
        this.props.onColorLeave({
            ...this._getSelectedColors(),
            target: ev.target,
        });
    }
    /**
     * Called when an update is made on the colorpicker.
     *
     * @private
     * @param {Object} colorInfo
     */
    _onColorPickerPreview(colorInfo) {
        this.props.onColorHover({
            ...this._getSelectedColors(),
            color: colorInfo.cssColor,
        });
    }
    /**
     * Called when an update is made on the gradient colorpicker.
     *
     * @private
     * @param {Object} colorInfo
     */
    _onColorPickerPreviewGradient(colorInfo) {
        this._updateGradientColor(colorInfo, true);
    }
    /**
     * Called when a color is selected on the colorpicker (mouseup).
     *
     * @private
     * @param {Object} colorInfo
     */
    _onColorPickerSelect(colorInfo) {
        this._selectColor({
            ...this._getSelectedColors(),
            color: colorInfo.cssColor,
        }, this.props.onCustomColorPicked);
    }
    /**
     * Called when a color is selected on the gradient colorpicker (mouseup).
     *
     * @private
     * @param {Object} colorInfo
     */
    _onColorPickerSelectGradient(colorInfo) {
        this._updateGradientColor(colorInfo);
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onSwitchPaneButtonClick(ev) {
        ev.stopPropagation();
        this._selectTabFromButton(ev.currentTarget);
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientSliderClick(ev) {
        ev.stopPropagation();
        this._activateGradientSlider($(ev.target));
        this._updateGradient();
    }
    /**
     * Adds a color inside the gradient based on the position clicked within the preview.
     *
     * @private
     * @param {Event} ev
     */
    _onGradientPreviewClick(ev) {
        ev.stopPropagation();
        const offset = ev.offsetX;
        const width = parseInt(window.getComputedStyle(ev.target).width, 10);
        const position = 100 * offset / width;

        let previousColor;
        let nextColor;
        let previousPosition;
        let nextPosition;
        for (const slider of $(this.gradientEditorParts.sliders).find('input')) {
            if (slider.value < position) {
                previousColor = slider.dataset.color;
                previousPosition = slider.value;
            } else {
                nextColor = slider.dataset.color;
                nextPosition = slider.value;
                break;
            }
        }
        let color;
        if (previousColor && nextColor) {
            previousColor = convertCSSColorToRgba(previousColor);
            nextColor = convertCSSColorToRgba(nextColor);
            const previousRatio = (nextPosition - position) / (nextPosition - previousPosition);
            const nextRatio = 1 - previousRatio;
            const red = Math.round(previousRatio * previousColor.red + nextRatio * nextColor.red);
            const green = Math.round(previousRatio * previousColor.green + nextRatio * nextColor.green);
            const blue = Math.round(previousRatio * previousColor.blue + nextRatio * nextColor.blue);
            const opacity = Math.round(previousRatio * previousColor.opacity + nextRatio * nextColor.opacity);
            color = `rgba(${red}, ${green}, ${blue}, ${opacity / 100})`;
        } else {
            color = nextColor || previousColor || 'rgba(128, 128, 128, 0.5)';
        }

        const $slider = this._createGradientSlider(position, color);
        this._activateGradientSlider($slider);
        this._updateGradient();
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onPanelClick(ev) {
        // Ignore to avoid closing popup.
        ev.stopPropagation();
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientInputChange(ev) {
        this._updateGradient();
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientInputKeyPress(ev) {
        if (ev.key === "Enter") {
            ev.preventDefault();
            this._onGradientInputChange();
        }
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientButtonClick(ev) {
        const $buttons = $(ev.target).closest('span').find('we-button');
        $buttons.removeClass('active');
        $(ev.target).closest('we-button').addClass('active');
        this._updateGradient();
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientButtonEnter(ev) {
        ev.stopPropagation();
        const $activeButton = $(ev.target).closest('span').find('we-button.active');
        const $buttons = $(ev.target).closest('span').find('we-button');
        $buttons.removeClass('active');
        $(ev.target).closest('we-button').addClass('active');
        this._updateGradient(true);
        $buttons.removeClass('active');
        $activeButton.addClass('active');
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientButtonLeave(ev) {
        ev.stopPropagation();
        this.props.onColorLeave({
            ...this._getSelectedColors(),
            target: ev.target,
        });
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientCustomButtonClick(ev) {
        let gradient = this.gradientEditorParts.customButton.style['backgroundImage'];
        if (!gradient) {
            // default to first predefined
            gradient = this.pickers['predefined_gradients'].querySelector('button').dataset.color;
        }
        this._selectColor({
            ...this._getSelectedColors(),
            color: gradient,
            target: this.gradientEditorParts.customButton,
        }, this.props.onCustomColorPicked);
        this._updateGradient();
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onGradientDeleteClick(ev) {
        ev.stopPropagation();
        const $activeSlider = $(this.pickers['custom_gradient'].querySelector('.o_slider_multi input.active'));
        $activeSlider.off();
        $activeSlider.remove();
        this.gradientEditorParts.deleteButton.classList.add('d-none');
        this.gradientEditorParts.deleteButton.classList.remove('active');
        this._updateGradient();
        this._activateGradientSlider($(this.pickers['custom_gradient'].querySelector('.o_slider_multi input')));
    }
    /**
     * @private
     * @param {Event} ev
     */
    _onColorpickerClick(ev) {
        if (ev.target.matches(".o_colorpicker_section, .o_colorpicker_sections")) {
            ev.stopPropagation();
        }
    }
}

return __exports;
});
;

/**********************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/image_crop.js  *
*  Lines: 341                                                         *
**********************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/image_crop', ['@web_editor/js/editor/image_processing', '@web/core/l10n/translation', '@odoo/owl', '@web/core/utils/hooks', '@web/legacy/js/core/dom'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const {applyModifications, cropperDataFields, activateCropper, loadImage, loadImageInfo} = require("@web_editor/js/editor/image_processing");
const { _t } = require("@web/core/l10n/translation");
const {
    Component,
    useRef,
    useState,
    onMounted,
    onWillDestroy,
    onWillUpdateProps,
    markup,
} = require("@odoo/owl");
const { useService } = require("@web/core/utils/hooks");
const dom = require("@web/legacy/js/core/dom")[Symbol.for("default")];

const ImageCrop = __exports.ImageCrop = class ImageCrop extends Component {
    static template = 'web_editor.ImageCrop';
    static props = {
        rpc: Function,
        showCount: { type: Number, optional: true },
        activeOnStart: { type: Boolean, optional: true },
        media: { optional: true },
        mimetype: { type: String, optional: true },
    };
    static defaultProps = {
        activeOnStart: false,
        showCount: 0,
    };
    aspectRatios = {
        "0/0": {label: _t("Flexible"), value: 0},
        "16/9": {label: "16:9", value: 16 / 9},
        "4/3": {label: "4:3", value: 4 / 3},
        "1/1": {label: "1:1", value: 1},
        "2/3": {label: "2:3", value: 2 / 3},
    };
    state = useState({
        active: false,
    });

    elRef = useRef('el');
    _cropperClosed = true;

    setup() {
        // This promise is resolved when the component is mounted. It is
        // required by a legacy mechanism to wait for the component to be
        // mounted. See `ImageTools.resetCrop`.
        this.mountedPromise = new Promise((resolve) => {
            this.mountedResolve = resolve;
        });
        this.notification = useService("notification");
        onMounted(async () => {
            const $el = $(this.elRef.el);
            this.$ = $el.find.bind($el);
            this.$('[data-action]').on('click', this._onCropOptionClick.bind(this));
            $el.on('zoom', this._onCropZoom.bind(this));
            if (this.props.activeOnStart) {
                this.state.active = true;
                await this._show(this.props);
            }
            this.mountedResolve();
        });
        onWillUpdateProps((newProps) => {
            if (newProps.showCount !== this.props.showCount) {
                this.state.active = true;
            }
            return this._show(newProps);
        });
        onWillDestroy(() => {
            this._closeCropper();
        });
    }

    _closeCropper() {
        if (this._cropperClosed) return;
        this._cropperClosed = true;
        if (this.$cropperImage) {
            this.$cropperImage.cropper('destroy');
            this.elRef.el.ownerDocument.removeEventListener('mousedown', this._onDocumentMousedown, {capture: true});
            this.elRef.el.ownerDocument.removeEventListener('keydown', this._onDocumentKeydown, {capture: true});
        }
        this.media.setAttribute('src', this.initialSrc);
        this.$media.trigger('image_cropper_destroyed');
        this.state.active = false;
    }

    /**
     * Resets the crop
     */
    async reset() {
        if (this.$cropperImage) {
            this.$cropperImage.cropper('reset');
            if (this.aspectRatio !== '0/0') {
                this.aspectRatio = '0/0';
                this.$cropperImage.cropper('setAspectRatio', this.aspectRatios[this.aspectRatio].value);
            }
            await this._save(false);
        }
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    async _show(props) {
        if (!props.media || !this.state.active) {
            return;
        }
        this._cropperClosed = false;
        this.media = props.media;
        this.$media = $(this.media);
        // Needed for editors in iframes.
        this.document = this.media.ownerDocument;
        // key: ratio identifier, label: displayed to user, value: used by cropper lib
        const src = this.media.getAttribute('src');
        const data = {...this.media.dataset};
        this.initialSrc = src;
        this.aspectRatio = data.aspectRatio || "0/0";
        const mimetype = data.mimetype ||
                src.endsWith('.png') ? 'image/png' :
                src.endsWith('.webp') ? 'image/webp' :
                'image/jpeg';
        this.mimetype = this.props.mimetype || mimetype;

        await loadImageInfo(this.media, this.props.rpc);
        const isIllustration = /^\/web_editor\/shape\/illustration\//.test(this.media.dataset.originalSrc);
        this.uncroppable = false;
        if (this.media.dataset.originalSrc && !isIllustration) {
            this.originalSrc = this.media.dataset.originalSrc;
            this.originalId = this.media.dataset.originalId;
        } else {
            // Couldn't find an attachment: not croppable.
            this.uncroppable = true;
        }

        if (this.uncroppable) {
            this.notification.add(
                markup(_t("This type of image is not supported for cropping.<br/>If you want to crop it, please first download it from the original source and upload it in Odoo.")),
                {
                    title: _t("This image is an external image"),
                    type: 'warning',
                }
            )
            return this._closeCropper();
        }
        const $cropperWrapper = this.$('.o_we_cropper_wrapper');

        await this._scrollToInvisibleImage();
        // Replacing the src with the original's so that the layout is correct.
        await loadImage(this.originalSrc, this.media);
        this.$cropperImage = this.$('.o_we_cropper_img');
        const cropperImage = this.$cropperImage[0];
        [cropperImage.style.width, cropperImage.style.height] = [this.$media.width() + 'px', this.$media.height() + 'px'];
        
        const sel = this.document.getSelection();
        sel && sel.removeAllRanges();

        // Overlaying the cropper image over the real image
        const offset = this.$media.offset();
        offset.left += parseInt(this.$media.css('padding-left'));
        offset.top += parseInt(this.$media.css('padding-right'));
        $cropperWrapper[0].style.left = `${offset.left}px`;
        $cropperWrapper[0].style.top = `${offset.top}px`;

        await loadImage(this.originalSrc, cropperImage);

        // We need to remove the d-none class for the cropper library to work.
        this.elRef.el.classList.remove('d-none');
        await activateCropper(cropperImage, this.aspectRatios[this.aspectRatio].value, this.media.dataset);

        this._onDocumentMousedown = this._onDocumentMousedown.bind(this);
        this._onDocumentKeydown = this._onDocumentKeydown.bind(this);
        // We use capture so that the handler is called before other editor handlers
        // like save, such that we can restore the src before a save.
        // We need to add event listeners to the owner document of the widget.
        this.elRef.el.ownerDocument.addEventListener('mousedown', this._onDocumentMousedown, {capture: true});
        this.elRef.el.ownerDocument.addEventListener('keydown', this._onDocumentKeydown, {capture: true});
    }
    /**
     * Updates the DOM image with cropped data and associates required
     * information for a potential future save (where required cropped data
     * attachments will be created).
     *
     * @private
     * @param {boolean} [cropped=true]
     */
    async _save(cropped = true) {
        // Mark the media for later creation of cropped attachment
        this.media.classList.add('o_modified_image_to_save');

        [...cropperDataFields, 'aspectRatio'].forEach(attr => {
            delete this.media.dataset[attr];
            const value = this._getAttributeValue(attr);
            if (value) {
                this.media.dataset[attr] = value;
            }
        });
        delete this.media.dataset.resizeWidth;
        this.initialSrc = await applyModifications(this.media, {forceModification: true, mimetype: this.mimetype});
        this.media.classList.toggle('o_we_image_cropped', cropped);
        this.$media.trigger('image_cropped');
        this._closeCropper();
    }
    /**
     * Returns an attribute's value for saving.
     *
     * @private
     */
    _getAttributeValue(attr) {
        if (cropperDataFields.includes(attr)) {
            return this.$cropperImage.cropper('getData')[attr];
        }
        return this[attr];
    }
    /**
     * Resets the crop box to prevent it going outside the image.
     *
     * @private
     */
    _resetCropBox() {
        this.$cropperImage.cropper('clear');
        this.$cropperImage.cropper('crop');
    }
    /**
     * Make sure the targeted image is in the visible viewport before crop.
     *
     * @private
     */
    async _scrollToInvisibleImage() {
        const rect = this.media.getBoundingClientRect();
        const viewportTop = this.document.documentElement.scrollTop || 0;
        const viewportBottom = viewportTop + window.innerHeight;
        const closestScrollable = el => {
            if (!el) {
                return null;
            }
            if (el.scrollHeight > el.clientHeight) {
                return $(el);
            } else {
                return closestScrollable(el.parentElement);
            }
        };
        // Give priority to the closest scrollable element (e.g. for images in
        // HTML fields, the element to scroll is different from the document's
        // scrolling element).
        const $scrollable = closestScrollable(this.media);

        // The image must be in a position that allows access to it and its crop
        // options buttons. Otherwise, the crop widget container can be scrolled
        // to allow editing.
        if (rect.top < viewportTop || viewportBottom - rect.bottom < 100) {
            await dom.scrollTo(this.media, {
                easing: "linear",
                duration: 500,
                ...($scrollable && { $scrollable }),
            });
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Called when a crop option is clicked -> change the crop area accordingly.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onCropOptionClick(ev) {
        const {action, value, scaleDirection} = ev.currentTarget.dataset;
        switch (action) {
            case 'ratio':
                this.$cropperImage.cropper('reset');
                this.aspectRatio = value;
                this.$cropperImage.cropper('setAspectRatio', this.aspectRatios[this.aspectRatio].value);
                break;
            case 'zoom':
            case 'reset':
                this.$cropperImage.cropper(action, value);
                break;
            case 'rotate':
                this.$cropperImage.cropper(action, value);
                this._resetCropBox();
                break;
            case 'flip': {
                const amount = this.$cropperImage.cropper('getData')[scaleDirection] * -1;
                return this.$cropperImage.cropper(scaleDirection, amount);
            }
            case 'apply':
                return this._save();
            case 'discard':
                return this._closeCropper();
        }
    }
    /**
     * Discards crop if the user clicks outside of the widget.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onDocumentMousedown(ev) {
        if (this.elRef.el.ownerDocument.body.contains(ev.target) && this.$(ev.target).length === 0) {
            return this._closeCropper();
        }
    }
    /**
     * Save crop if user hits enter,
     * discard crop on escape.
     *
     * @private
     * @param {KeyboardEvent} ev
     */
    _onDocumentKeydown(ev) {
        if (ev.key === 'Enter') {
            return this._save();
        } else if (ev.key === 'Escape') {
            ev.stopImmediatePropagation();
            return this._closeCropper();
        }
    }
    /**
     * Resets the cropbox on zoom to prevent crop box overflowing.
     *
     * @private
     */
    async _onCropZoom() {
        // Wait for the zoom event to be fully processed before reseting.
        await new Promise(res => setTimeout(res, 0));
        this._resetCropBox();
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/link.js  *
*  Lines: 718                                                   *
****************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/link', ['@web_editor/js/editor/odoo-editor/src/OdooEditor', '@web/core/l10n/translation', '@web/core/utils/ui', '@web_editor/js/common/utils', '@odoo/owl', '@web_editor/js/editor/odoo-editor/src/utils/sanitize'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const OdooEditorLib = require("@web_editor/js/editor/odoo-editor/src/OdooEditor");
const { _t } = require("@web/core/l10n/translation");
const { isVisible } = require("@web/core/utils/ui");
const weUtils = require("@web_editor/js/common/utils")[Symbol.for("default")];
const {
    Component,
    onWillStart,
    onMounted,
    onWillUpdateProps,
    onWillDestroy,
    useState,
    useRef,
} = require("@odoo/owl");
const { deduceURLfromText } = require("@web_editor/js/editor/odoo-editor/src/utils/sanitize");

const { getDeepRange, getInSelection, EMAIL_REGEX, PHONE_REGEX } = OdooEditorLib;

/**
 * Allows to customize link content and style.
 */
const Link = __exports.Link = class Link extends Component {
    static props = {
        editable: true,
        link: true,
        needLabel: { type: Boolean, optional: true },
        forceNewWindow: { type: Boolean, optional: true },
        initialIsNewWindow: { type: Boolean, optional: true },
        shouldFocusUrl: { type: Boolean, optional: true },
    };
    static defaultProps = {
        needLabel: true,
        forceNewWindow: false,
        initialIsNewWindow: false,
        shouldFocusUrl: false,
    }
    linkComponentWrapperRef = useRef("linkComponentWrapper");
    colorsData = [
        {type: '', label: _t("Link"), btnPreview: 'link'},
        {type: 'primary', label: _t("Primary"), btnPreview: 'primary'},
        {type: 'secondary', label: _t("Secondary"), btnPreview: 'secondary'},
        {type: 'custom', label: _t("Custom"), btnPreview: 'custom'},
        // Note: by compatibility the dialog should be able to remove old
        // colors that were suggested like the BS status colors or the
        // alpha -> epsilon classes. This is currently done by removing
        // all btn-* classes anyway.
    ];
    setup() {
        this.state = useState({});
        // We need to wait for the `onMounted` changes to be done before
        // accessing `this.$el`.
        this.mountedPromise = new Promise(resolve => this.mountedResolve = resolve);

        onWillStart(() => this._updateState(this.props));
        let started = false;
        onMounted(async () => {
            if (started) {
                return;
            }
            started = true;
            if (!this.linkComponentWrapperRef.el) {
                // There is legacy code that can trigger the instantiation of the
                // link tool when it's parent component (the toolbar) is not in the
                // dom. If the parent element is not in the dom, owl will not return
                // `this.linkComponentWrapperRef.el` because of a check (see
                // `inOwnerDocument`).
                // Todo: this workaround should be removed when the snippet menu is
                // converted to owl.
                await new Promise(resolve => {
                    const observer = new MutationObserver(() => {
                        if (this.linkComponentWrapperRef.el) {
                            observer.disconnect();
                            resolve();
                        }
                    });
                    observer.observe(document.body, { childList: true, subtree: true });
                });
            }
            this.$el = $(this.linkComponentWrapperRef.el);

            this.$el.find('input, select').on('input', this._onAnyChange.bind(this));
            this.$el.find('input, select').on('change', this._onAnyChange.bind(this));
            this.$el.find('[name="url"]').on('input', this.__onURLInput.bind(this));
            this.$el.find('[name="url"]').on('change', this._onURLInputChange.bind(this));

            await this.start();
            this.mountedResolve();
        });
        onWillUpdateProps(async (newProps) => {
            await this.mountedPromise;
            this._updateState(newProps);
            this.state.url = newProps.link.getAttribute('href') || '';
            this._setUrl({ shouldFocus: newProps.shouldFocusUrl });
        });
        onWillDestroy(() => {
            this.destroy();
        });
    }
    /**
     * @override
     */
    async start() {
        this._setSelectOptionFromLink();

        this._updateOptionsUI();

        this.$el[0].querySelector('#o_link_dialog_label_input').value = this.state.originalText;
        this._setUrl({ shouldFocus: this.props.shouldFocusUrl });
    }
    /**
     * @override
     */
    destroy () {
        if (this._savedURLInputOnDestroy) {
            this._adaptPreview();
        }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Apply the new link to the DOM (via `this.$link`).
     *
     * @param {object} data
     */
    applyLinkToDom(data) {
        // Some mass mailing template use <a class="btn btn-link"> instead of just a simple <a>.
        // And we need to keep the classes because the a.btn.btn-link have some special css rules.
        // Same thing for the "btn-success" class, this class cannot be added
        // by the options but we still have to ensure that it is not removed if
        // it exists in a template (e.g. "Newsletter Block" snippet).
        if (!data.classes.split(' ').includes('btn')) {
            for (const linkClass of this.toleratedClasses) {
                if (this.state.iniClassName && this.state.iniClassName.split(' ').includes(linkClass)) {
                    data.classes += " btn " + linkClass;
                }
            }
        }
        // When multiple buttons follow each other, they may break on 2 lines
        // or more on mobile, so they need a margin-bottom.
        if (data.classes.split(" ").includes("btn")) {
            const closestButtonSiblingEls = this._getDirectButtonSiblings(this.linkEl);
            if (closestButtonSiblingEls.length) {
                data.classes += " mb-2";
                closestButtonSiblingEls.forEach(btnEl => btnEl.classList.add("mb-2"));
            }
        }
        if (['btn-custom', 'btn-outline-custom', 'btn-fill-custom'].some(className =>
            data.classes.includes(className)
        )) {
            this.$link.css('color', data.classes.includes(data.customTextColor) ? '' : data.customTextColor);
            this.$link.css('background-color', data.classes.includes(data.customFill) || weUtils.isColorGradient(data.customFill) ? '' : data.customFill);
            this.$link.css('background-image', weUtils.isColorGradient(data.customFill) ? data.customFill : '');
            this.$link.css('border-width', data.customBorderWidth);
            this.$link.css('border-style', data.customBorderStyle);
            this.$link.css('border-color', data.customBorder);
        } else {
            this.$link.css('color', '');
            this.$link.css('background-color', '');
            this.$link.css('background-image', '');
            this.$link.css('border-width', '');
            this.$link.css('border-style', '');
            this.$link.css('border-color', '');
        }
        const attrs = Object.assign({}, this.state.oldAttributes, {
            href: data.url,
            target: data.isNewWindow ? '_blank' : '',
        });
        if (typeof data.classes === "string") {
            data.classes = data.classes.replace(/o_default_snippet_text/, '');
            attrs.class = `${data.classes}`;
        }
        if (data.rel) {
            attrs.rel = `${data.rel}`;
        }

        this.$link.attr(attrs);
        if (!this.$link.attr('target')) {
            this.$link[0].removeAttribute('target');
        }
        this._updateLinkContent(this.$link, data);
    }
    /**
     * Focuses the url input.
     */
    focusUrl() {
        const urlInput = this.$el[0].querySelector('input[name="url"]');
        urlInput.focus();
        urlInput.select();
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _setUrl({ shouldFocus } = {}) {
        if (this.state.url) {
            const protocolLessUrl = this.state.url.replace(/^(https?|mailto|tel):(\/\/)?/i, '');
            this.$el.find('input[name="url"]').val(protocolLessUrl);
            this._onURLInput();
            this._savedURLInputOnDestroy = false;
        }
        if (shouldFocus) {
            this.focusUrl();
        }
    }
    /**
     * @private
     */
    _setSelectOptionFromLink() {
        for (const option of this._getLinkOptions()) {
            const $option = $(option);
            const value = $option.is('input') ? $option.val() : $option.data('value') || option.getAttribute('value');
            let active = false;
            if (value) {
                const subValues = value.split(',');
                let subActive = true;
                for (let subValue of subValues) {
                    const classPrefix = new RegExp('(^|btn-| |btn-outline-|btn-fill-)' + subValue);
                    subActive = subActive && classPrefix.test(this.state.iniClassName);
                }
                active = subActive;
            } else {
                active = !this.state.iniClassName
                         || this.toleratedClasses.some(val => this.state.iniClassName.split(' ').includes(val))
                         || !this.state.iniClassName.includes('btn-');
            }
            this._setSelectOption($option, active);
        }
    }
    /**
     * Abstract method: adapt the link to changes.
     *
     * @abstract
     * @private
     */
    _adaptPreview() {}
    /**
     * @private
     */
    _correctLink(url) {
        if (url.indexOf('tel:') === 0) {
            url = url.replace(/^tel:([0-9]+)$/, 'tel://$1');
        } else if (url && !url.startsWith('mailto:') && url.indexOf('://') === -1
                    && url[0] !== '/' && url[0] !== '#' && url.slice(0, 2) !== '${') {
            url = 'http://' + url;
        }
        return url;
    }
    _deduceUrl(text) {
        text = text.trim();
        if (/^(https?:|mailto:|tel:)/.test(text)) {
            // Text begins with a known protocol, accept it as valid URL.
            return text;
        } else {
            return deduceURLfromText(text, this.linkEl) || '';
        }
    }
    /**
     * Abstract method: return true if the URL should be stripped of its domain.
     *
     * @abstract
     * @private
     * @returns {boolean}
     */
    _doStripDomain() {}
    /**
     * Get the link's data (url, content and styles).
     *
     * @private
     * @returns {Object} {content: String, url: String, classes: String, isNewWindow: Boolean}
     */
    _getData() {
        var $url = this.$el.find('input[name="url"]');
        var url = $url.val();
        var content = this.$el.find('input[name="label"]').val() || url;

        if (!this.state.isButton && $url.prop('required') && (!url || !$url[0].checkValidity())) {
            return null;
        }

        const type = this._getLinkType();
        const customTextColor = this._getLinkCustomTextColor();
        const customFill = this._getLinkCustomFill();
        const customBorder = this._getLinkCustomBorder();
        const customBorderWidth = this._getLinkCustomBorderWidth();
        const customBorderStyle = this._getLinkCustomBorderStyle();
        const customClasses = this._getLinkCustomClasses();
        const size = this._getLinkSize();
        const shape = this._getLinkShape();
        const shapes = shape ? shape.split(',') : [];
        const style = ['outline', 'fill'].includes(shapes[0]) ? `${shapes[0]}-` : '';
        const shapeClasses = shapes.slice(style ? 1 : 0).join(' ');
        const classes = (this.state.className || '') +
            (type ? (` btn btn-${style}${type}`) : '') +
            (type === 'custom' ? customClasses : '') +
            (type && shapeClasses ? (` ${shapeClasses}`) : '') +
            (type && size ? (' btn-' + size) : '');
        var isNewWindow = this._isNewWindow(url);
        var doStripDomain = this._doStripDomain();
        if (this.state.url.indexOf(location.origin) === 0 && doStripDomain) {
            this.state.url = this.state.url.slice(location.origin.length);
        }
        var allWhitespace = /\s+/gi;
        var allStartAndEndSpace = /^\s+|\s+$/gi;
        const isImage = this.props.link && this.props.link.querySelector('img');
        return {
            content: content,
            url: this._correctLink(this.state.url),
            classes: classes.replace(allWhitespace, ' ').replace(allStartAndEndSpace, ''),
            customTextColor: customTextColor,
            customFill: customFill,
            customBorder: customBorder,
            customBorderWidth: customBorderWidth,
            customBorderStyle: customBorderStyle,
            oldAttributes: this.state.oldAttributes,
            isNewWindow: isNewWindow,
            doStripDomain: doStripDomain,
            isImage,
        };
    }
    /**
     * Return a list of all the descendants of a given element.
     *
     * @private
     * @param {Node} rootNode
     * @returns {Node[]}
     */
    _getDescendants(rootNode) {
        const nodes = [];
        for (const node of rootNode.childNodes) {
            nodes.push(node);
            nodes.push(...this._getDescendants(node));
        }
        return nodes;
    }
    /**
     * Abstract method: return a JQuery object containing the UI elements
     * holding the "Open in new window" option's row of the link.
     *
     * @abstract
     * @private
     * @returns {JQuery}
     */
    _getIsNewWindowFormRow() {}
    /**
     * Abstract method: return a JQuery object containing the UI elements
     * holding the styling options of the link (eg: color, size, shape).
     *
     * @abstract
     * @private
     * @returns {JQuery}
     */
    _getLinkOptions() {}
    /**
     * Abstract method: return the shape(s) to apply to the link (eg:
     * "outline", "rounded-circle", "outline,rounded-circle").
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkShape() {}
    /**
     * Abstract method: return the size to apply to the link (eg:
     * "sm", "lg").
     *
     * @private
     * @returns {string}
     */
    _getLinkSize() {}
    /**
     * Abstract method: return the type to apply to the link (eg:
     * "primary", "secondary").
     *
     * @private
     * @returns {string}
     */
    _getLinkType() {}
    /**
     * Returns the custom text color for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomTextColor() {}
    /**
     * Returns the custom border color for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomBorder() {}
    /**
     * Returns the custom border width for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomBorderWidth() {}
    /**
     * Returns the custom border style for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomBorderStyle() {}
    /**
     * Returns the custom fill color for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomFill() {}
    /**
     * Returns the custom text, fill and border color classes for custom type.
     *
     * @abstract
     * @private
     * @returns {string}
     */
    _getLinkCustomClasses() {}
    /**
     * @private
     */
    _isFromAnotherHostName(url) {
        if (url.includes(window.location.hostname)) {
            return false;
        }
        try {
            const Url = URL || window.URL || window.webkitURL;
            const urlObj = url.startsWith('/') ? new Url(url, window.location.origin) : new Url(url);
            return (urlObj.origin !== window.location.origin);
        } catch {
            return true;
        }
    }
    /**
     * Abstract method: return true if the link should open in a new window.
     *
     * @abstract
     * @private
     * @returns {boolean}
     */
    _isNewWindow(url) {}
    /**
     * Abstract method: mark one or several options as active or inactive.
     *
     * @abstract
     * @private
     * @param {JQuery} $option
     * @param {boolean} [active]
     */
    _setSelectOption($option, active) {}
    /**
     * Update the link content.
     *
     * @private
     * @param {JQuery} $link
     * @param {object} linkInfos
     * @param {boolean} force
     */
    _updateLinkContent($link, linkInfos, { force = false } = {}) {
        if (force || (this.props.needLabel && (linkInfos.content !== this.state.originalText || linkInfos.url !== this.state.url))) {
            if (linkInfos.content === this.state.originalText || linkInfos.isImage) {
                $link.html(this.state.originalHTML.replaceAll('\u200B', '').replaceAll('\uFEFF', ''));
            } else if (linkInfos.content && linkInfos.content.length) {
                let contentWrapperEl = $link[0];
                const text = $link[0].innerText.replaceAll("\u200B", "").replaceAll("\uFEFF", "").trim();
                // Update the first not ZWS child element that has the same inner text
                // as the link with the new content while preserving child
                // elements within the link. (e.g. the link is bold and italic)
                let child;
                do {
                    contentWrapperEl = child || contentWrapperEl;
                    child = [...contentWrapperEl.children].find(
                        (element) => !element.hasAttribute("data-o-link-zws")
                    );
                } while (child?.innerText.replaceAll('\u200B', '').replaceAll('\uFEFF', '').trim() === text);
                contentWrapperEl.innerText = linkInfos.content;
            } else {
                $link.text(linkInfos.url);
            }
        }
    }
    /**
     * @abstract
     * @private
     */
    _updateOptionsUI() {}
    /**
     * Update the state.
     *
     * @private
     */
    async _updateState(props) {
        this.initialNewWindow = props.initialIsNewWindow;

        this.state.className = "";
        this.state.iniClassName = "";

        // The classes in the following array should not be in editable areas
        // but as there are still some (e.g. in the "newsletter block" snippet)
        // we make sure the options system works with them.
        this.toleratedClasses = ['btn-link', 'btn-success'];

        this.editable = props.editable;
        this.$editable = $(this.editable);

        if (props.link) {
            const range = document.createRange();
            range.selectNodeContents(props.link);
            this.state.range = range;
            this.$link = $(props.link);
            this.linkEl = props.link;
        }

        if (this.state.range) {
            this.$link = this.$link || $(OdooEditorLib.getInSelection(this.editable.ownerDocument, 'a'));
            this.linkEl = this.$link[0];
            this.state.iniClassName = this.$link.attr('class') || '';
            this.colorCombinationClass = false;
            let $node = this.$link;
            while ($node.length && !$node.is('body')) {
                const className = $node.attr('class') || '';
                const m = className.match(/\b(o_cc\d+)\b/g);
                if (m) {
                    this.colorCombinationClass = m[0];
                    break;
                }
                $node = $node.parent();
            }
            const linkNode = this.$link[0] || this.state.range.cloneContents();
            const linkText = weUtils.getLinkLabel(linkNode);
            this.state.originalText = linkText.replace(/[ \t\r\n]+/g, ' ');
            if (linkNode instanceof DocumentFragment) {
                this.state.originalHTML = $('<fakeEl>').append(linkNode).html();
            } else {
                this.state.originalHTML = linkNode.innerHTML;
            }
            this.state.url = this.$link.attr('href') || '';
        } else {
            this.state.originalText = this.state.originalText ? this.state.originalText.replace(/[ \t\r\n]+/g, ' ') : '';
        }

        this.state.url ||= this._deduceUrl(this.state.originalText, this.linkEl);

        if (this.linkEl) {
            this.initialNewWindow = this.initialNewWindow || this.linkEl.target === '_blank';
        }

        const classesToKeep = [
            'text-wrap', 'text-nowrap', 'text-start', 'text-center', 'text-end',
            'text-truncate',
        ];
        const keptClasses = this.state.iniClassName.split(' ').filter(className => classesToKeep.includes(className));
        const allBtnColorPrefixes = /(^|\s+)(bg|text|border)((-[a-z0-9_-]*)|\b)/gi;
        const allBtnClassSuffixes = /(^|\s+)btn((-[a-z0-9_-]*)|\b)/gi;
        const allBtnShapes = /\s*(rounded-circle|flat)\s*/gi;
        const btnMarginBottom = /(^|\s+)mb-2(\s+|$)/i;
        this.state.className = this.state.iniClassName
            .replace(allBtnColorPrefixes, ' ')
            .replace(allBtnClassSuffixes, ' ')
            .replace(allBtnShapes, " ")
            .replace(btnMarginBottom, " ");
        this.state.className += ' ' + keptClasses.join(' ');
        // 'o_submit' class will force anchor to be handled as a button in linkdialog.
        if (/(?:s_website_form_send|o_submit)/.test(this.state.className)) {
            this.state.isButton = true;
        }
    }
    /**
     * Returns an array of the buttons which are the closest non empty
     * previousSibling and/or nextSibling.
     *
     * @param {HTMLElement} el
     * @returns {HTMLElement[]}
     */
    _getDirectButtonSiblings(el) {
        return ["previous", "next"].reduce((buttonSiblingsEls, side) => {
            let siblingNode = el[`${side}Sibling`];
            while (siblingNode) {
                // If the node is an empty text node, or if it is a <br> tag or
                // an invisible element, it is not taken into account.
                if ((siblingNode.nodeType === 3 && !!siblingNode.textContent.match(/^\s*$/)) ||
                        (siblingNode.nodeType === 1 &&
                        (siblingNode.nodeName === "BR" || !isVisible(siblingNode)))) {
                    siblingNode = siblingNode[`${side}Sibling`];
                    continue;
                }
                if (siblingNode.nodeType === 1 && siblingNode.classList.contains("btn")) {
                    buttonSiblingsEls.push(siblingNode);
                }
                break;
            }
            return buttonSiblingsEls;
        }, []);
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onAnyChange(e) {
        if (!e.target.closest('input[type="text"]')) {
            this._adaptPreview();
        }
    }
    /**
     * @todo Adapt in master: in stable _onURLInput was both used as an event
     * handler responding to url input events + a private method called at the
     * widget lifecycle start. Originally both points were to update the link
     * tools/dialog UI. It was later wanted to actually update the DOM... but
     * should only be done in event handler part.
     *
     * This allows to differentiate the event handler part. In master, we should
     * take the opportunity to also update the `_updatePreview` concept which
     * updates the "preview" of the original link dialog but actually updates
     * the real DOM for the "new" link tools.
     *
     * @private
     */
    __onURLInput() {
        const inputValue = this.$el[0].querySelector('#o_link_dialog_url_input').value;
        this.state.url = this._deduceUrl(inputValue, this.linkEl) || inputValue;
        this._onURLInput(...arguments);
    }
    /**
     * @private
     */
    _onURLInput() {
        this._savedURLInputOnDestroy = true;
        var $linkUrlInput = this.$el.find('#o_link_dialog_url_input');
        let value = $linkUrlInput.val();
        let isLink = !EMAIL_REGEX.test(value) && !PHONE_REGEX.test(value);
        this._getIsNewWindowFormRow().toggleClass('d-none', !isLink);
        this.$el.find('.o_strip_domain').toggleClass('d-none', value.indexOf(window.location.origin) !== 0);
    }
    /**
     * @private
     */
    _onURLInputChange() {
        this._adaptPreview();
        this._savedURLInputOnDestroy = false;
    }
}

/**
 * Return the link element to edit. Create one from selection if none was
 * present in selection.
 *
 * @param {Node} [options.containerNode]
 * @param {Node} [options.startNode]
 * @returns {Object}
 */
__exports.getOrCreateLink = getOrCreateLink; function getOrCreateLink({ containerNode, startNode } = {}) {
    if (startNode) {
        if ($(startNode).is('a')) {
            return { link: startNode, needLabel: false };
        } else {
            $(startNode).wrap('<a href="#"/>');
            return { link: startNode.parentElement, needLabel: false };
        }
    }

    const doc = containerNode && containerNode.ownerDocument || document;
    let needLabel = false;
    let link = getInSelection(doc, 'a');
    const $link = $(link);
    const range = getDeepRange(containerNode, {splitText: true, select: true, correctTripleClick: true});
    if (!range) {
        return {};
    }
    const isContained = containerNode.contains(range.startContainer) && containerNode.contains(range.endContainer);
    if (link && (!$link.has(range.startContainer).length || !$link.has(range.endContainer).length)) {
        // Expand the current link to include the whole selection.
        let before = link.previousSibling;
        while (before !== null && range.intersectsNode(before)) {
            link.insertBefore(before, link.firstChild);
            before = link.previousSibling;
        }
        let after = link.nextSibling;
        while (after !== null && range.intersectsNode(after)) {
            link.appendChild(after);
            after = link.nextSibling;
        }
    } else if (!link && isContained) {
        link = document.createElement('a');
        if (range.collapsed) {
            range.insertNode(link);
            needLabel = true;
        } else {
            link.appendChild(range.extractContents());
            range.insertNode(link);
        }
    }
    return { link, needLabel };
};

return __exports;
});
;

/***********************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/link_dialog.js  *
*  Lines: 195                                                          *
***********************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/link_dialog', ['@odoo/owl', '@web/core/dialog/dialog', '@web_editor/js/wysiwyg/widgets/link'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { onMounted, useRef } = require("@odoo/owl");
const { Dialog } = require("@web/core/dialog/dialog");
const { Link } = require("@web_editor/js/wysiwyg/widgets/link");

const LinkDialog = __exports.LinkDialog = class LinkDialog extends Link {
    static components = { Dialog };
    static template = 'web_editor.LinkDialog';
    static props = {
        ...Link.props,
        focusField: { type: String, optional: true },
        close: { type: Function },
        onClose: { type: Function },
        onSave: { type: Function },
    };
    inputTextRef = useRef('inputText');
    inputUrlRef = useRef('inputUrl');

    setup() {
        super.setup();
        onMounted(() => {
            this.$el.find('[name="link_style_color"]').on('change', this._onTypeChange.bind(this));
            this.$el.find('input[name="label"]').on('input', this._adaptPreview.bind(this));
            const el = this.props.focusField === 'url' ? this.inputUrlRef.el : this.inputTextRef.el;
            el.focus();
        });
        this.env.dialogData.close = () => this.onDiscard();
    }

    /**
     * @override
     */
    start() {
        super.start();
        this.buttonOptsCollapseEl = this.linkComponentWrapperRef.el.querySelector('#o_link_dialog_button_opts_collapse');
        this.$styleInputs = this.$el.find('input.link-style');
        this.$styleInputs.prop('checked', false).filter('[value=""]').prop('checked', true);
        if (this.initialNewWindow) {
            this.$el.find('we-button.o_we_checkbox_wrapper').toggleClass('active', true);
        }
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    onSave() {
        var data = this._getData();
        if (data === null) {
            var $url = this.$el.find('input[name="url"]');
            $url.closest('.o_url_input').addClass('o_has_error').find('.form-control, .form-select').addClass('is-invalid');
            $url.focus();
            return;
        }
        var allWhitespace = /\s+/gi;
        var allStartAndEndSpace = /^\s+|\s+$/gi;
        var allBtnTypes = /(^|[ ])(btn-secondary|btn-success|btn-primary|btn-info|btn-warning|btn-danger)([ ]|$)/gi;
        data.classes = data.classes.replace(allWhitespace, ' ').replace(allStartAndEndSpace, '');
        if (data.classes.replace(allBtnTypes, ' ')) {
            data.style = {
                'background-color': '',
                'color': '',
            };
        }
        data.linkDialog = this;
        this.props.close();
        this.props.onSave(data);
    }

    onDiscard() {
        this.props.onClose();
        this.props.close();
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    _adaptPreview() {
        var data = this._getData();
        if (data === null) {
            return;
        }
        const attrs = {
            target: '_blank',
            href: data.url && data.url.length ? data.url : '#',
            class: `${data.classes.replace(/float-\w+/, '')} o_btn_preview`,
        };

        const $linkPreview = this.$el.find("#link-preview");
        $linkPreview.attr(attrs);
        this._updateLinkContent($linkPreview, data, { force: true });
    }
    /**
     * @override
     */
    _doStripDomain() {
        return this.$el.find('#o_link_dialog_url_strip_domain').prop('checked');
    }
    /**
     * @override
     */
    _getIsNewWindowFormRow() {
        return this.$el.find('input[name="is_new_window"]').closest('.row');
    }
    /**
     * @override
     */
    _getLinkOptions() {
        const options = [
            'input[name="link_style_color"]',
            'select[name="link_style_size"] > option',
            'select[name="link_style_shape"] > option',
        ];
        return this.$el.find(options.join(','));
    }
    /**
     * @override
     */
    _getLinkShape() {
        return this.$el.find('select[name="link_style_shape"]').val() || '';
    }
    /**
     * @override
     */
    _getLinkSize() {
        return this.$el.find('select[name="link_style_size"]').val() || '';
    }
    /**
     * @override
     */
    _getLinkType() {
        return this.$el.find('input[name="link_style_color"]:checked').val() || '';
    }
    /**
     * @override
     */
    _isNewWindow(url) {
        if (this.props.forceNewWindow) {
            return this._isFromAnotherHostName(url);
        } else {
            return this.$el.find('input[name="is_new_window"]').prop('checked');
        }
    }
    /**
     * @override
     */
    _setSelectOption($option, active) {
        if ($option.is("input")) {
            $option.prop("checked", active);
        } else if (active) {
            $option.parent().find('option').removeAttr('selected').removeProp('selected');
            $option.parent().val($option.val());
            $option.attr('selected', 'selected').prop('selected', 'selected');
        }
    }
    /**
     * @override
     */
    _updateOptionsUI() {
        const el = this.linkComponentWrapperRef.el.querySelector('[name="link_style_color"]:checked');
        $(this.buttonOptsCollapseEl).collapse(el && el.value ? 'show' : 'hide');
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onTypeChange() {
        this._updateOptionsUI();
    }
    /**
     * @override
     */
    _onURLInput() {
        this.$el.find('#o_link_dialog_url_input').closest('.o_url_input').removeClass('o_has_error').find('.form-control, .form-select').removeClass('is-invalid');
        this._adaptPreview();
    }
}

return __exports;
});
;

/*******************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/link_popover_widget.js  *
*  Lines: 336                                                                  *
*******************************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/link_popover_widget', ['@web/core/l10n/translation', '@web_editor/js/common/wysiwyg_utils', '@web/core/utils/concurrency', '@web/core/browser/browser'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { _t } = require("@web/core/l10n/translation");
const { ancestors } = require('@web_editor/js/common/wysiwyg_utils');
const { KeepLast } = require('@web/core/utils/concurrency');
const { browser } = require("@web/core/browser/browser");

const LinkPopoverWidget = __exports.LinkPopoverWidget = class LinkPopoverWidget {
    static createFor(params) {
        const noLinkPopoverClass = ".o_no_link_popover, .carousel-control-prev, .carousel-control-next, .dropdown-toggle";
        // Target might already have a popover, eg cart icon in navbar
        const alreadyPopover = $(params.target).data('bs.popover');
        if (alreadyPopover || $(params.target).is(noLinkPopoverClass) || !!$(params.target).parents(noLinkPopoverClass).length) {
            return null;
        }
        const popoverWidget = new this(params);
        params.wysiwyg?.odooEditor.observerUnactive('LinkPopoverWidget');
        popoverWidget.start(); // This is not async
        params.wysiwyg?.odooEditor.observerActive('LinkPopoverWidget');
        return popoverWidget;
    };

    template = `
        <div class="d-flex">
            <span class="me-2 o_we_preview_favicon"><i class="fa fa-globe"></i><img class="align-baseline d-none"></img></span>
            <div class="w-100">
                <div class="d-flex">
                    <a href="#" target="_blank" class="o_we_url_link fw-bold flex-grow-1 text-truncate" title="${_t('Open in a new tab')}"></a>
                    <a href="#" class="mx-1 o_we_copy_link text-dark" data-bs-toggle="tooltip" data-bs-placement="top" title="${_t('Copy Link')}">
                        <i class="fa fa-clone"></i>
                    </a>
                    <a href="#" class="mx-1 o_we_edit_link text-dark" data-bs-toggle="tooltip" data-bs-placement="top" title="${_t('Edit Link')}">
                        <i class="fa fa-edit"></i>
                    </a>
                    <a href="#" class="ms-1 o_we_remove_link text-dark" data-bs-toggle="tooltip" data-bs-placement="top" title="${_t('Remove Link')}">
                        <i class="fa fa-chain-broken"></i>
                    </a>
                </div>
                <a href="#" target="_blank" class="o_we_full_url mt-1 text-muted d-none" title="${_t('Open in a new tab')}"></a>
            </div>
        </div>
    `;

    constructor(params) {
        const template = document.createElement('template');
        template.innerHTML = this.template;
        this.el = template.content.firstElementChild;
        this.$el = $(this.el);

        this.wysiwyg = params.wysiwyg;
        this.target = params.target;
        this.notify = params.notify;
        this.$target = $(params.target);
        this.container = params.container || this.target.ownerDocument.body;
        this.href = this.$target.attr('href'); // for template
        this._keepLastPromise = new KeepLast();
    }

    /**
     *
     * @override
     */
    start() {
        this.$urlLink = this.$el.find('.o_we_url_link');
        this.$previewFaviconImg = this.$el.find('.o_we_preview_favicon img');
        this.$previewFaviconFa = this.$el.find('.o_we_preview_favicon .fa');
        this.$copyLink = this.$el.find('.o_we_copy_link');
        this.$fullUrl = this.$el.find('.o_we_full_url');

        this.$urlLink.attr('href', this.href);
        this.$fullUrl.attr('href', this.href);
        this.$el.find(`.o_we_edit_link`).on('click', this._onEditLinkClick.bind(this));
        this.$el.find(`.o_we_remove_link`).on('click', this._onRemoveLinkClick.bind(this));

        this.$copyLink.on("click", this._onCopyLinkClick.bind(this));

        // init tooltips & popovers
        this.$el.find('[data-bs-toggle="tooltip"]').tooltip({
            delay: 0,
            placement: 'bottom',
            container: this.container,
        });
        const tooltips = [];
        for (const el of this.$el.find('[data-bs-toggle="tooltip"]').toArray()) {
            tooltips.push(Tooltip.getOrCreateInstance(el));
        }
        let popoverShown = true;
        this.$target.popover({
            html: true,
            content: this.$el,
            placement: 'bottom',
            // We need the popover to:
            // 1. Open when the link is clicked or double clicked
            // 2. Remain open when the link is clicked again (which `trigger: 'click'` is not doing)
            // 3. Remain open when the popover content is clicked..
            // 4. ..except if it the click was on a button of the popover content
            // 5. Close when the user click somewhere on the page (not being the link or the popover content)
            trigger: 'manual',
            boundary: 'viewport',
            container: this.container,
        })
        .on('show.bs.popover.link_popover', () => {
            this._loadAsyncLinkPreview();
            popoverShown = true;
        })
        .on('hide.bs.popover.link_popover', () => {
            popoverShown = false;
        })
        .on('hidden.bs.popover.link_popover', () => {
            for (const tooltip of tooltips) {
                tooltip.hide();
            }
        })
        .on('inserted.bs.popover.link_popover', () => {
            const popover = Popover.getInstance(this.target);
            popover.tip.classList.add('o_edit_menu_popover');
        })
        .popover('show');

        this.popover = Popover.getInstance(this.target);
        this.$target.on('mousedown.link_popover', (e) => {
            if (!popoverShown) {
                this.$target.popover('show');
            }
        });
        this.$target.on('href_changed.link_popover', (e) => {
            // Do not change shown/hidden state.
            if (popoverShown) {
                this._loadAsyncLinkPreview();
            }
        });
        const onClickDocument = (e) => {
            if (popoverShown) {
                const hierarchy = [e.target, ...ancestors(e.target)];
                if (
                    !(
                        hierarchy.includes(this.$target[0]) ||
                        (hierarchy.includes(this.$el[0]) &&
                            !hierarchy.some(x => x.tagName && x.tagName === 'A' && (x === this.$urlLink[0] || x === this.$fullUrl[0])))
                    )
                ) {
                    // Note: For buttons of the popover, their listeners should
                    // handle the hide themselves to avoid race conditions.
                    this.popover.hide();
                }
            }
        };
        $(document).on('mouseup.link_popover', onClickDocument);
        if (document !== this.wysiwyg.odooEditor.document) {
            $(this.wysiwyg.odooEditor.document).on('mouseup.link_popover', onClickDocument);
        }

        // Update popover's content and position upon changes
        // on the link's label or href.
        this._observer = new MutationObserver(records => {
            if (!popoverShown) {
                return;
            }
            if (records.some(record => record.type === 'attributes')) {
                this._loadAsyncLinkPreview();
            }
            this.$target.popover('update');
        });
        this._observer.observe(this.target, {
            subtree: true,
            characterData: true,
            attributes: true,
            attributeFilter: ['href'],
        });
    }
    /**
     *
     * @override
     */
    destroy() {
        // FIXME those are never destroyed, so this could be a cause of memory
        // leak. However, it is only one leak per click on a link during edit
        // mode so this should not be a huge problem.
        this.$target.off('.link_popover');
        $(document).off('.link_popover');
        $(this.wysiwyg.odooEditor.document).off('.link_popover');
        this.$target.popover('dispose');
        this._observer.disconnect();
    }

    /**
     *  Hide the popover.
     */
    hide() {
        this.$target.popover('hide');
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Fetches and gets the link preview data (title, description..).
     * For external URL, only the favicon will be loaded.
     *
     * @private
     */
    async _loadAsyncLinkPreview() {
        let url;
        if (this.target.href === '') {
            this._resetPreview('');
            this.$previewFaviconFa.removeClass('fa-globe').addClass('fa-question-circle-o');
            return;
        }
        try {
            url = new URL(this.target.href); // relative to absolute
        } catch {
            // Invalid URL, might happen with editor unsuported protocol. eg type
            // `geo:37.786971,-122.399677`, become `http://geo:37.786971,-122.399677`
            this.notify(_t("This URL is invalid. Preview couldn't be updated."), {
                type: 'danger',
            });
            return;
        }

        this._resetPreview(url);
        const protocol = url.protocol;
        if (!protocol.startsWith('http')) {
            const faMap = {'mailto:': 'fa-envelope-o', 'tel:': 'fa-phone'};
            const icon = faMap[protocol];
            if (icon) {
                this.$previewFaviconFa.toggleClass(`fa-globe ${icon}`);
            }
        } else if (window.location.hostname !== url.hostname) {
            // Preview pages from current website only. External website will
            // most of the time raise a CORS error. To avoid that error, we
            // would need to fetch the page through the server (s2s), involving
            // enduser fetching problematic pages such as illicit content.
            this.$previewFaviconImg.attr({
                'src': `https://www.google.com/s2/favicons?sz=16&domain=${encodeURIComponent(url)}`
            }).removeClass('d-none');
            this.$previewFaviconFa.addClass('d-none');
        } else {
            await this._keepLastPromise.add($.get(this.target.href)).then(content => {
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(content, "text/html");

                // Get
                const favicon = doc.querySelector("link[rel~='icon']");
                const ogTitle = doc.querySelector("[property='og:title']");
                const title = doc.querySelector("title");

                // Set
                if (favicon) {
                    this.$previewFaviconImg.attr({'src': favicon.href}).removeClass('d-none');
                    this.$previewFaviconFa.addClass('d-none');
                }
                if (ogTitle || title) {
                    this.$urlLink.text(ogTitle ? ogTitle.getAttribute('content') : title.text.trim());
                }
                this.$fullUrl.removeClass('d-none').addClass('o_we_webkit_box');
            }).catch(error => {
                // HTML error codes should not prevent to edit the links, so we
                // only check for proper instances of Error.
                if (error instanceof Error) {
                    return Promise.reject(error);
                }
            }).finally(() => {
                this.$target.popover('update');
            });
        }
    }
    /**
     * Resets the preview elements visibility. Particularly useful when changing
     * the link url from an internal to an external one and vice versa.
     *
     * @private
     * @param {string} url
     */
    _resetPreview(url) {
        this.$previewFaviconImg.addClass('d-none');
        this.$previewFaviconFa.removeClass('d-none fa-question-circle-o fa-envelope-o fa-phone').addClass('fa-globe');
        this.$urlLink.add(this.$fullUrl).text(url || _t('No URL specified')).attr('href', url || null);
        this.$fullUrl.addClass('d-none').removeClass('o_we_webkit_box');
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Opens the Link Dialog.
     *
     * TODO The editor instance should be reached a proper way
     *
     * @private
     * @param {Event} ev
     */
    _onEditLinkClick(ev) {
        ev.preventDefault();
        this.wysiwyg.toggleLinkTools({
            forceOpen: true,
            link: this.$target[0],
        });
        ev.stopImmediatePropagation();
        this.popover.hide();
    }
    /**
     * Removes the link/anchor.
     *
     * @private
     * @param {Event} ev
     */
    _onRemoveLinkClick(ev) {
        ev.preventDefault();
        this.wysiwyg.removeLink();
        ev.stopImmediatePropagation();
        this.popover.hide();
    }
    /**
     * Copy the link/anchor
     * 
     * @private
     * @param {Event} ev
     */
    async _onCopyLinkClick(ev) {
        ev.preventDefault();
        await browser.navigator.clipboard.writeText(this.target.href);
        this.$copyLink.tooltip('hide');
        this.notify(_t("Link copied to clipboard."), {
            type: 'success',
        });
        this.popover.hide();
    }
}

return __exports;
});
;

/**********************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/widgets/link_tools.js  *
*  Lines: 543                                                         *
**********************************************************************/
odoo.define('@web_editor/js/wysiwyg/widgets/link_tools', ['@web_editor/js/wysiwyg/widgets/link', '@web_editor/js/wysiwyg/widgets/color_palette', '@web_editor/js/common/utils', '@odoo/owl', '@web/core/utils/colors'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Link } = require("@web_editor/js/wysiwyg/widgets/link");
const { ColorPalette } = require('@web_editor/js/wysiwyg/widgets/color_palette');
const weUtils = require("@web_editor/js/common/utils")[Symbol.for("default")];
const {
    onWillUpdateProps,
    onMounted,
    onWillUnmount,
    useState,
} = require("@odoo/owl");
const { normalizeCSSColor } = require('@web/core/utils/colors');

/**
 * Allows to customize link content and style.
 */
const LinkTools = __exports.LinkTools = class LinkTools extends Link {
    static template = 'web_editor.LinkTools';
    static props = {
        ...Link.props,
        wysiwyg: { type: Object },
        $button: { type: Object },
        onColorCombinationClassChange: { type: Function, optional: true },
        onPreApplyLink: { type: Function, optional: true },
        onPostApplyLink: { type: Function, optional: true },
        onDestroy: { type: Function, optional: true },
        getColorpickerTemplate: { type: Function, optional: true },
    };
    static defaultProps = {
        ...Link.defaultProps,
        onColorCombinationClassChange: () => {},
        onPreApplyLink: () => {},
        onPostApplyLink: () => {},
        onDestroy: () => {},
    };
    static components = { ColorPalette };
    colorpickerProps = useState({
        'color': { selectedColor: undefined },
        'background-color': { selectedColor: undefined },
        'border-color': { selectedColor: undefined },
    });
    colorpickers = {
        'color': { colorNames: null },
        'background-color': { colorNames: null },
        'border-color': { colorNames: null },
    };
    state = useState({
        showLinkSizeRow: true,
        showLinkCustomColor: true,
        showLinkShapeRow: true,
    });

    setup() {
        super.setup(...arguments);
        onWillUpdateProps(async (newProps) => {
            await this.mountedPromise;
            this.$link = newProps.link ? $(newProps.link) : this.link;
            this._setSelectOptionFromLink();
            this._updateOptionsUI();
            this._updateLabelInput();
        });
        onMounted(() => {
            this._observer = new MutationObserver(records => {
                if (records.some(record => record.type === 'attributes')) {
                    this.state.url = this.props.link.getAttribute('href') || '';
                    this._setUrl();
                }
                this._updateLabelInput();
            });
            this._observerOptions = {
                subtree: true,
                childList: true,
                characterData: true,
                attributes: true,
                attributeFilter: ['href'],
            };
            this._observer.observe(this.props.link, this._observerOptions);
        });
        onWillUnmount(() => {
            this._observer.disconnect();
        });
    }
    /**
     * @override
     */
    async _updateState() {
        await super._updateState(...arguments);
        // Keep track of each selected custom color and colorpicker.
        this.customColors = {};
        this.PREFIXES = {
            'color': 'text-',
            'background-color': 'bg-',
        };
    }
    /**
     * @override
     */
    async start() {
        const ret = await super.start(...arguments);
        this.$el.on('click', 'we-select we-button', this._onPickSelectOption.bind(this));
        this.$el.on('click', 'we-checkbox', this._onClickCheckbox.bind(this));
        this.$el.on('change', '.link-custom-color-border input', this._onChangeCustomBorderWidth.bind(this));
        this.$el.on('keypress', '.link-custom-color-border input', this._onKeyPressCustomBorderWidth.bind(this));
        this.$el.on('click', 'we-select [name="link_border_style"] we-button', this._onBorderStyleSelectOption.bind(this));
        this.$el.on('input', 'input[name="label"]', this._onLabelInput.bind(this));

        this._setSelectOptionFromLink();
        this._updateOptionsUI();

        if (!this.linkEl.href && this.state.url) {
            // Link URL was deduced from label. Apply changes to DOM.
            this.__onURLInput();
        }

        return ret;
    }
    destroy() {
        if (!this.$el?.[0]) {
            return super.destroy(...arguments);
        }
        const $contents = this.$link.contents();
        if (shouldUnlink(this.$link[0], this.colorCombinationClass)) {
            $contents.unwrap();
        }
        super.destroy(...arguments);
        this.props.onDestroy();
    }
    applyLinkToDom() {
        this._observer.disconnect();
        this.props.onPreApplyLink();
        super.applyLinkToDom(...arguments);
        this.props.wysiwyg.odooEditor.historyStep();
        this.props.onPostApplyLink();
        this._observer.observe(this.props.link, this._observerOptions);
    }

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    focusUrl() {
        this.$el[0].scrollIntoView();
        super.focusUrl(...arguments);
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    _setSelectOptionFromLink() {
        super._setSelectOptionFromLink(...arguments);
        const link = this.$link[0];
        const customStyleProps = ['color', 'background-color', 'background-image', 'border-width', 'border-style', 'border-color'];
        const shapeClasses = ['btn-outline-primary', 'btn-outline-secondary', 'btn-fill-primary', 'btn-fill-secondary', 'rounded-circle', 'flat'];
        if (customStyleProps.some(s => link.style[s]) || shapeClasses.some(c => link.classList.contains(c))) {
            // Force custom style if style or shape exists on the link.
            const customOption = this.$el[0].querySelector('[name="link_style_color"] we-button[data-value="custom"]');
            this._setSelectOption($(customOption), true);
        }
    }
    /**
     * @override
     */
    _adaptPreview() {
        var data = this._getData();
        if (data === null) {
            return;
        }
        this.applyLinkToDom(data);
    }
    /**
     * @override
     */
    _doStripDomain() {
        return this.$el.find('we-checkbox[name="do_strip_domain"]').closest('we-button.o_we_checkbox_wrapper').hasClass('active');
    }
    /**
     * @override
     */
    _getIsNewWindowFormRow() {
        return this.$el.find('we-checkbox[name="is_new_window"]').closest('we-row');
    }
    /**
     * @override
     */
    _getLinkOptions() {
        const options = [
            'we-selection-items[name="link_style_color"] > we-button',
            'we-selection-items[name="link_style_size"] > we-button',
            'we-selection-items[name="link_style_shape"] > we-button',
        ];
        return this.$el.find(options.join(','));
    }
    /**
     * @override
     */
    _getLinkShape() {
        return this.$el.find('we-selection-items[name="link_style_shape"] we-button.active').data('value') || '';
    }
    /**
     * @override
     */
    _getLinkSize() {
        return this.$el.find('we-selection-items[name="link_style_size"] we-button.active').data('value') || '';
    }
    /**
     * @override
     */
    _getLinkType() {
        return this.$el.find('we-selection-items[name="link_style_color"] we-button.active').data('value') || '';
    }
    /**
     * @override
     */
    _getLinkCustomTextColor() {
        return this.customColors['color'];
    }
    /**
     * @override
     */
    _getLinkCustomBorder() {
        return this.customColors['border-color'];
    }
    /**
     * @override
     */
    _getLinkCustomBorderWidth() {
        return this.$el.find('.link-custom-color-border input').val() || '';
    }
    /**
     * @override
     */
    _getLinkCustomBorderStyle() {
        return this.$el.find('.link-custom-color-border we-button.active').data('value') || '';
    }
    /**
     * @override
     */
    _getLinkCustomFill() {
        return this.customColors['background-color'];
    }
    /**
     * @override
     */
    _getLinkCustomClasses() {
        let textClass = this.customColors['color'];
        const colorPickerFg = this.colorpickers['color'].colorNames;
        if (
            !textClass ||
            !colorPickerFg ||
            !weUtils.computeColorClasses(colorPickerFg, 'text-').includes(textClass)
        ) {
            textClass = '';
        }
        let fillClass = this.customColors['background-color'];
        const colorPickerBg = this.colorpickers['background-color'].colorNames;
        if (
            !fillClass ||
            !colorPickerBg ||
            !weUtils.computeColorClasses(colorPickerBg, 'bg-').includes(fillClass)
        ) {
            fillClass = '';
        }
        return ` ${textClass} ${fillClass}`;
    }
    /**
     * @override
     */
    _isNewWindow(url) {
        if (this.props.forceNewWindow) {
            return this._isFromAnotherHostName(url);
        } else {
            return this.$el.find('we-checkbox[name="is_new_window"]').closest('we-button.o_we_checkbox_wrapper').hasClass('active');
        }
    }
    /**
     * @override
     */
    _setSelectOption($option, active) {
        $option.toggleClass('active', active);
        if (active) {
            $option.closest('we-select').find('we-toggler').text($option.text());
            // ensure only one option is active in the dropdown
            $option.siblings('we-button').removeClass("active");
        }
    }
    /**
     * @override
     */
    _updateOptionsUI() {
        const el = this.$el[0].querySelector('[name="link_style_color"] we-button.active');
        if (el) {
            this.colorCombinationClass = el.dataset.value;
            // Hide the size option if the link is an unstyled anchor.
            this.state.showLinkSizeRow = Boolean(this.colorCombinationClass);

            // // Show custom colors and shape only for Custom style.
            this.state.showLinkCustomColor = el.dataset.value === 'custom';
            this.state.showLinkShapeRow = el.dataset.value === 'custom';

            this.props.onColorCombinationClassChange(this.colorCombinationClass);

            this._updateColorpicker('color');
            this._updateColorpicker('background-color');
            this._updateColorpicker('border-color');

            const borderWidth = this.linkEl.style['border-width'];
            const numberAndUnit = weUtils.getNumericAndUnit(borderWidth);
            this.$el.find('.link-custom-color-border input').val(numberAndUnit ? numberAndUnit[0] : "1");
            let borderStyle = this.linkEl.style['border-style'];
            if (!borderStyle || borderStyle === 'none') {
                borderStyle = 'solid';
            }
            const $activeBorderStyleButton = this.$el.find(`.link-custom-color-border [name="link_border_style"] we-button[data-value="${borderStyle}"]`);
            $activeBorderStyleButton.addClass('active');
            $activeBorderStyleButton.siblings('we-button').removeClass("active");
            const $activeBorderStyleToggler = $activeBorderStyleButton.closest('we-select').find('we-toggler');
            $activeBorderStyleToggler.empty();
            $activeBorderStyleButton.find('div').clone().appendTo($activeBorderStyleToggler);
        }
    }
    /**
     * Updates the colorpicker associated to a given property - updated with its selected color.
     *
     * @private
     * @param {string} cssProperty
     */
    _updateColorpicker(cssProperty) {
        const prefix = this.PREFIXES[cssProperty];

        // Update selected color.
        const colorNames = this.colorpickers[cssProperty].colorNames;
        let color = this.linkEl.style[cssProperty];
        const colorClasses = prefix ? weUtils.computeColorClasses(colorNames, prefix) : [];
        const colorClass = prefix && weUtils.getColorClass(this.linkEl, colorNames, prefix);
        const isColorClass = colorClasses.includes(colorClass);
        if (isColorClass) {
            color = colorClass;
        } else if (cssProperty === 'background-color') {
            const gradientColor = this.linkEl.style['background-image'];
            if (weUtils.isColorGradient(gradientColor)) {
                color = gradientColor;
            }
        }
        this.customColors[cssProperty] = color;
        if (cssProperty === 'border-color') {
            // Highlight matching named color if any.
            const colorName = colorNames[normalizeCSSColor(color)];
            this.colorpickerProps[cssProperty].selectedColor = colorName || color;
        } else {
            this.colorpickerProps[cssProperty].selectedColor = isColorClass ? color.replace(prefix, '') : color;
        }

        // Update preview.
        const $colorPreview = this.$el.find('.link-custom-color-' + (cssProperty === 'border-color' ? 'border' : cssProperty === 'color' ? 'text' : 'fill') + ' .o_we_color_preview');
        const previewClasses = weUtils.computeColorClasses(colorNames, 'bg-');
        $colorPreview[0].classList.remove(...previewClasses);
        if (isColorClass) {
            $colorPreview.css('background-color', `var(--we-cp-${color.replace(prefix, '')}`);
            $colorPreview.css('background-image', '');
        } else {
            $colorPreview.css('background-color', weUtils.isColorGradient(color) ? 'rgba(0, 0, 0, 0)' : color);
            $colorPreview.css('background-image', weUtils.isColorGradient(color) ? color : '');
        }
    }

    /**
     * @private
     */
    _onColorpaletteSetColorNames(cssProperty, colorNames) {
        this.colorpickers[cssProperty].colorNames = colorNames;
    }
    /**
     * @private
     */
    _onColorpaletteColorPicked(cssProperty, params) {
        // Reset color styles in link content to make sure new color is not hidden.
        // Only done when applied to avoid losing state during preview.
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(this.linkEl);
        selection.removeAllRanges();
        selection.addRange(range);
        this.props.wysiwyg.odooEditor.execCommand('applyColor', '', 'color');
        this.props.wysiwyg.odooEditor.execCommand('applyColor', '', 'backgroundColor');

        this._colorpaletteApply(cssProperty, params);

        this.props.wysiwyg.odooEditor.historyStep();
        this._updateOptionsUI();
    }
    /**
     * @private
     */
    _colorpaletteApply(cssProperty, params) {
        const prefix = this.PREFIXES[cssProperty];
        let color = params.color;
        const colorNames = this.colorpickers[cssProperty].colorNames;
        const colorClasses = prefix ? weUtils.computeColorClasses(colorNames, prefix) : [];
        const colorClass = `${prefix}${color}`;
        if (colorClasses.includes(colorClass)) {
            color = colorClass;
        } else if (colorNames.includes(color)) {
            // Store as color value.
            color = weUtils.getCSSVariableValue(color);
        }
        this.customColors[cssProperty] = color;
        this.applyLinkToDom(this._getData());
    }
    /**
     * Updates the label input with the DOM content of the link.
     *
     * @private
     */
    _updateLabelInput() {
        if (this.$el) {
            this.$el[0].querySelector('#o_link_dialog_label_input').value =
                weUtils.getLinkLabel(this.linkEl);
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    _onClickCheckbox(ev) {
        const $target = $(ev.target);
        $target.closest('we-button.o_we_checkbox_wrapper').toggleClass('active');
        this._adaptPreview();
    }
    _onPickSelectOption(ev) {
        const $target = $(ev.target);
        if ($target.closest('[name="link_border_style"]').length) {
            return;
        }
        const $select = $target.closest('we-select');
        $select.find('we-selection-items we-button').toggleClass('active', false);
        this._setSelectOption($target, true);
        this._updateOptionsUI();
        this._adaptPreview();
    }
    /**
     * Sets the border width on the link.
     *
     * @private
     * @param {Event} ev
     */
    _onChangeCustomBorderWidth(ev) {
        const value = ev.target.value;
        if (parseInt(value) >= 0) {
            this.$link.css('border-width', value + 'px');
        }
    }
    /**
     * Sets the border width on the link when enter is pressed.
     *
     * @private
     * @param {Event} ev
     */
    _onKeyPressCustomBorderWidth(ev) {
        if (ev.key === "Enter") {
            this._onChangeCustomBorderWidth(ev);
        }
    }
    /**
     * Sets the border style on the link.
     *
     * @private
     * @param {Event} ev
     */
    _onBorderStyleSelectOption(ev) {
        const value = ev.currentTarget.dataset.value;
        if (value) {
            this.$link.css('border-style', value);
            const $target = $(ev.currentTarget);
            const $activeBorderStyleToggler = $target.closest('we-select').find('we-toggler');
            $activeBorderStyleToggler.empty();
            $target.find('div').clone().appendTo($activeBorderStyleToggler);
            // Ensure only one option is active in the dropdown.
            $target.addClass('active');
            $target.siblings('we-button').removeClass("active");
            this.props.wysiwyg.odooEditor.historyStep();
        }
    }
    /**
     * @override
     */
    __onURLInput() {
        super.__onURLInput(...arguments);
        this.props.wysiwyg.odooEditor.historyPauseSteps('_onURLInput');
        this._syncContent();
        this._adaptPreview();
        this.props.wysiwyg.odooEditor.historyUnpauseSteps('_onURLInput');
    }
    /**
     * Updates the DOM content of the link with the input value.
     *
     * @private
     * @param {Event} ev
     */
    _onLabelInput(ev) {
        const data = this._getData();
        if (!data) {
            return;
        }
        this._observer.disconnect();
        // Force update of link's content with new data using 'force: true'.
        // Without this, no update if input is same as original text.
        this._updateLinkContent(this.$link, data, {force: true});
        this._observer.observe(this.props.link, this._observerOptions);
    }
    /* If content is equal to previous URL, update it to match current URL.
     *
     * @private
     */
    _syncContent() {
        const previousUrl = this.linkEl.getAttribute('href');
        if (!previousUrl) {
            return;
        }
        const protocolLessPrevUrl = previousUrl.replace(/^https?:\/\/|^mailto:/i, '');
        const content = weUtils.getLinkLabel(this.linkEl);
        if (content === previousUrl || content === protocolLessPrevUrl) {
            const newUrl = this.linkComponentWrapperRef.el.querySelector('input[name="url"]').value;
            const protocolLessNewUrl = newUrl.replace(/^https?:\/\/|^mailto:/i, '')
            const newContent = content.replace(protocolLessPrevUrl, protocolLessNewUrl);
            this.linkComponentWrapperRef.el.querySelector('#o_link_dialog_label_input').value = newContent;
            this._onLabelInput();
        }
    }
}

__exports.shouldUnlink = shouldUnlink; function shouldUnlink(link, colorCombinationClass) {
    return !link.getAttribute('href') && !colorCombinationClass;
}

return __exports;
});
;

/**********************************************************
*  Filepath: /web_editor/static/src/js/editor/toolbar.js  *
*  Lines: 111                                             *
**********************************************************/
odoo.define('@web_editor/js/editor/toolbar', ['@web/core/ui/ui_service', '@web_editor/js/wysiwyg/widgets/color_palette', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { useActiveElement, utils: uiUtils } = require("@web/core/ui/ui_service");
const { ColorPalette } = require("@web_editor/js/wysiwyg/widgets/color_palette");

const {
    Component,
    onMounted,
    useRef,
} = require("@odoo/owl");

const Toolbar = __exports.Toolbar = class Toolbar extends Component {
    static template = 'web_editor.toolbar';
    static components = { ColorPalette };
    static props = {
        dropDirection: { type: String, optional: true },

        showChecklist: { type: Boolean, optional: true },
        showColors: { type: Boolean, optional: true },
        showFontSize: { type: Boolean, optional: true },
        useFontSizeInput: { type: Boolean, optional: true },
        showHistory: { type: Boolean, optional: true },

        showStyle: { type: Boolean, optional: true },
        showJustify: { type: Boolean, optional: true },
        showList: { type: Boolean, optional: true },
        showLink: { type: Boolean, optional: true },

        showImageShape: { type: Boolean, optional: true },
        showImagePadding: { type: Boolean, optional: true },
        showImageWidth: { type: Boolean, optional: true },
        showImageEdit: { type: Boolean, optional: true },

        showHeading1: { type: Boolean, optional: true },
        showHeading2: { type: Boolean, optional: true },
        showHeading3: { type: Boolean, optional: true },
        showHeading4: { type: Boolean, optional: true },
        showHeading5: { type: Boolean, optional: true },
        showHeading6: { type: Boolean, optional: true },

        onColorpaletteDropdownShow: { type: Function, optional: true },
        onColorpaletteDropdownHide: { type: Function, optional: true },
        textColorPaletteProps: { type: Object },
        backgroundColorPaletteProps: { type: Object },

        slots: { type: Object, optional: true },
    };
    static defaultProps = {
        dropDirection: 'dropdown',

        showChecklist: true,
        showColors: true,
        showFontSize: true,
        useFontSizeInput: false,
        showHistory: false,

        showStyle: true,
        showJustify: true,
        showList: true,
        showLink: true,

        showImageShape: true,
        showImagePadding: true,
        showImageWidth: true,
        showImageEdit: true,

        showHeading1: true,
        showHeading2: true,
        showHeading3: true,
        showHeading4: true,
        showHeading5: true,
        showHeading6: true,

        onColorpaletteDropdownShow: () => {},
        onColorpaletteDropdownHide: () => {},
    };

    colorDropdownRef = {
        text: useRef("textColorpickerDropdown"),
        background: useRef("backgroundColorpaletteDropdown"),
    }

    setup() {
        useActiveElement("toolbarRef");
        onMounted(() => {
            for (const [colorType, ref] of Object.entries(this.colorDropdownRef)) {
                const dropdown = ref.el;
                if (!dropdown) continue;
                // If the element is within an iframe, access the jquery loaded in
                // the iframe because it is the one who will trigger the dropdown
                // events (i.e hide.bs.dropdown and show.bs.dropdown).
                const $ = dropdown.ownerDocument.defaultView.$;
                const $dropdown = $(dropdown);
                $dropdown.on('show.bs.dropdown', () => {
                    this.props.onColorpaletteDropdownShow(colorType);
                });
                $dropdown.on('hide.bs.dropdown', (ev) => this.props.onColorpaletteDropdownHide(ev));
            }
        });
    }

    isMobile() {
        return uiUtils.isSmall();
    }
}

return __exports;
});
;

/****************************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/wysiwyg_jquery_extention.js  *
*  Lines: 107                                                               *
****************************************************************************/
odoo.define('@web_editor/js/wysiwyg/wysiwyg_jquery_extention', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

// jQuery extensions
$.extend($.expr[':'], {
    o_editable: function (node, i, m) {
        while (node) {
            if (node.className && typeof node.className === "string") {
                if (node.className.indexOf('o_not_editable') !== -1) {
                    return false;
                }
                if (node.className.indexOf('o_editable') !== -1) {
                    return true;
                }
            }
            node = node.parentNode;
        }
        return false;
    },
});

function firstChild(node) {
    while (node.firstChild) {
        node = node.firstChild;
    }
    return node;
}
function lastChild(node) {
    while (node.lastChild) {
        node = node.lastChild;
    }
    return node;
}
function nodeLength(node) {
    if (node.nodeType === Node.TEXT_NODE) {
        return node.nodeValue.length;
    } else {
        return node.childNodes.length;
    }
}

$.fn.extend({
    focusIn: function () {
        if (this.length) {
            const selection = this[0].ownerDocument.getSelection();
            selection.removeAllRanges();

            const range = new Range();
            const node = firstChild(this[0]);
            range.setStart(node, 0);
            range.setEnd(node, 0);
            selection.addRange(range);
        }
        return this;
    },
    focusInEnd: function () {
        if (this.length) {
            const selection = this[0].ownerDocument.getSelection();
            selection.removeAllRanges();

            const range = new Range();
            const node = lastChild(this[0]);
            const length = nodeLength(node);

            range.setStart(node, length);
            range.setEnd(node, length);
            selection.addRange(range);
        }
        return this;
    },
    selectContent: function () {
        if (this.length && !this[0].hasChildNodes()) {
            return this.selectElement();
        }
        if (this.length) {
            const selection = this[0].ownerDocument.getSelection();
            selection.removeAllRanges();

            const range = new Range();
            range.setStart(this[0].firstChild, 0);
            range.setEnd(this[0].lastChild, this[0].lastChild.length);
            selection.addRange(range);
        }
        return this;
    },
    selectElement: function () {
        if (this.length) {
            const selection = this[0].ownerDocument.getSelection();
            selection.removeAllRanges();

            const element = this[0];
            const parent = element.parentNode;
            const offsetStart = Array.from(parent.childNodes).indexOf(element);

            const range = new Range();
            range.setStart(parent, offsetStart);
            range.setEnd(parent, offsetStart + 1);
            selection.addRange(range);
        }
        return this;
    },
});

return __exports;
});
;

/***********************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/wysiwyg.js  *
*  Lines: 3689                                             *
***********************************************************/
odoo.define('@web_editor/js/wysiwyg/wysiwyg', ['@web/session', '@web_editor/components/media_dialog/media_dialog', '@web_editor/components/media_dialog/video_selector', '@web/core/browser/browser', '@web/core/utils/hooks', '@web_editor/js/editor/custom_colors', '@web/core/l10n/localization', '@web_editor/js/editor/odoo-editor/src/OdooEditor', '@web_editor/js/editor/toolbar', '@web_editor/js/wysiwyg/widgets/link_popover_widget', '@web_editor/js/wysiwyg/widgets/alt_dialog', '@web_editor/js/wysiwyg/widgets/chatgpt_prompt_dialog', '@web_editor/js/wysiwyg/widgets/chatgpt_alternatives_dialog', '@web_editor/js/wysiwyg/widgets/image_crop', '@web_editor/js/common/wysiwyg_utils', '@web_editor/js/common/utils', '@web_editor/js/editor/odoo-editor/src/utils/utils', '@web_editor/js/wysiwyg/PeerToPeer', '@web/core/utils/functions', '@web/core/utils/arrays', '@web/core/utils/timing', '@web/core/registry', '@web/core/file_viewer/file_viewer', '@web/core/browser/feature_detection', '@web/core/utils/concurrency', '@web/core/confirmation_dialog/confirmation_dialog', '@web/core/l10n/translation', '@web_editor/js/wysiwyg/conflict_dialog', '@web_editor/js/wysiwyg/widgets/link', '@web_editor/js/wysiwyg/widgets/link_tools', '@web_editor/js/wysiwyg/widgets/link_dialog', '@odoo/owl', '@web/core/utils/colors', '@web/core/emoji_picker/emoji_picker', '@web/core/tooltip/tooltip'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { session } = require("@web/session");
const { MediaDialog } = require("@web_editor/components/media_dialog/media_dialog");
const { VideoSelector } = require("@web_editor/components/media_dialog/video_selector");
const { browser } = require("@web/core/browser/browser");
const { useService } = require("@web/core/utils/hooks");
const customColors = require("@web_editor/js/editor/custom_colors")[Symbol.for("default")];
const { localization } = require("@web/core/l10n/localization");
const OdooEditorLib = require("@web_editor/js/editor/odoo-editor/src/OdooEditor");
const { Toolbar } = require("@web_editor/js/editor/toolbar");
const { LinkPopoverWidget } = require('@web_editor/js/wysiwyg/widgets/link_popover_widget');
const { AltDialog } = require('@web_editor/js/wysiwyg/widgets/alt_dialog');
const { ChatGPTPromptDialog } = require('@web_editor/js/wysiwyg/widgets/chatgpt_prompt_dialog');
const { ChatGPTAlternativesDialog } = require('@web_editor/js/wysiwyg/widgets/chatgpt_alternatives_dialog');
const { ImageCrop } = require('@web_editor/js/wysiwyg/widgets/image_crop');

const wysiwygUtils = require("@web_editor/js/common/wysiwyg_utils");
const weUtils = require("@web_editor/js/common/utils")[Symbol.for("default")];
const { isSelectionInSelectors, peek } = require('@web_editor/js/editor/odoo-editor/src/utils/utils');
const { PeerToPeer, RequestError } = require("@web_editor/js/wysiwyg/PeerToPeer");
const { uniqueId } = require("@web/core/utils/functions");
const { groupBy } = require("@web/core/utils/arrays");
const { debounce } = require("@web/core/utils/timing");
const { registry } = require("@web/core/registry");
const { FileViewer } = require("@web/core/file_viewer/file_viewer");
const { isMobileOS } = require("@web/core/browser/feature_detection");
const { Mutex } = require("@web/core/utils/concurrency");
const { AlertDialog, ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { _t } = require("@web/core/l10n/translation");
const { ConflictDialog } = require("@web_editor/js/wysiwyg/conflict_dialog");
const { getOrCreateLink } = require("@web_editor/js/wysiwyg/widgets/link");
const { shouldUnlink } = require('@web_editor/js/wysiwyg/widgets/link_tools');
const { LinkDialog } = require("@web_editor/js/wysiwyg/widgets/link_dialog");
const {
    Component,
    useRef,
    useState,
    onWillStart,
    onMounted,
    onWillDestroy,
    onWillUpdateProps,
    markup,
    status,
} = require("@odoo/owl");
const { isCSSColor } = require('@web/core/utils/colors');
const { EmojiPicker } = require('@web/core/emoji_picker/emoji_picker');
const { Tooltip } = require("@web/core/tooltip/tooltip");

const OdooEditor = OdooEditorLib.OdooEditor;
const getDeepRange = OdooEditorLib.getDeepRange;
const getInSelection = OdooEditorLib.getInSelection;
const isProtected = OdooEditorLib.isProtected;
const rgbToHex = OdooEditorLib.rgbToHex;
const preserveCursor = OdooEditorLib.preserveCursor;
const closestElement = OdooEditorLib.closestElement;
const setSelection = OdooEditorLib.setSelection;
const endPos = OdooEditorLib.endPos;
const hasValidSelection = OdooEditorLib.hasValidSelection;
const parseHTML = OdooEditorLib.parseHTML;
const closestBlock = OdooEditorLib.closestBlock;
const getRangePosition = OdooEditorLib.getRangePosition;
const fillEmpty = OdooEditorLib.fillEmpty;
const isVisible = OdooEditorLib.isVisible;

function getJqueryFromDocument(doc) {
    if (doc.defaultView && doc.defaultView.$) {
        return doc.defaultView.$;
    } else {
        const _jquery = window.$;
        return (...args) => {
            if (args.length <= 2 && typeof args[0] === "string") {
                return _jquery(args[0], args[1] || doc);
            } else {
                return _jquery(...args)
            }
        }
    }
}

var id = 0;
const basicMediaSelector = 'img, .fa, .o_image, .media_iframe_video';
// (see isImageSupportedForStyle).
const mediaSelector = basicMediaSelector.split(',').map(s => `${s}:not([data-oe-xpath])`).join(',');

// Time to consider a user offline in ms. This fixes the problem of the
// navigator closing rtc connection when the mac laptop screen is closed.
const CONSIDER_OFFLINE_TIME = 1000;
// Check wether the computer could be offline. This fixes the problem of the
// navigator closing rtc connection when the mac laptop screen is closed.
// This case happens on Mac OS on every browser when the user close it's laptop
// screen. At first, the os/navigator closes all rtc connection, and after some
// times, the os/navigator internet goes offline without triggering an
// offline/online event.
// However, if the laptop screen is open and the connection is properly remove
// (e.g. disconnect wifi), the event is properly triggered.
const CHECK_OFFLINE_TIME = 1000;
const PTP_CLIENT_DISCONNECTED_STATES = [
    'failed',
    'closed',
    'disconnected',
];

// Time in ms to wait when trying to aggregate snapshots from other peers and
// potentially recover from a missing step before trying to apply those
// snapshots or recover from the server.
const PTP_MAX_RECOVERY_TIME = 500;

const REQUEST_ERROR = Symbol('REQUEST_ERROR');

// this is a local cache for ice server descriptions
let ICE_SERVERS = null;

let fileViewerId = 0;

const Wysiwyg = __exports.Wysiwyg = class Wysiwyg extends Component {
    static template = 'web_editor.Wysiwyg';
    static components = { MediaDialog, VideoSelector, Toolbar, ImageCrop };
    static props = {
        options: Object,
        startWysiwyg: { type: Function, optional: true },
        editingValue: { type: String, optional: true },
    };
    elRef = useRef("el");
    toolbarRef = useRef("toolbar");
    imageCropRef = useRef("imageCrop");
    colorPalettesProps = {
        text: useState({
            resetTabCount: 0,
        }),
        background: useState({
            resetTabCount: 0,
        }),
    }
    imageCropProps = useState({
        rpc: this._serviceRpc.bind(this),
        showCount: 0,
        media: undefined,
        mimetype: undefined,
    });
    state = useState({
        linkToolProps: false,
        showToolbar: true,
        toolbarProps: {},
    });

    setup() {
        this.orm = useService('orm');
        this.rpc = useService('rpc');
        this.getColorPickerTemplateService = useService('get_color_picker_template');
        this.notification = useService("notification");
        this.popover = useService("popover");
        this.busService = this.env.services.bus_service;

        const getColorPickedHandler = (colorType) => {
            return (params) => {
                if (this.hadNonCollapsedSelectionBeforeColorpicker) {
                    this.odooEditor.historyResetLatestComputedSelection(true);
                }
                // Unstash the mutations now that the color is picked.
                this.odooEditor.historyUnstash();
                this._processAndApplyColor(colorType, params.color);
                // Deselect tables so the applied color can be seen
                // without using `!important` (otherwise the selection
                // hides it).
                if (this.odooEditor.deselectTable() && hasValidSelection(this.odooEditor.editable)) {
                    this.odooEditor.document.getSelection().collapseToStart();
                }
                this._updateEditorUI(this.lastMediaClicked && { target: this.lastMediaClicked });
            };
        }

        const getColorHoverHandler = (colorType) => {
            return (props) => {
                if (this.hadNonCollapsedSelectionBeforeColorpicker) {
                    this.odooEditor.historyResetLatestComputedSelection(true);
                }
                this.odooEditor.historyPauseSteps();
                try {
                    this._processAndApplyColor(colorType, props.color, true);
                    this.odooEditor._computeHistorySelection();
                } finally {
                    this.odooEditor.historyUnpauseSteps();
                }
            }
        };

        const colorPaletteCommonOptions = {
            excluded: ['transparent_grayscale'],
            document: this.props.options.document,
            selectedTab: 'theme-colors',
            withGradients: true,
            onColorLeave: () => {
                // We need to prevent rollback in case the seclection is in unremovable
                this.odooEditor.withoutRollback(() => this.odooEditor.historyRevertCurrentStep());
                // Compute the selection to ensure it's preserved between
                // selectionchange events in case this gets triggered multiple
                // times quickly.
                this.odooEditor._computeHistorySelection();
            },
            onInputEnter: (ev) => {
                const pickergroup = ev.target.closest('.colorpicker-group');
                $(pickergroup.querySelector('.dropdown-toggle')).dropdown('hide');
            },

            getTemplate: this.getColorpickerTemplate.bind(this),
            getEditableCustomColors: () => {
                if (!this.$editable) {
                    return [];
                }
                return [...this.$editable[0].querySelectorAll('[style*="color"]')].map(el => {
                    return [el.style.color, el.style.backgroundColor];
                }).flat();
            },
        };
        onWillStart(() => {
            this.init();

            Object.assign(this.colorPalettesProps.text, colorPaletteCommonOptions, {
                document: this.options.document,
                onColorPicked: getColorPickedHandler('text'),
                onCustomColorPicked: getColorPickedHandler('text'),
                onColorHover: getColorHoverHandler('text'),
                onColorpaletteTabChange: this.getColorPaletteTabChangeHandler('text').bind(this),
            });
            Object.assign(this.colorPalettesProps.background, colorPaletteCommonOptions, {
                document: this.options.document,
                onColorPicked: getColorPickedHandler('background'),
                onCustomColorPicked: getColorPickedHandler('background'),
                onColorHover: getColorHoverHandler('background'),
                onColorpaletteTabChange: this.getColorPaletteTabChangeHandler('background').bind(this),
            });

            this._setToolbarProps();
        });
        onMounted(async () => {
            this.el = this.elRef.el
            this.$el = $(this.elRef.el);
            this._renderElement();
            if (this.props.startWysiwyg) {
                await this.props.startWysiwyg(this);
            } else {
                await this.startEdition();
            }
        });
        onWillDestroy(() => {
            this.destroy();
        });
        onWillUpdateProps((newProps) => {
            this.options = this._getEditorOptions(newProps.options);
            this._setToolbarProps();

            const lastValue = String(this.props.options.value || '');
            const lastRecordInfo = this.props.options.recordInfo;
            const lastCollaborationChannel = this.props.options.collaborationChannel;
            const newValue = String(newProps.options.value || '');
            const newRecordInfo = newProps.options.recordInfo;
            const newCollaborationChannel = newProps.options.collaborationChannel;

            const isDifferentRecord =
                JSON.stringify(lastRecordInfo) !== JSON.stringify(newRecordInfo) ||
                JSON.stringify(lastCollaborationChannel) !== JSON.stringify(newCollaborationChannel);
            const isDiscardedRecord = !isDifferentRecord && newProps.options.record && !newProps.options.record.dirty;

            if (
                (
                    stripHistoryIds(newValue) !== stripHistoryIds(newProps.editingValue) &&
                    stripHistoryIds(lastValue) !== stripHistoryIds(newValue)
                ) ||
                    isDifferentRecord
                )
            {
                if (isDifferentRecord || isDiscardedRecord) {
                    this.resetEditor(newValue, newProps.options);
                } else {
                    this.setValue(newValue);
                }
                this.env.onWysiwygReset && this.env.onWysiwygReset();
            }
        });
    }

    defaultOptions = {
        lang: 'odoo',
        colors: customColors,
        recordInfo: {context: {}},
        document: document,
        allowCommandVideo: true,
        allowCommandImage: true,
        allowCommandLink: true,
        insertParagraphAfterColumns: true,
        onHistoryResetFromSteps: () => {},
        autostart: true,
        dropImageAsAttachment: true,
        editorPlugins: [],
        useResponsiveFontSizes: true,
        showResponsiveFontSizesBadges: false,
        showExtendedTextStylesOptions: false,
        getCSSVariableValue: weUtils.getCSSVariableValue,
        convertNumericToUnit: weUtils.convertNumericToUnit,
    };
    init() {
        this.id = ++id;
        this.options = this._getEditorOptions(this.props.options);
        this.saving_mutex = new Mutex();
        // Keeps track of color palettes per event name.
        this.colorpickers = {};
        this._onDocumentMousedown = this._onDocumentMousedown.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._onScroll = this._onScroll.bind(this);
        this.customizableLinksSelector = 'a'
            + ':not([data-bs-toggle="tab"])'
            + ':not([data-bs-toggle="collapse"])'
            + ':not([data-bs-toggle="dropdown"])'
            + ':not(.dropdown-item)';
        // navigator.onLine is sometimes a false positive, this._isOnline use
        // more heuristics to bypass the limitation.
        this._isOnline = true;
        this._signalOnline = this._signalOnline.bind(this);
        this.tooltipTimeouts = [];
        Wysiwyg.activeWysiwygs.add(this);
        this._joinPeerToPeer = this._joinPeerToPeer.bind(this);
    }
    /**
     *
     * @override
     */
    async start() {
        // If this widget is started from the OWL legacy component, at the time
        // of start, the $el is not in the document yet. Some instruction in the
        // start rely on the $el being in the document at that time, including
        // code for the collaboration (for adding cursors) or the iframe loading
        // in mass_mailing.
        if (this.options.autostart) {
            return this.startEdition();
        }
    }
    async startEdition() {
        const self = this;

        const options = this.options;

        this.$editable ??= this.$el;
        if (options.value) {
            this.$editable.html(options.value);
        }

        this._isDocumentStale = false;

        // Each time a reset of the document is triggered, it is assigned a
        // unique identifier. Since resetting the editor involves asynchronous
        // requests, it is possible that subsequent resets are triggered before
        // the previous one is complete. This property identifies the latest
        // reset and can be compared against to cancel the processing of late
        // responses from previous resets.
        this._lastCollaborationResetId = 0;
        // This ID correspond to the peer that initiated the document and set
        // the initial oid for all nodes in the tree. It is not the same as
        // document that had a step id at some point. If a step comes from a
        // different history, we should not apply it.
        this._historyShareId = Math.floor(Math.random() * Math.pow(2,52)).toString();

        // The ID is the latest step ID that the server knows through
        // `data-last-history-steps`. We cannot save to the server if we do not
        // have that ID in our history ids as it means that our version is
        // stale.
        this._serverLastStepId = options.value && this._getLastHistoryStepId(options.value);

        this.$editable.data('wysiwyg', this);
        this.$editable.data('oe-model', options.recordInfo.res_model);
        this.$editable.data('oe-id', options.recordInfo.res_id);
        document.addEventListener('mousedown', this._onDocumentMousedown, true);
        this._bindOnBlur();

        this.toolbarEl = this.toolbarRef.el.firstChild;

        this.imageCropEL = this.imageCropRef.el.firstChild;
        options.document.body.append(this.imageCropEL);

        const powerboxOptions = this._getPowerboxOptions();

        let editorCollaborationOptions;
        if (this._isCollaborationEnabled(options)) {
            this._currentClientId = this._generateClientId();
            editorCollaborationOptions = this.setupCollaboration(options.collaborationChannel);
            if (this.options.collaborativeTrigger === 'start') {
                this._joinPeerToPeer();
            } else if (this.options.collaborativeTrigger === 'focus') {
                // Wait until editor is focused to join the peer to peer network.
                this.$editable[0].addEventListener('focus', this._joinPeerToPeer);
            }
        }

        const getYoutubeVideoElement = async (url) => {
            const { embed_url: src } = await this._serviceRpc(
                '/web_editor/video_url/data',
                { video_url: url },
            );
            const [savedVideo] = VideoSelector.createElements([{src}]);
            savedVideo.classList.add(...VideoSelector.mediaSpecificClasses);
            return savedVideo;
        };

        weUtils.setEditableDocument(this.options.document);

        const _getContentEditableAreas = this.options.getContentEditableAreas;
        this.odooEditor = new OdooEditor(this.$editable[0], Object.assign({
            _t: _t,
            toolbar: this.toolbarEl,
            document: this.options.document,
            autohideToolbar: !!this.options.autohideToolbar,
            isRootEditable: this.options.isRootEditable,
            onPostSanitize: this._onPostSanitize.bind(this),
            placeholder: this.options.placeholder,
            powerboxFilters: this.options.powerboxFilters || [],
            showEmptyElementHint: this.options.showEmptyElementHint,
            controlHistoryFromDocument: this.options.controlHistoryFromDocument,
            initialHistoryId: this._serverLastStepId,
            // TODO other places in this file call this.options.getContentEditableAreas
            // without the extension here. It does not seem to be a problem (it
            // was like that before o_editor_banner elements were considered
            // here), but we might want to review that.
            getContentEditableAreas: (...args) => {
                const areaEls = _getContentEditableAreas?.(...args) || [];
                const bannerEls = this.$editable[0].querySelectorAll('.o_editor_banner > div');
                return [...areaEls, ...bannerEls];
            },
            getReadOnlyAreas: this.options.getReadOnlyAreas,
            getUnremovableElements: this.options.getUnremovableElements,
            defaultLinkAttributes: this.options.userGeneratedContent ? {rel: 'ugc' } : {},
            allowCommandVideo: this.options.allowCommandVideo,
            allowInlineAtRoot: this.options.allowInlineAtRoot,
            getYoutubeVideoElement: getYoutubeVideoElement,
            getContextFromParentRect: options.getContextFromParentRect,
            getScrollContainerRect: () => {
                if (!this.scrollContainer || !this.scrollContainer.getBoundingClientRect) {
                    this.scrollContainer = document.querySelector('.o_action_manager') || document.body;
                }
                return this.scrollContainer.getBoundingClientRect();
            },
            getPowerboxElement: () => {
                const selection = (this.options.document || document).getSelection();
                if (selection.isCollapsed && selection.rangeCount) {
                    const baseNode = closestElement(selection.anchorNode, 'P:not([t-field]), DIV:not([t-field])');
                    const fieldContainer = closestElement(selection.anchorNode, '[data-oe-field]');
                    if (!baseNode ||
                        (
                            fieldContainer &&
                            !(
                                fieldContainer.getAttribute('data-oe-field') === 'arch' ||
                                fieldContainer.getAttribute('data-oe-type') === 'html'
                            )
                        )) {
                        return false;
                    }
                    return baseNode;
                }
            },
            isHintBlacklisted: node => {
                return (node.classList && node.classList.contains('nav-item')) || (
                    node.hasAttribute && (
                        node.hasAttribute('data-target') ||
                        node.hasAttribute('data-oe-model')
                    )
                );
            },
            filterMutationRecords: (records) => {
                return records.filter((record) => {
                    if (record.type === 'attributes'
                            && record.attributeName === 'aria-describedby') {
                        const value = (record.oldValue || record.target.getAttribute(record.attributeName));
                        if (value && value.startsWith('popover')) {
                            // TODO maybe we should just always return false at
                            // this point: never considering the
                            // aria-describedby attribute for any tooltip?
                            const popoverData = Popover.getInstance(record.target);
                            return !popoverData
                                || popoverData.tip.id !== value
                                || !popoverData.tip.classList.contains('o_edit_menu_popover');
                        }
                    }
                    return !(
                        // TODO should probably not check o_header_standard
                        // here, since it is a website class ?
                        (record.target.classList && record.target.classList.contains('o_header_standard')) ||
                        (record.type === 'attributes' && record.attributeName === 'data-last-history-steps')
                    );
                });
            },
            preHistoryUndo: () => {
                this.destroyLinkTools();
            },
            beforeAnyCommand: this._beforeAnyCommand.bind(this),
            commands: powerboxOptions.commands,
            categories: powerboxOptions.categories,
            plugins: options.editorPlugins,
            direction: options.direction || localization.direction || 'ltr',
            collaborationClientAvatarUrl: this._getCollaborationClientAvatarUrl(),
            renderingClasses: ["o_dirty", "o_transform_removal", "oe_edited_link", "o_menu_loading", "o_draggable", "o_link_in_selection"],
            dropImageAsAttachment: options.dropImageAsAttachment,
            foldSnippets: !!options.foldSnippets,
            useResponsiveFontSizes: options.useResponsiveFontSizes,
            showResponsiveFontSizesBadges: options.showResponsiveFontSizesBadges,
            showExtendedTextStylesOptions: options.showExtendedTextStylesOptions,
            getCSSVariableValue: options.getCSSVariableValue,
            convertNumericToUnit: options.convertNumericToUnit,
            autoActivateContentEditable: this.options.autoActivateContentEditable,
        }, editorCollaborationOptions));

        this.odooEditor.addEventListener('contentChanged', function () {
            self.$editable.trigger('content_changed');
        });
        document.addEventListener("mousemove", this._signalOnline, true);
        document.addEventListener("keydown", this._signalOnline, true);
        document.addEventListener("keyup", this._signalOnline, true);
        if (this.odooEditor.document !== document) {
            this.odooEditor.document.addEventListener("mousemove", this._signalOnline, true);
            this.odooEditor.document.addEventListener("keydown", this._signalOnline, true);
            this.odooEditor.document.addEventListener("keyup", this._signalOnline, true);
        }

        this._initialValue = this.getValue();
        const $wrapwrap = $('#wrapwrap');
        if ($wrapwrap.length) {
            $wrapwrap[0].addEventListener('scroll', this.odooEditor.multiselectionRefresh, { passive: true });
            this.$root = this.$root || $wrapwrap;
        }

        this.$editable.on('click', '[data-oe-field][data-oe-sanitize-prevent-edition]', () => {
            this.env.services.dialog.add(AlertDialog, {
                body: _t("Someone with escalated rights previously modified this area, you are therefore not able to modify it yourself."),
            });
        });

        for (const field of this.$editable[0].querySelectorAll('[data-oe-type="text"], [data-oe-type="char"]')) {
            if (!isVisible(field)) {
                fillEmpty(field);
            }
        }

        this._observeOdooFieldChanges();
        this.$editable.on(
            'mousedown touchstart',
            '[data-oe-field]',
            function () {
                self.odooEditor.observerUnactive();
                const $field = $(this);
                if (($field.data('oe-type') === "datetime" || $field.data('oe-type') === "date")) {
                    let selector = '[data-oe-id="' + $field.data('oe-id') + '"]';
                    selector += '[data-oe-field="' + $field.data('oe-field') + '"]';
                    selector += '[data-oe-model="' + $field.data('oe-model') + '"]';
                    const $linkedFieldNodes = self.$editable.find(selector).addBack(selector);
                    $linkedFieldNodes.addClass('o_editable_date_field_linked');
                    if (!$field.hasClass('o_editable_date_field_format_changed')) {
                        $linkedFieldNodes.text($field.data('oe-original-with-format'));
                        $linkedFieldNodes.addClass('o_editable_date_field_format_changed');
                        $linkedFieldNodes.filter('.oe_hide_on_date_edit').addClass('d-none');
                        setTimeout(() => {
                            // we might hide the clicked date, focus the one
                            // supposed to be editable
                            Wysiwyg.setRange($linkedFieldNodes.filter(':not(.oe_hide_on_date_edit)')[0]);
                        }, 0);
                    }
                }
                if ($field.attr('contenteditable') !== 'false') {
                    if ($field.data('oe-type') === "monetary") {
                        $field.attr('contenteditable', false);
                        const $currencyValue = $field.find('.oe_currency_value');
                        $currencyValue.attr('contenteditable', true);
                        $currencyValue.one('mouseup touchend', (e) => {
                            $currencyValue.selectContent();
                        });
                    }
                    if ($field.data('oe-type') === "image") {
                        $field.attr('contenteditable', false);
                        $field.find('img').attr('contenteditable', $field.data('oe-readonly') !== 1);
                    }
                    if ($field.is('[data-oe-many2one-id]')) {
                        $field.attr('contenteditable', false);
                    }
                }
                self.odooEditor.observerActive();
            }
        );

        this.$editable.on('click', '.o_image, .media_iframe_video', e => e.preventDefault());
        this.showTooltip = true;
        this.$editable.on('dblclick', mediaSelector, ev => {
            const targetEl = ev.currentTarget;
            let isEditable =
                // TODO that first check is probably useless/wrong: checking if
                // the media itself has editable content should not be relevant.
                // In fact the content of all media should be marked as non
                // editable anyway.
                targetEl.isContentEditable ||
                // For a media to be editable, the base case is to be in a
                // container whose content is editable.
                (targetEl.parentElement && targetEl.parentElement.isContentEditable);

            if (!isEditable && targetEl.classList.contains('o_editable_media')) {
                isEditable = weUtils.shouldEditableMediaBeEditable(targetEl);
            }

            if (isEditable) {
                this.showTooltip = false;

                if (!isProtected(this.odooEditor.document.getSelection().anchorNode)) {
                    if (this.options.onDblClickEditableMedia && targetEl.nodeName === 'IMG' && targetEl.src) {
                        this.options.onDblClickEditableMedia(ev);
                    } else {
                        this._onDblClickEditableMedia(ev);
                    }
                }
            }
        });

        if (options.snippets) {
            $(this.odooEditor.document.body).addClass('editor_enable');
            this.snippetsMenu = await this._createSnippetsMenuInstance(options);
            await this._insertSnippetMenu();

            this._onBeforeUnload = (event) => {
                if (this.isDirty()) {
                    event.returnValue = _t('This document is not saved!');
                }
            };
            window.addEventListener('beforeunload', this._onBeforeUnload);
        }
        if (this.options.getContentEditableAreas) {
            $(this.options.getContentEditableAreas(this.odooEditor)).find('*').off('mousedown mouseup click');
        }

        // The toolbar must be configured after the snippetMenu is loaded
        // because if snippetMenu is loaded in an iframe, binding of the color
        // buttons must use the jquery loaded in that iframe.
        this._configureToolbar(options);

        $(this.odooEditor.editable).on('mouseup', this._updateEditorUI.bind(this));
        $(this.odooEditor.editable).on('keydown', this._updateEditorUI.bind(this));
        $(this.odooEditor.editable).on('keydown', this._handleShortcuts.bind(this));
        // Ensure the Toolbar always have the correct layout in note.
        this._updateEditorUI();

        this.$root.on('click', (ev) => {
            const $target = $(ev.target).closest('a');

            // Keep popover open if clicked inside it, but not on a button
            if ($(ev.target).parents('.o_edit_menu_popover').length && !$target.length) {
                ev.preventDefault();
            }

            if ($target.is(this.customizableLinksSelector)
                    && $target.is('a')
                    && $target[0].isContentEditable
                    && !$target.attr('data-oe-model')
                    && !$target.find('> [data-oe-model]').length
                    && !$target[0].closest('.o_extra_menu_items')
                    && $target[0].isContentEditable) {
                if (ev.ctrlKey || ev.metaKey) {
                    window.open($target[0].href, '_blank');
                }
                this.linkPopover = $target.data('popover-widget-initialized');
                if (!this.linkPopover) {
                    // TODO this code is ugly maybe the mutex should be in the
                    // editor root widget / the popover should not depend on
                    // editor panel (like originally intended but...) / ...
                    (async () => {
                        let container;
                        if (this.snippetsMenu) {
                            // Await for the editor panel to be fully updated
                            // as some buttons of the link popover we create
                            // here relies on clicking in that editor panel...
                            await this.snippetsMenu._mutex.exec(() => null);
                            container = this.options.document.getElementById('oe_manipulators');
                        }
                        this.linkPopover = LinkPopoverWidget.createFor({
                            target: $target[0],
                            wysiwyg: this,
                            container,
                            notify: (message, params) => {
                                this.notification.add(message, { type: params.type });
                            },
                        });;
                        $target.data('popover-widget-initialized', this.linkPopover);
                    })();
                }
                // Setting the focus on the closest contenteditable element
                // resets the selection inside that element if no selection
                // exists.
                $target.closest('[contenteditable=true]').focus();
                if ($target.closest('#wrapwrap').length && this.snippetsMenu) {
                    this.toggleLinkTools({
                        forceOpen: true,
                        link: $target[0],
                        shouldFocusUrl: ev.detail !== 1,
                    });
                }
            }
        });

        this._onSelectionChange = this._onSelectionChange.bind(this);
        this.odooEditor.document.addEventListener('selectionchange', this._onSelectionChange);
        this.setCSSVariables(this.snippetsMenu ? this.snippetsMenu.el : this.toolbarEl);

        this.odooEditor.addEventListener('preObserverActive', () => {
            // The onPostSanitize will be called right after the
            // editor sanitization (to be right before the historyStep).
            // If any `.o_not_editable` is created while the observer is
            // unactive, now is the time to call `onPostSanitize` before the
            // editor could register a mutation.
            this._onPostSanitize(this.odooEditor.editable);
        });

        if (this.options.autohideToolbar) {
            if (this.odooEditor.isMobile) {
                this.odooEditor.editable.before(this.toolbarEl);
            } else {
                document.body.append(this.toolbarEl);
            }
        }
    }
    setupCollaboration(collaborationChannel) {
        const modelName = collaborationChannel.collaborationModelName;
        const fieldName = collaborationChannel.collaborationFieldName;
        const resId = collaborationChannel.collaborationResId;
        const channelName = `editor_collaboration:${modelName}:${fieldName}:${resId}`;

        if (
            !(modelName && fieldName && resId) ||
            Wysiwyg.activeCollaborationChannelNames.has(channelName)
        ) {
            return;
        }

        this._collaborationChannelName = channelName;
        this._historyStepsBuffer = [];
        Wysiwyg.activeCollaborationChannelNames.add(channelName);

        const collaborationBusListener = ({ detail: notifications}) => {
            for (const { payload, type } of notifications) {
                if (
                    type === 'editor_collaboration' &&
                    payload.model_name === modelName &&
                    payload.field_name === fieldName &&
                    payload.res_id === resId
                ) {
                    if (payload.notificationName === 'html_field_write') {
                        this._onServerLastIdUpdate(payload.notificationPayload.last_step_id);
                    } else if (this._ptpJoined) {
                        this._peerToPeerLoading.then(() => this.ptp.handleNotification(payload));
                    }
                }
            }
        }
        this.busService.addEventListener('notification', collaborationBusListener);
        this.busService.addChannel(this._collaborationChannelName);
        this._collaborationStopBus = () => {
            Wysiwyg.activeCollaborationChannelNames.delete(this._collaborationChannelName);
            this.busService.removeEventListener('notification', collaborationBusListener);
            this.busService.deleteChannel(this._collaborationChannelName);
        }

        this._startCollaborationTime = new Date().getTime();

        this._checkConnectionChange = () => {
            if (!this.ptp) {
                return;
            }
            if (!navigator.onLine) {
                this._signalOffline();
            } else {
                this._signalOnline();
            }
        };

        window.addEventListener('online', this._checkConnectionChange);
        window.addEventListener('offline', this._checkConnectionChange);

        this._collaborationInterval = setInterval(async () => {
            if (this._offlineTimeout || this.preSavePromise || !this.ptp) {
                return;
            }

            const clientsInfos = Object.values(this.ptp.clientsInfos);
            const couldBeDisconnected =
                Boolean(clientsInfos.length) &&
                clientsInfos.every((x) => PTP_CLIENT_DISCONNECTED_STATES.includes(x.peerConnection && x.peerConnection.connectionState));

            if (couldBeDisconnected) {
                this._offlineTimeout = setTimeout(() => {
                    this._signalOffline();
                }, CONSIDER_OFFLINE_TIME);
            }
        }, CHECK_OFFLINE_TIME);

        this._peerToPeerLoading = new Promise(async (resolve) => {
            if (!ICE_SERVERS) {
                ICE_SERVERS = await this._serviceRpc('/web_editor/get_ice_servers');
            }
            let iceServers = ICE_SERVERS;
            if (!iceServers.length) {
                iceServers = [
                    {
                        urls: [
                            'stun:stun1.l.google.com:19302',
                            'stun:stun2.l.google.com:19302',
                        ],
                    }
                ];
            }
            this._iceServers = iceServers;

            this.ptp = this._getNewPtp();

            resolve();
        });

        const editorCollaborationOptions = {
            collaborationClientId: this._currentClientId,
            onHistoryStep: (historyStep) => {
                if (!this.ptp) return;
                this.ptp.notifyAllClients('oe_history_step', historyStep, { transport: 'rtc' });
            },
            onCollaborativeSelectionChange: debounce((collaborativeSelection) => {
                if (!this.ptp) return;
                this.ptp.notifyAllClients('oe_history_set_selection', collaborativeSelection, { transport: 'rtc' });
            }, 50),
            onHistoryMissingParentSteps: async ({ step, fromStepId }) => {
                if (!this.ptp) return;
                const missingSteps = await this.requestClient(
                    step.clientId,
                    'get_missing_steps', {
                        fromStepId: fromStepId,
                        toStepId: step.id
                    },
                    { transport: 'rtc' }
                );
                if (missingSteps === REQUEST_ERROR) return;
                this._processMissingSteps(Array.isArray(missingSteps) ? missingSteps.concat(step) : missingSteps);
            },
        };
        if (this.options.postProcessExternalSteps) {
            editorCollaborationOptions.postProcessExternalSteps = this.options.postProcessExternalSteps;
        }
        return editorCollaborationOptions;
    }
    setupToolbar(toolbarEl) {
        this.toolbarEl = toolbarEl;
        this.odooEditor.setupToolbar(toolbarEl);
        this._configureToolbar(this.options)
        this._updateEditorUI();
    }
    /**
     * @override
     */
    destroy() {
        // Sometimes, the component is started and destroyed so quickly that
        // external calls to `wysiwyg.getColorPickerTemplateService()` fail by
        // the time it's done, even though `wysiwyg` was properly instantiated.
        // As it's not needed once the component is destroyed, we return null.
        this.getColorPickerTemplateService = () => null;
        Wysiwyg.activeWysiwygs.delete(this);

        this._stopPeerToPeer();
        document.removeEventListener("mousemove", this._signalOnline, true);
        document.removeEventListener("keydown", this._signalOnline, true);
        document.removeEventListener("keyup", this._signalOnline, true);
        this._collaborationStopBus && this._collaborationStopBus();
        if (this.odooEditor) {
            this.odooEditor.document.removeEventListener("mousemove", this._signalOnline, true);
            this.odooEditor.document.removeEventListener("keydown", this._signalOnline, true);
            this.odooEditor.document.removeEventListener("keyup", this._signalOnline, true);
            this.odooEditor.document.removeEventListener('selectionchange', this._onSelectionChange);
            this.odooEditor.destroy();
        }
        if (this.snippetsMenu) {
            this.snippetsMenu.destroy();
        }
        // If peer to peer is initializing, wait for properly closing it.
        if (this._peerToPeerLoading) {
            this._peerToPeerLoading.then(()=> {
                this._stopPeerToPeer();
                this._collaborationStopBus && this._collaborationStopBus();
            });
        }
        clearInterval(this._collaborationInterval);
        this.$editable && this.$editable.off('blur', this._onBlur);
        document.removeEventListener('mousedown', this._onDocumentMousedown, true);
        const $body = $(document.body);
        $body.off('mousemove', this.resizerMousemove);
        $body.off('mouseup', this.resizerMouseup);
        const $wrapwrap = $('#wrapwrap');
        if ($wrapwrap.length && this.odooEditor) {
            $('#wrapwrap')[0].removeEventListener('scroll', this.odooEditor.multiselectionRefresh, { passive: true });
        }
        $(this.$root).off('click');
        this.toolbarEl?.remove();
        this.imageCropEL?.remove();
        if (this.linkPopover) {
            this.linkPopover.hide();
        }
        if (this._checkConnectionChange) {
            window.removeEventListener('online', this._checkConnectionChange);
            window.removeEventListener('offline', this._checkConnectionChange);
        }
        window.removeEventListener('beforeunload', this._onBeforeUnload);
        for (const timeout of this.tooltipTimeouts) {
            clearTimeout(timeout);
        }
        document.removeEventListener('scroll', this._onScroll, true);
    }
    /**
     * @override
     */
    _renderElement() {
        this.$editable = this.options.editable || $('<div class="note-editable">');

        // We add the field's name as id so default_focus will target it if
        // needed. For that to work, it has to already be editable but note that
        // the editor is at this point not yet instantiated.
        if (typeof this.options.fieldId !== 'undefined' && !this.options.inIframe) {
            this.$editable.attr('id', this.options.fieldId);
            this.$editable.attr('contenteditable', true);
        }

        this.$root = this.$editable;
        if (this.options.height) {
            this.$editable.height(this.options.height);
        }
        if (this.options.minHeight) {
            this.$editable.css('min-height', this.options.minHeight);
        }
        if (this.options.maxHeight && this.options.maxHeight > 10) {
            this.$editable.css('max-height', this.options.maxHeight);
        }
        if (this.options.resizable && !isMobileOS()) {
            const $wrapper = $('<div class="o_wysiwyg_wrapper odoo-editor">');
            this.$root = $wrapper;
            $wrapper.append(this.$editable);
            this.$resizer = $(`<div class="o_wysiwyg_resizer">
                <div class="o_wysiwyg_resizer_hook"></div>
                <div class="o_wysiwyg_resizer_hook"></div>
                <div class="o_wysiwyg_resizer_hook"></div>
            </div>`);
            $wrapper.append(this.$resizer);
            this._replaceElement($wrapper);

            const minHeight = this.options.minHeight || 100;
            this.$editable.height(this.options.height || minHeight);

            // resizer hooks
            let startOffsetTop;
            let startHeight;
            const $body = $(document.body);
            const resizerMousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                $body.on('mousemove', this.resizerMousemove);
                $body.on('mouseup', this.resizerMouseup);
                startHeight = this.$editable.height();
                startOffsetTop = e.pageY;
            };
            this.resizerMousemove = (e) => {
                const offsetTop = e.pageY - startOffsetTop;
                let height = startHeight + offsetTop;
                if (height < minHeight) {
                    height = minHeight;
                }
                this.$editable.height(height);
            };
            this.resizerMouseup = () => {
                $body.off('mousemove', this.resizerMousemove);
                $body.off('mouseup', this.resizerMouseup);
            };
            this.$resizer.on('mousedown', resizerMousedown);
        } else {
            if (!this.options.sideAttach) {
                this._replaceElement(this.$editable);
            }
        }
    }
    /**
     * @private
     */
    _replaceElement($el) {
        this.el.replaceWith($el[0]);
        this.el = $el[0];
        this.$el = $el;
    }
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------
    /**
     * Return the editable area.
     *
     * @returns {jQuery}
     */
    getEditable() {
        return this.$editable;
    }
    /**
     * Return true if the content has changed.
     *
     * @returns {Boolean}
     */
    isDirty() {
        // TODO review... o_dirty is not even a set up system in web_editor,
        // only in website... although some other code checks that class in
        // web_editor for no apparent reason either. Also, why comparing HTML
        // values if already confirmed dirty with the first check?
        const isDocumentDirty = this.$editable[0].ownerDocument.defaultView.$(".o_dirty").length;
        return this._initialValue !== (this.getValue() || this.$editable.val()) && isDocumentDirty;
    }
    /**
     * Get the value of the editable element.
     *
     * @param {object} [options]
     * @param {jQuery} [options.$layout]
     * @returns {String}
     */
    getValue(options) {
        var $editable = options && options.$layout || this.$editable.clone();
        $editable.find('[contenteditable]').removeAttr('contenteditable');
        $editable.find('[class=""]').removeAttr('class');
        $editable.find('[style=""]').removeAttr('style');
        $editable.find('[title=""]').removeAttr('title');
        $editable.find('[alt=""]').removeAttr('alt');
        $editable.find('[data-bs-original-title=""]').removeAttr('data-bs-original-title');
        $editable.find('[data-editor-message]').removeAttr('data-editor-message');
        $editable.find('a.o_image, span.fa, i.fa').html('');
        $editable.find('[aria-describedby]').removeAttr('aria-describedby').removeAttr('data-bs-original-title');
        if (this.odooEditor) {
            this.odooEditor.cleanForSave($editable[0]);
            this._attachHistoryIds($editable[0]);
        }
        return $editable.html();
    }
    /**
     * Save the content in the target
     *      - in init option beforeSave
     *      - receive editable jQuery DOM as attribute
     *      - called after deactivate codeview if needed
     * @returns {Promise}
     *      - resolve with true if the content was dirty
     */
    save() {
        const isDirty = this.isDirty();
        const html = this.getValue();
        if (this.$editable.is('textarea')) {
            this.$editable.val(html);
        } else {
            this.$editable.html(html);
        }
        return Promise.resolve({isDirty: isDirty, html: html});
    }
    /**
     * Reset the history.
     */
    historyReset() {
        this.odooEditor.historyReset();
    }
    /**
     * Saves the content or the given editable.
     *
     * @param {boolean} [reload=true]
     * @param {Object} [editable=false] Specific editable to save
     * @returns {Promise}
     */
    async saveContent(reload = true, editable = false) {
        this.savingContent = true;
        if (!editable) {
            await this.cleanForSave();
            const editables = "getContentEditableAreas" in this.options ? this.options.getContentEditableAreas(this.odooEditor) : [];
            await this.savePendingImages(editables.length ? $(editables) : this.$editable);
            await this._saveViewBlocks();
        } else {
            await this.cleanForSave(editable);
            await this.savePendingImages(editable);
            await this._saveViewBlocks(false, editable);
        }

        this.savingContent = false;

        window.removeEventListener('beforeunload', this._onBeforeUnload);
        if (reload) {
            window.location.reload();
        }
    }
    /**
     * Checks if the Wysiwyg is currently saving content. It can be used to
     * prevent some unwanted actions during save.
     *
     * @returns {Boolean}
     */
    isSaving() {
        return !!this.savingContent;
    }
    /**
     * Asks the user if he really wants to discard its changes (if there are
     * some of them), then simply reload the page if he wants to.
     *
     * @param {boolean} [reload=true]
     *        true if the page has to be reloaded when the user answers yes
     *        (do nothing otherwise but add this to allow class extension)
     * @returns {Promise}
     */
    cancel(reload) {
        var self = this;
        return new Promise((resolve, reject) => {
            this.env.services.dialog.add(ConfirmationDialog, {
                body: _t("If you discard the current edits, all unsaved changes will be lost. You can cancel to return to edit mode."),
                confirm: () => resolve(),
                cancel: () => reject()
            });
        }).then(function () {
            if (reload !== false) {
                window.onbeforeunload = null;
                return self._reload();
            }
        });
    }
    /**
     * Create/Update attachments for unsaved images.
     * (e.g. modified/cropped images, drag & dropped images, pasted images..)
     *
     * @param {jQuery} $editable
     * @returns {Promise}
     */
    savePendingImages($editable = this.$editable) {
        const defs = Array.from($editable).map(async (editableEl) => {
            const { resModel, resId } = this._getRecordInfo(editableEl);
            // When saving a webp, o_b64_image_to_save is turned into
            // o_modified_image_to_save by _saveB64Image to request the saving
            // of the pre-converted webp resizes and all the equivalent jpgs.
            const b64Proms = [...editableEl.querySelectorAll('.o_b64_image_to_save')].map(async el => {
                const dirtyEditable = el.closest(".o_dirty");
                if (dirtyEditable && dirtyEditable !== editableEl) {
                    // Do nothing as there is an editable element closer to the
                    // image that will perform the `_saveB64Image()` call with
                    // the correct "resModel" and "resId" parameters.
                    return;
                }
                await this._saveB64Image(el, resModel, resId);
            });
            const modifiedProms = [...editableEl.querySelectorAll('.o_modified_image_to_save')].map(async el => {
                const dirtyEditable = el.closest(".o_dirty");
                if (dirtyEditable && dirtyEditable !== editableEl) {
                    // Do nothing as there is an editable element closer to the
                    // image that will perform the `_saveModifiedImage()` call
                    // with the correct "resModel" and "resId" parameters.
                    return;
                }
                await this._saveModifiedImage(el, resModel, resId);
            });
            return Promise.all([...b64Proms, ...modifiedProms]);
        });
        return Promise.all(defs);
    }
    /**
     * @param {String} value
     * @returns {String}
     */
    setValue(value) {
        this.odooEditor.resetContent(value);
    }
    /**
     * Undo one step of change in the editor.
     */
    undo() {
        this.odooEditor.historyUndo();
    }
    /**
     * Redo one step of change in the editor.
     */
    redo() {
        this.odooEditor.historyRedo();
    }
    /**
     * Focus inside the editor.
     *
     * Set cursor to the editor latest position before blur or to the last editable node, ready to type.
     */
    focus() {
        if (this.odooEditor && !this.odooEditor.historyResetLatestComputedSelection(true)) {
            // If the editor don't have an history step to focus to,
            // We place the cursor after the end of the editor exiting content.
            const range = document.createRange();
            const elementToTarget = this.$editable[0].lastElementChild ? this.$editable[0].lastElementChild : this.$editable[0];
            range.selectNodeContents(elementToTarget);
            range.collapse();

            const selection = this.odooEditor.document.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }
    }
    getDeepRange() {
        return getDeepRange(this.odooEditor.editable);
    }
    closestElement(...args) {
        return closestElement(...args);
    }
    async cleanForSave(editable = this.odooEditor.editable) {
        if (this.odooEditor) {
            this.odooEditor.cleanForSave(editable);
            this._attachHistoryIds(editable);
        }

        if (this.snippetsMenu) {
            await this.snippetsMenu.cleanForSave();
        }
    }
    isSelectionInEditable() {
        return this.odooEditor.isSelectionInEditable();
    }
    /**
     * Start or resume the Odoo field changes muation observers.
     *
     * Necessary to keep all copies of a given field at the same value throughout the page.
     */
    _observeOdooFieldChanges() {
        const observerOptions = {
            childList: true,
            subtree: true,
            attributes: true,
            characterData: true,
            attributeOldValue: true,
        };
        if (this.odooFieldObservers) {
            for (let observerData of this.odooFieldObservers) {
                observerData.observer.observe(observerData.field, observerOptions);
            }
        } else {
            const odooFieldSelector = '[data-oe-model], [data-oe-translation-initial-sha]';
            const $odooFields = this.$editable.find(odooFieldSelector);
            const renderingClassesSelector = this.odooEditor.options.renderingClasses
                .map(className => `.${className}`).join(", ");
            this.odooFieldObservers = [];

            $odooFields.each((i, field) => {
                const observer = new MutationObserver((mutations) => {
                    mutations = this.odooEditor.filterMutationRecords(mutations);
                    mutations = mutations.filter(rec =>
                        !(rec.type === "attributes" && (rec.attributeName.startsWith("data-oe-t")))
                    );
                    if (!mutations.length) {
                        return;
                    }

                    let $node = $(field);
                    // Do not forward "unstyled" copies to other nodes.
                    if ($node.hasClass('o_translation_without_style')) {
                        return;
                    }
                    let $nodes = $odooFields.filter(function () {
                        return this !== field;
                    });
                    if ($node.data('oe-model')) {
                        $nodes = $nodes.filter('[data-oe-model="' + $node.data('oe-model') + '"]')
                            .filter('[data-oe-id="' + $node.data('oe-id') + '"]')
                            .filter('[data-oe-field="' + $node.data('oe-field') + '"]');
                    }

                    if ($node.data('oe-translation-initial-sha')) {
                        $nodes = $nodes.filter('[data-oe-translation-initial-sha="' + $node.data('oe-translation-initial-sha') + '"]');
                    }
                    if ($node.data('oe-type')) {
                        $nodes = $nodes.filter('[data-oe-type="' + $node.data('oe-type') + '"]');
                    }
                    if ($node.data('oe-expression')) {
                        $nodes = $nodes.filter('[data-oe-expression="' + $node.data('oe-expression') + '"]');
                    } else if ($node.data('oe-xpath')) {
                        $nodes = $nodes.filter('[data-oe-xpath="' + $node.data('oe-xpath') + '"]');
                    }
                    if ($node.data('oe-contact-options')) {
                        $nodes = $nodes.filter("[data-oe-contact-options='" + $node[0].dataset.oeContactOptions + "']");
                    }

                    let nodes = $node.get();

                    if ($node.data('oe-type') === "many2one") {
                        $nodes = $nodes.add($('[data-oe-model]')
                            .filter(function () {
                                return this !== $node[0] && nodes.indexOf(this) === -1;
                            })
                            .filter('[data-oe-many2one-model="' + $node.data('oe-many2one-model') + '"]')
                            .filter('[data-oe-many2one-id="' + $node.data('oe-many2one-id') + '"]')
                            .filter('[data-oe-type="many2one"]'));

                        $nodes = $nodes.add($('[data-oe-model]')
                            .filter(function () {
                                return this !== $node[0] && nodes.indexOf(this) === -1;
                            })
                            .filter('[data-oe-model="' + $node.data('oe-many2one-model') + '"]')
                            .filter('[data-oe-id="' + $node.data('oe-many2one-id') + '"]')
                            .filter('[data-oe-field="name"]'));
                    }

                    // TODO adapt in master: remove this and only use the
                    //  `_pauseOdooFieldObservers(field)` call.
                    this.__odooFieldObserversToPause = this.odooFieldObservers.filter(
                        // Exclude inner translation fields observers. They
                        // still handle translation synchronization inside the
                        // targeted field.
                        observerData => !observerData.field.dataset.oeTranslationInitialSha ||
                            !field.contains(observerData.field)
                    );
                    this._pauseOdooFieldObservers();
                    // Tag the date fields to only replace the value
                    // with the original date value once (see mouseDown event)
                    if ($node.hasClass('o_editable_date_field_format_changed')) {
                        $nodes.addClass('o_editable_date_field_format_changed');
                    }
                    // Ignore the editor's rendering classes when copying field
                    // content.
                    const fieldNodeClone = $node[0].cloneNode(true);
                    for (const node of fieldNodeClone.querySelectorAll(renderingClassesSelector)) {
                        node.classList.remove(...this.odooEditor.options.renderingClasses);
                    }
                    const html = $(fieldNodeClone).html();
                    this.odooEditor.withoutRollback(() => {
                        for (const node of $nodes) {
                            if (node.classList.contains('o_translation_without_style')) {
                                // For generated elements such as the navigation
                                // labels of website's table of content, only the
                                // text of the referenced translation must be used.
                                const text = $node.text();
                                if (node.innerText !== text) {
                                    node.innerText = text;
                                }
                                continue;
                            }
                            if (node.innerHTML !== html) {
                                node.innerHTML = html;
                            }
                        }
                    });
                    this._observeOdooFieldChanges();
                });
                observer.observe(field, observerOptions);
                this.odooFieldObservers.push({field: field, observer: observer});
            });
        }
    }
    /**
     * Stop the field changes mutation observers.
     */
    _pauseOdooFieldObservers() {
        // TODO adapt in master: remove this and directly exclude observers with
        // targets inside the current field (we use `this.odooFieldObservers`
        // as fallback for compatibility here).
        const fieldObserversData = this.__odooFieldObserversToPause || this.odooFieldObservers;
        for (let observerData of fieldObserversData) {
            observerData.observer.disconnect();
        }
    }
    /**
     * Open the link tools or the image link tool depending on the selection.
     */
    openLinkToolsFromSelection() {
        const targetEl = this.odooEditor.document.getSelection().getRangeAt(0).startContainer;
        // Link tool is different if the selection is an image or a text.
        if (targetEl.nodeType === Node.ELEMENT_NODE
                && (targetEl.tagName === 'IMG' || targetEl.querySelectorAll('img').length === 1)) {
            this.odooEditor.dispatchEvent(new Event('activate_image_link_tool'));
            return;
        }
        this.toggleLinkTools();
    }
    /**
     * Toggle the Link tools/dialog to edit links. If a snippet menu is present,
     * use the link tools, otherwise use the dialog.
     *
     * @param {boolean} [options.forceOpen] default: false
     * @param {boolean} [options.forceDialog] force to open the dialog
     * @param {boolean} [options.link] The anchor element to edit if it is known.
     * @param {boolean} [options.shoudFocusUrl=true] Disable the automatic focusing of the URL field.
     */
    async toggleLinkTools(options = {}) {
        const shouldFocusUrl = options.shouldFocusUrl === undefined ? true : options.shouldFocusUrl;

        const linkEl = getInSelection(this.odooEditor.document, 'a');
        if (linkEl && (!linkEl.matches(this.customizableLinksSelector) || !linkEl.isContentEditable)) {
            return;
        }
        if (this.snippetsMenu && !options.forceDialog) {
            if (options.link && options.link.querySelector(mediaSelector) &&
                    !options.link.textContent.trim() && wysiwygUtils.isImg(this.lastElement)) {
                // If the link contains a media without text, the link is
                // editable in the media options instead.
                if (options.shoudFocusUrl) {
                    // Wait for the editor panel to be fully updated.
                    this.snippetsMenu._mutex.exec(() => {
                        // This is needed to focus the URL input when clicking
                        // on the "Edit link" of the popover.
                        this.odooEditor.dispatchEvent(new Event('activate_image_link_tool'));
                    });
                }
                return;
            }
            if (options.forceOpen || !this.state.linkToolProps) {
                const $button = $(this.toolbarEl.querySelector('#create-link'));
                if (!this.state.linkToolProps || ![options.link, ...wysiwygUtils.ancestors(options.link)].includes(this.linkToolsInfos.link)) {
                    const { link } = getOrCreateLink({
                        containerNode: this.odooEditor.editable,
                        startNode: options.link || this.lastMediaClicked,
                    });
                    if (!link) {
                        return;
                    }
                    const addHintClasses = () => {
                        this.odooEditor.observerUnactive("hint_classes");
                        link.classList.add('oe_edited_link');
                        $button.addClass('active');
                        this.odooEditor.observerActive("hint_classes");
                    };
                    const removeHintClasses = () => {
                        this.odooEditor.observerUnactive("hint_classes");
                        link.classList.remove('oe_edited_link');
                        $button.removeClass('active');
                        this.odooEditor.observerActive("hint_classes");
                    };
                    this.linkToolsInfos = {
                        onDestroy: () => {},
                        link,
                        removeHintClasses,
                    };

                    addHintClasses();
                    this.state.linkToolProps = {
                        ...this.options.linkOptions,
                        wysiwyg: this,
                        editable: this.odooEditor.editable,
                        link,
                        // If the link contains an image or an icon do not
                        // display the label input (e.g. some mega menu links).
                        needLabel: !link.querySelector('.fa, img'),
                        shouldFocusUrl,
                        $button,
                        onColorCombinationClassChange: (colorCombinationClass) => {
                            this.linkToolsInfos.colorCombinationClass = colorCombinationClass;
                        },
                        onPreApplyLink: removeHintClasses,
                        onPostApplyLink: addHintClasses,
                        onDestroy: () => {
                            removeHintClasses();
                            this.linkToolsInfos.onDestroy();
                        },
                        getColorpickerTemplate: this.getColorpickerTemplate.bind(this),
                    };
                }
                // update the shouldFocusUrl prop to focus on url when double click and click edit link
                this.state.linkToolProps.shouldFocusUrl = shouldFocusUrl;
                const _onClick = ev => {
                    if (
                        !ev.target.closest('#create-link') &&
                        (!ev.target.closest('.oe-toolbar') || !ev.target.closest('we-customizeblock-option')) &&
                        !ev.target.closest('.ui-autocomplete') &&
                        (!this.state.linkToolProps || ![ev.target, ...wysiwygUtils.ancestors(ev.target)].includes(this.linkToolsInfos.link))
                    ) {
                        // Destroy the link tools on click anywhere outside the
                        // toolbar if the target is the orgiginal target not in the original target.
                        this.destroyLinkTools();
                        this.odooEditor.document.removeEventListener('click', _onClick, true);
                        document.removeEventListener('click', _onClick, true);
                    }
                };
                this.odooEditor.document.addEventListener('click', _onClick, true);
                document.addEventListener('click', _onClick, true);
            } else {
                this.destroyLinkTools();
            }
        } else {
            const historyStepIndex = this.odooEditor.historySize() - 1;
            this.odooEditor.historyPauseSteps();
            let { link } = getOrCreateLink({
                containerNode: this.odooEditor.editable,
                startNode: options.link,
            });
            if (!link) {
                this.odooEditor.historyUnpauseSteps();
                return
            }
            this._shouldDelayBlur = true;
            this.env.services.dialog.add(LinkDialog, {
                ...this.options.linkOptions,
                editable: this.odooEditor.editable,
                link,
                needLabel: true && !link.querySelector('img'),
                focusField: link.innerHTML ? 'url' : '',
                onSave: (data) => {
                    if (!data) {
                        return;
                    }
                    getDeepRange(this.$editable[0], {range: data.range, select: true});
                    if (this.options.userGeneratedContent) {
                        data.rel = 'ugc';
                    }
                    data.linkDialog.applyLinkToDom(data);
                    this.odooEditor.historyUnpauseSteps();
                    this.odooEditor.historyStep();
                    const link = data.linkDialog.$link[0];
                    setSelection(link, 0, link, link.childNodes.length, false);
                    link.focus();
                },
                onClose: () => {
                    this.odooEditor.historyUnpauseSteps();
                    this.odooEditor.historyRevertUntil(historyStepIndex)
                }
            });
        }
    }
    /**
     * Open one of the ChatGPTDialogs to generate or modify content.
     *
     * @param {'prompt'|'alternatives'} [mode='prompt']
     */
    openChatGPTDialog(mode = 'prompt') {
        const restore = preserveCursor(this.odooEditor.document);
        const params = {
            insert: content => {
                this.odooEditor.historyPauseSteps();
                const insertedNodes = this.odooEditor.execCommand('insert', content);
                this.odooEditor.historyUnpauseSteps();
                this.notification.add(_t('Your content was successfully generated.'), {
                    title: _t('Content generated'),
                    type: 'success',
                });
                this.odooEditor.historyStep();
                // Add a frame around the inserted content to highlight it for 2
                // seconds.
                const start = insertedNodes?.length && closestElement(insertedNodes[0]);
                const end = insertedNodes?.length && closestElement(insertedNodes[insertedNodes.length - 1]);
                if (start && end) {
                    const divContainer = this.odooEditor.editable.parentElement;
                    let [parent, left, top] = [start.offsetParent, start.offsetLeft, start.offsetTop - start.scrollTop];
                    while (parent && !parent.contains(divContainer)) {
                        left += parent.offsetLeft;
                        top += parent.offsetTop - parent.scrollTop;
                        parent = parent.offsetParent;
                    }
                    let [endParent, endTop] = [end.offsetParent, end.offsetTop - end.scrollTop];
                    while (endParent && !endParent.contains(divContainer)) {
                        endTop += endParent.offsetTop - endParent.scrollTop;
                        endParent = endParent.offsetParent;
                    }
                    const div = document.createElement('div');
                    div.classList.add('o-chatgpt-content');
                    const FRAME_PADDING = 3;
                    div.style.left = `${left - FRAME_PADDING}px`;
                    div.style.top = `${top - FRAME_PADDING}px`;
                    div.style.width = `${Math.max(start.offsetWidth, end.offsetWidth) + (FRAME_PADDING * 2)}px`;
                    div.style.height = `${endTop + end.offsetHeight - top + (FRAME_PADDING * 2)}px`;
                    divContainer.prepend(div);
                    setTimeout(() => div.remove(), 2000);
                }
            },
        };
        if (mode === 'alternatives') {
            params.originalText = this.odooEditor.document.getSelection().toString() || '';
        }
        this.odooEditor.document.getSelection().collapseToEnd();
        this.env.services.dialog.add(
            mode === 'prompt' ? ChatGPTPromptDialog : ChatGPTAlternativesDialog,
            params,
            { onClose: restore },
        );
    }
    /**
     * Removes the current Link.
     */
    removeLink() {
        if (this.snippetsMenu && wysiwygUtils.isImg(this.lastElement)) {
            this.snippetsMenu._mutex.exec(() => {
                // Wait for the editor panel to be fully updated.
                this.odooEditor.dispatchEvent(new Event('deactivate_image_link_tool'));
            });
        } else {
            this.odooEditor.execCommand('unlink');
        }
    }
    /**
     * Destroy the Link tools/dialog and restore the selection.
     */
    // todo: review me
    async destroyLinkTools() {
        if (this.state.linkToolProps) {
            const selection = this.odooEditor.document.getSelection();
            const link = this.linkToolsInfos.link;
            let anchorNode
            let focusNode;
            let anchorOffset = 0;
            let focusOffset;
            if (selection && link.parentElement) {
                // Focus the link after the dialog element is removed.
                if (shouldUnlink(this.linkToolsInfos.link, this.linkToolsInfos.colorCombinationClass)) {
                    if (link.childNodes.length) {
                        anchorNode = link.childNodes[0];
                        focusNode = link.childNodes[link.childNodes.length - 1];
                    } else {
                        const parent = link.parentElement;
                        const index = Array.from(parent.childNodes).indexOf(link);
                        anchorNode = focusNode = parent;
                        anchorOffset = focusOffset = index;
                    }
                } else {
                    const commonBlock = selection.rangeCount && closestBlock(selection.getRangeAt(0).commonAncestorContainer);
                    [anchorNode, focusNode] = commonBlock && link.contains(commonBlock) ? [commonBlock, commonBlock] : [link, link];
                }
                if (!focusOffset) {
                    focusOffset = focusNode.childNodes.length || focusNode.length;
                }
            }
            this.linkToolsInfos.removeHintClasses();
            if (anchorNode) {
                setSelection(anchorNode, anchorOffset, focusNode, focusOffset, false);
            }
            this.state.linkToolProps = undefined;
        }
    }
    /**
     * Take an image's URL and display it in a fullscreen viewer.
     *
     * @todo should use `useFileViewer` instead once Wysiwyg becomes an Owl Component.
     * @param {string} url
     */
    showImageFullscreen(url) {
        const viewerId = `web.file_viewer${fileViewerId++}`;
        registry.category("main_components").add(viewerId, {
            Component: FileViewer,
            props: {
                files: [{
                        isImage: true,
                        isViewable: true,
                        displayName: url,
                        defaultSource: url,
                        downloadUrl: url,
                }],
                startIndex: 0,
                close: () => {
                    registry.category('main_components').remove(viewerId);
                },
            },
        });
        this.odooEditor.document.getSelection()?.collapseToEnd();
        this.odooEditor.editable.blur();
    }
    /**
     * Open the media dialog.
     *
     * Used to insert or change image, icon, document and video.
     *
     * @param {object} params
     * @param {Node} [params.node] Optionnal
     * @param {Node} [params.htmlClass] Optionnal
     * @param {Class} [params.MediaDialog] Optional
     */
    openMediaDialog(params = {}) {
        const sel = this.odooEditor.document.getSelection();

        if (!sel.rangeCount) {
            return;
        }
        const range = sel.getRangeAt(0);
        // We lose the current selection inside the content editable when we
        // click the media dialog button so we need to be able to restore the
        // selection when the modal is closed.
        const restoreSelection = preserveCursor(this.odooEditor.document);

        const editable = OdooEditorLib.closestElement(params.node || range.startContainer, '.o_editable') || this.odooEditor.editable;
        const { resModel, resId, field, type } = this._getRecordInfo(editable);

        this.env.services.dialog.add(params.MediaDialog || MediaDialog, {
            resModel,
            resId,
            useMediaLibrary: !!(field && (resModel === 'ir.ui.view' && field === 'arch' || type === 'html')),
            media: params.node,
            save: this._onMediaDialogSave.bind(this, {
                node: params.node,
                restoreSelection: restoreSelection,
            }),
            onAttachmentChange: this._onAttachmentChange.bind(this),
            close: () => restoreSelection(),
            ...this.options.mediaModalParams,
            ...params,
        });
    }
    // todo: test me
    showEmojiPicker() {
        const targetEl = this.odooEditor.document.getSelection();
        const closest = closestBlock(targetEl.anchorNode);
        const restoreSelection = preserveCursor(this.odooEditor.document);

        this.popover.add(closest, EmojiPicker, {
                onSelect: (str) => {
                    restoreSelection();
                    this.odooEditor.execCommand('insert', str);
                },
            }, {
                onPositioned: (popover) => {
                    restoreSelection();
                    // Set the 'parentContextRect' option in 'options' when
                    // 'getContextFromParentRect' is available. This facilitates
                    // element positioning relative to a parent or reference
                    // rectangle.
                    const options = {};
                    if (this.options.getContextFromParentRect) {
                        options['parentContextRect'] = this.options.getContextFromParentRect();
                    }
                    const rangePosition = getRangePosition(popover, this.options.document, options);
                    popover.style.top = rangePosition.top + 'px';
                    popover.style.left = rangePosition.left + 'px';
                    const oInputBox = popover.querySelector('input');
                    oInputBox?.focus();
                },
            },
        );
    }
    /**
     * Sets custom CSS Variables on the snippet menu element.
     * Used for color previews and color palette to get the color
     * values of the editable. (e.g. if the editable is in an iframe
     * with different SCSS color values as the top window.)
     *
     * @param {HTMLElement} element
     */
    setCSSVariables(element) {
        const stylesToCopy = weUtils.EDITOR_COLOR_CSS_VARIABLES;

        for (const style of stylesToCopy) {
            element.style.setProperty(`--we-cp-${style}`, weUtils.getCSSVariableValue(style));
        }

        element.classList.toggle('o_we_has_btn_outline_primary',
            weUtils.getCSSVariableValue('btn-primary-outline') === 'true');
        element.classList.toggle('o_we_has_btn_outline_secondary',
            weUtils.getCSSVariableValue('btn-secondary-outline') === 'true');
    }
    /**
     * Detached function to allow overriding.
     *
     * @param {Object} params binded @see openMediaDialog
     * @param {Element} element provided by the dialog
     */
    _onMediaDialogSave(params, element) {
        params.restoreSelection();
        if (!element) {
            return;
        }

        if (params.node) {
            const isIcon = (el) => el.matches('i.fa, span.fa');
            const changedIcon = isIcon(params.node) && isIcon(element);
            if (changedIcon) {
                // Preserve tag name when changing an icon and not recreate the
                // editors unnecessarily.
                for (const attribute of element.attributes) {
                    params.node.setAttribute(attribute.nodeName, attribute.nodeValue);
                }
            } else {
                params.node.replaceWith(element);
            }
            this.odooEditor.unbreakableStepUnactive();
            this.odooEditor.historyStep();
            // Refocus again to save updates when calling `_onWysiwygBlur`
            this.odooEditor.editable.focus();
        } else {
            return this.odooEditor.execCommand('insert', element);
        }

        if (this.snippetsMenu) {
            this.snippetsMenu.activateSnippet($(element)).then(() => {
                if (element.tagName === 'IMG') {
                    $(element).trigger('image_changed');
                }
            });
        }
    }
    getInSelection(selector) {
        return getInSelection(this.odooEditor.document, selector);
    }
    /**
     * Adds an empty action in the mutex. Can be used to wait for some options
     * to be initialized before doing something else.
     *
     * @returns {Promise}
     */
    waitForEmptyMutexAction() {
        if (this.snippetsMenu) {
            return this.snippetsMenu.execWithLoadingEffect(() => null, false);
        }
        return Promise.resolve();
    }
    getColorpickerTemplate() {
        // Public user using the editor may have a colorpalette but with
        // the default wysiwyg ones.
        if (!session.is_website_user) {
            return this.getColorPickerTemplateService();
        }
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    _getRecordInfo() {
        const { res_model: resModel, res_id: resId } = this.options.recordInfo;
        return { resModel, resId };
    }
    /**
     * Returns an instance of the snippets menu.
     *
     * @param {Object} [options]
     * @returns {widget}
     */
    async _createSnippetsMenuInstance(options={}) {
        const snippetsEditor = await odoo.loader.modules.get('@web_editor/js/editor/snippets.editor')[Symbol.for('default')];
        const { SnippetsMenu } = snippetsEditor;
        return new SnippetsMenu(this, Object.assign({
            wysiwyg: this,
            selectorEditableArea: '.o_editable',
        }, options));
    }
    _setToolbarProps() {
        this.state.toolbarProps = {
            ...this.options.toolbarOptions,
            onColorpaletteDropdownShow: this.onColorpaletteDropdownShow.bind(this),
            onColorpaletteDropdownHide: this.onColorpaletteDropdownHide.bind(this),
            textColorPaletteProps: this.colorPalettesProps.text,
            backgroundColorPaletteProps: this.colorPalettesProps.background,
        }
    }
    _configureToolbar(options) {
        const $toolbar = $(this.toolbarEl);
        // Prevent selection loss when interacting with the toolbar buttons.
        $toolbar.find('.btn-group').on('mousedown', e => {
            if (
                // Prevent when clicking on btn-group but not on dropdown items.
                !e.target.closest('.dropdown-menu') ||
                // Unless they have a data-call in which case there is an editor
                // command that is bound to it so we need to preventDefault.
                e.target.closest('.btn') && e.target.closest('.btn').getAttribute('data-call')
            ) {
                e.preventDefault();
            }
        });
        const openTools = e => {
            e.preventDefault();
            e.stopImmediatePropagation();
            e.stopPropagation();
            switch (e.currentTarget.id) {
                case 'create-link':
                    this.toggleLinkTools();
                    break;
                case 'media-insert':
                case 'media-replace':
                    this.openMediaDialog({ node: this.lastMediaClicked });
                    break;
                case 'media-description': {
                    const allEscQuots = /&quot;/g;
                    const alt = ($(this.lastMediaClicked).attr('alt') || "").replace(allEscQuots, '"');
                    const tag_title = (
                        $(this.lastMediaClicked).attr('title') ||
                        $(this.lastMediaClicked).data('original-title') ||
                        ""
                    ).replace(allEscQuots, '"');

                    this.env.services.dialog.add(AltDialog, {
                        alt,
                        tag_title,
                        confirm: (newAlt, newTitle) => {
                            if (newAlt) {
                                this.lastMediaClicked.setAttribute('alt', newAlt);
                            } else {
                                this.lastMediaClicked.removeAttribute('alt');
                            }
                            if (newTitle) {
                                this.lastMediaClicked.setAttribute('title', newTitle);
                            } else {
                                this.lastMediaClicked.removeAttribute('title');
                            }
                        },
                    });
                    break;
                }
                case 'open-chatgpt': {
                    this.openChatGPTDialog(this.odooEditor.document.getSelection()?.isCollapsed ? 'prompt' : 'alternatives');
                    break;
                }
            }
        };
        if (!options.snippets) {
            $toolbar.find('#justify, #media-insert').remove();
        }
        $toolbar.find('#image-fullscreen').click(() => {
            if (!this.lastMediaClicked?.src) {
                return;
            }
            this.showImageFullscreen(this.lastMediaClicked.src);
    })
        $toolbar.find('#media-insert, #media-replace, #media-description').click(openTools);
        $toolbar.find('#create-link').click(openTools);
        $toolbar.find('#open-chatgpt').click(openTools);
        $toolbar.find('#image-shape div, #fa-spin').click(e => {
            if (!this.lastMediaClicked) {
                return;
            }
            this.lastMediaClicked.classList.toggle(e.target.id);
            e.target.classList.toggle('active', $(this.lastMediaClicked).hasClass(e.target.id));
        });
        const $imageWidthButtons = $toolbar.find('#image-width div');
        $imageWidthButtons.click(e => {
            if (!this.lastMediaClicked) {
                return;
            }
            this.lastMediaClicked.style.width = e.target.id;
            for (const button of $imageWidthButtons) {
                button.classList.toggle('active', this.lastMediaClicked.style.width === button.id);
            }
        });
        $toolbar.find('#image-padding .dropdown-item').click(e => {
            if (!this.lastMediaClicked) {
                return;
            }
            $(this.lastMediaClicked).removeClass((index, className) => (
                (className.match(/(^|\s)padding-\w+/g) || []).join(' ')
            )).addClass(e.target.dataset.class);
        });
        $toolbar.on('mousedown', e => {
            const justifyBtn = e.target.closest('#justify div.btn');
            if (!justifyBtn || !this.lastMediaClicked) {
                return;
            }
            e.originalEvent.stopImmediatePropagation();
            e.originalEvent.stopPropagation();
            e.originalEvent.preventDefault();
            const mode = justifyBtn.id.replace('justify', '').toLowerCase();
            const classes = mode === 'center' ? ['d-block', 'mx-auto'] : ['float-' + mode];
            const doAdd = classes.some(className => !this.lastMediaClicked.classList.contains(className));
            this.lastMediaClicked.classList.remove('float-start', 'float-end');
            if (this.lastMediaClicked.classList.contains('mx-auto')) {
                this.lastMediaClicked.classList.remove('d-block', 'mx-auto');
            }
            if (doAdd) {
                this.lastMediaClicked.classList.add(...classes);
            }
            this._updateMediaJustifyButton(justifyBtn.id);
        });
        $toolbar.find('#image-crop').click(() => this._showImageCrop());
        $toolbar.find('#image-transform').click(e => {
            const sel = document.getSelection();
            sel.removeAllRanges();
            if (!this.lastMediaClicked) {
                return;
            }
            const $image = $(this.lastMediaClicked);
            if ($image.data('transfo-destroy')) {
                $image.removeData('transfo-destroy');
                return;
            }
            $image.transfo({document: this.odooEditor.document});
            const destroyTransfo = () => {
                $image.transfo('destroy');
                $(this.odooEditor.document).off('mousedown', mousedown).off('mouseup', mouseup);
                this.odooEditor.document.removeEventListener('keydown', keydown);
            }
            const mouseup = () => {
                $('#image-transform').toggleClass('active', $image.is('[style*="transform"]'));
            };
            $(this.odooEditor.document).on('mouseup', mouseup);
            const mousedown = mousedownEvent => {
                if (!$(mousedownEvent.target).closest('.transfo-container').length) {
                    destroyTransfo();
                }
                if ($(mousedownEvent.target).closest('#image-transform').length) {
                    $image.data('transfo-destroy', true).attr('style', ($image.attr('style') || '').replace(/[^;]*transform[\w:]*;?/g, ''));
                }
                $image.trigger('content_changed');
            };
            $(this.odooEditor.document).on('mousedown', mousedown);
            const keydown = keydownEvent => {
                if (keydownEvent.key === 'Escape') {
                    keydownEvent.stopImmediatePropagation();
                    destroyTransfo();
                }
            };
            this.odooEditor.document.addEventListener('keydown', keydown);
        });
        $toolbar.find('#image-delete').click(e => {
            if (!this.lastMediaClicked) {
                return;
            }
            $(this.lastMediaClicked).remove();
            this.lastMediaClicked = undefined;
            this.odooEditor.toolbarHide();
        });
        $toolbar.find('#fa-resize div').click(e => {
            if (!this.lastMediaClicked) {
                return;
            }
            const $target = $(this.lastMediaClicked);
            const sValue = e.target.dataset.value;
            $target.attr('class', $target.attr('class').replace(/\s*fa-[0-9]+x/g, ''));
            if (+sValue > 1) {
                $target.addClass('fa-' + sValue + 'x');
            }
            this._updateFaResizeButtons();
        });
        if (!options.snippets) {
            // Scroll event does not bubble.
            document.addEventListener('scroll', this._onScroll, true);
        }
    }

    _showImageCrop() {
        if (!this.lastMediaClicked) {
            return;
        }
        this.imageCropProps.media = this.lastMediaClicked;
        this.imageCropProps.showCount++;
        this.odooEditor.toolbarHide();
        $(this.lastMediaClicked).on('image_cropper_destroyed', () => this.odooEditor.toolbarShow());
    }
    /**
     * @private
     * @param {jQuery} $
     * @param {String} colorType 'text' or 'background'
     * @returns {String} color
     */
    _getSelectedColor($, colorType) {
        const selection = this.odooEditor.document.getSelection();
        if (!selection) return;
        const range = selection.rangeCount && selection.getRangeAt(0);
        const targetNode = range && range.startContainer;
        const targetElement = targetNode && targetNode.nodeType === Node.ELEMENT_NODE
            ? targetNode
            : targetNode && targetNode.parentNode;
        const backgroundImage = $(targetElement).css('background-image');
        let backgroundGradient = false;
        if (weUtils.isColorGradient(backgroundImage)) {
            const textGradient = targetElement.classList.contains('text-gradient');
            if (colorType === "text" && textGradient || colorType !== "text" && !textGradient) {
                backgroundGradient = backgroundImage;
            }
        }
        return backgroundGradient || $(targetElement).css(colorType === "text" ? 'color' : 'backgroundColor');
    }
    onColorpaletteDropdownHide(ev) {
        return !(ev.clickEvent && ev.clickEvent.__isColorpickerClick);
    }
    onColorpaletteDropdownShow(colorType) {
        const selectedColor = this._getSelectedColor($, colorType);
        this.colorPalettesProps[colorType].resetTabCount++;
        this.colorPalettesProps[colorType].selectedColor = selectedColor;

        const selection = this.odooEditor.document.getSelection();
        const range = selection.rangeCount && selection.getRangeAt(0);
        this.hadNonCollapsedSelectionBeforeColorpicker = range && !selection.isCollapsed;

        // The color_leave event will revert the mutations with
        // `historyRevertCurrentStep`. We must stash the current
        // mutations to prevent them from being reverted.
        this.odooEditor.historyStash();
    }
    getColorPaletteTabChangeHandler(colorType) {
        return (selectedTab) => {
            this.colorPalettesProps[colorType].selectedTab = selectedTab;
        }
    }
    _processAndApplyColor(colorType, color, previewMode) {
        if (color && !isCSSColor(color) && !weUtils.isColorGradient(color)) {
            color = (colorType === "text" ? 'text-' : 'bg-') + color;
        }
        const selectedTds = this.odooEditor.document.querySelectorAll('td.o_selected_td');
        const applyTransparency =
            color.startsWith('#') && // Check for hex color.
            !selectedTds.length && // Do not apply to table cells.
            colorType === 'background' && // Only apply on bg color.
            // Check if color is coming from theme-colors tab.
            this.colorPalettesProps.background.selectedTab === 'theme-colors';
        // Apply default transparency to the selected common color to make
        // text highlighting more usable between light and dark modes.
        if (applyTransparency) {
            const HEX_OPACITY = '99';
            color = color.concat(HEX_OPACITY);
        }
        let coloredElements = this.odooEditor.execCommand('applyColor', color, colorType === 'text' ? 'color' : 'backgroundColor', this.lastMediaClicked);
        // Some nodes returned by applyColor can be removed of the document by the sanitization in historyStep
        coloredElements = coloredElements.filter(element => this.odooEditor.document.contains(element));

        const coloredTds = coloredElements && coloredElements.length && Array.isArray(coloredElements) && coloredElements.filter(coloredElement => coloredElement.classList.contains('o_selected_td'));
        if (coloredTds.length) {
            const propName = colorType === 'text' ? 'color' : 'background-color';
            for (const td of coloredTds) {
                // Make it important so it has priority over selection color.
                td.style.setProperty(propName, td.style[propName], previewMode ? 'important' : '');
            }
        } else if (!this.lastMediaClicked && coloredElements && coloredElements.length && Array.isArray(coloredElements)) {
            // Ensure the selection in the fonts tags, otherwise an undetermined
            // race condition could generate a wrong selection later.
            const first = coloredElements[0];
            const last = coloredElements[coloredElements.length - 1];

            const sel = this.odooEditor.document.getSelection();
            sel.removeAllRanges();
            const range = new Range();
            range.setStart(first, 0);
            range.setEnd(...endPos(last));
            sel.addRange(getDeepRange(this.odooEditor.editable, { range }));
        }

        const hexColor = this._colorToHex(color);
        this.odooEditor.updateColorpickerLabels({
            [colorType === 'text' ? 'text' : 'hiliteColor']: hexColor,
        });
    }
    _colorToHex(color) {
        if (color.startsWith('#')) {
            return color;
        } else if (weUtils.isColorGradient(color)) {
            // return gradient the way it is: updateColorpickerLabels will handle it
            return color;
        } else {
            let rgbColor;
            if (color.startsWith('rgb')) {
                rgbColor = color;
            } else {
                const $font = $(`<font class="${color}"/>`);
                $(document.body).append($font);
                const propertyName = color.startsWith('text') ? 'color' : 'backgroundColor';
                rgbColor = $font.css(propertyName);
                $font.remove();
            }
            return rgbToHex(rgbColor);
        }
    }
    /**
     * Handle custom keyboard shortcuts.
     */
    _handleShortcuts(e) {
        // Open the link tool when CTRL+K is pressed.
        if (this.options.bindLinkTool && e && e.key === 'k' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            this.openLinkToolsFromSelection();
        }
        // Override selectAll (CTRL+A) to restrict it to the editable zone / current snippet and prevent traceback.
        if (e && e.key === 'a' && (e.ctrlKey || e.metaKey)) {
            e.preventDefault();
            const selection = this.odooEditor.document.getSelection();
            const containerSelector = '#wrap>*, .oe_structure>*, [contenteditable]';
            const container =
                (selection &&
                    closestElement(selection.anchorNode, containerSelector)) ||
                // In case a suitable container could not be found then the
                // selection is restricted inside the editable area.
                this.$editable.find(containerSelector)[0];
            if (container) {
                const range = document.createRange();
                range.selectNodeContents(container);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        }
    }
    /**
     * Update any editor UI that is not handled by the editor itself.
     */
    _updateEditorUI(e) {
        let selection = this.odooEditor.document.getSelection();
        if (!selection) return;
        const anchorNode = selection.anchorNode;
        if (isProtected(anchorNode)) {
            return;
        }

        this.odooEditor.automaticStepSkipStack();
        // We need to use the editor's window so the tooltip displays in its
        // document even if it's in an iframe.
        const editorWindow = this.odooEditor.document.defaultView;
        const $target = e ? editorWindow.$(e.target) : editorWindow.$();
        // Restore paragraph dropdown button's default ID.
        this.toolbarEl.querySelector('#mediaParagraphDropdownButton')?.setAttribute('id', 'paragraphDropdownButton');
        // Only show the media tools in the toolbar if the current selected
        // snippet is a media.
        const isInMedia = $target.is(mediaSelector) && !$target.parent().hasClass('o_stars') && e.target &&
            (e.target.isContentEditable || (e.target.parentElement && e.target.parentElement.isContentEditable));
        this.toolbarEl.classList.toggle('oe-media', isInMedia);

        for (const el of this.toolbarEl.querySelectorAll([
            '#image-preview',
            '#image-shape',
            '#image-width',
            '#image-padding',
            '#image-edit',
            '#media-replace',
            ].join(','))) {
            el.classList.toggle('d-none', !isInMedia);
        }
        // The image replace button is in the image options when the sidebar
        // exists.
        if (this.snippetsMenu && !this.snippetsMenu.folded && $target.is('img')) {
            this.toolbarEl.querySelector('#media-replace')?.classList.toggle('d-none', true);
        }
        // Only show the image-transform, image-crop and media-description
        // buttons if the current selected snippet is an image.
        for (const el of this.toolbarEl.querySelectorAll([
            '#image-transform',
            '#image-crop',
            '#media-description',
            ].join(','))) {
            el.classList.toggle('d-none', !isInMedia || !$target.is('img'));
        }
        this.lastMediaClicked = isInMedia && e.target;
        this.lastElement = $target[0];
        // Hide the irrelevant text buttons for media.
        for (const el of this.toolbarEl.querySelectorAll([
            '#style',
            '#decoration',
            '#font-size',
            '#justifyFull',
            '#list',
            '#colorInputButtonGroup',
            '#media-insert', // "Insert media" should be replaced with "Replace media".
            '#chatgpt', // Chatgpt should be removed when media is in selection.
        ].join(','))){
            el.classList.toggle('d-none', isInMedia);
        }
        // Some icons are relevant for icons, that aren't for other media.
        for (const el of this.toolbarEl.querySelectorAll('#colorInputButtonGroup')) {
            el.classList.toggle('d-none', isInMedia && !$target.is('.fa'));
        }
        for (const el of this.toolbarEl.querySelectorAll('.only_fa')) {
            el.classList.toggle('d-none', !isInMedia || !$target.is('.fa'));
        }
        // Hide unsuitable buttons for icon
        if ($target.is('.fa')) {
            for (const el of this.toolbarEl.querySelectorAll([
                '#image-shape',
                '#image-width',
                '#image-edit',
            ].join(','))) {
                el.classList.toggle('d-none', true);
            }
        }
        // Toggle the toolbar arrow.
        this.toolbarEl.classList.toggle('noarrow', isInMedia);
        // Unselect all media.
        this.$editable.find('.o_we_selected_image').removeClass('o_we_selected_image');
        if (isInMedia) {
            this.odooEditor.automaticStepSkipStack();
            // Select the media in the DOM.
            const selection = this.odooEditor.document.getSelection();
            const range = this.odooEditor.document.createRange();
            range.selectNode(this.lastMediaClicked);
            selection.removeAllRanges();
            selection.addRange(range);
            // Toggle the 'active' class on the active image tool buttons.
            for (const button of this.toolbarEl.querySelectorAll('#image-shape div, #fa-spin')) {
                button.classList.toggle('active', $(e.target).hasClass(button.id));
            }
            for (const button of this.toolbarEl.querySelectorAll('#image-width div')) {
                button.classList.toggle('active', e.target.style.width === button.id);
            }
            this._updateMediaJustifyButton();
            this._updateFaResizeButtons();
        }
        if (isInMedia && !this.options.onDblClickEditableMedia) {
            // Handle the media/link's tooltip.
            this.showTooltip = true;
            this.tooltipTimeouts.push(setTimeout(() => {
                // Do not show tooltip on double-click and if there is already one
                if (!this.showTooltip || $target.attr('title') !== undefined) {
                    return;
                }
                // Tooltips need to be cleared before leaving the editor.
                this.saving_mutex.exec(() => {
                    const removeTooltip = this.popover.add(e.target, Tooltip, { tooltip: _t('Double-click to edit') });
                    this.tooltipTimeouts.push(setTimeout(() => removeTooltip(), 800));
                });
            }, 400));
        }
        // Toolbar might have changed size, update its position.
        this.odooEditor.updateToolbarPosition();
        // Update color of already opened colorpickers.
        setTimeout(() => {
            for (const colorType in this.colorPalettesProps) {
                const selectedColor = this._getSelectedColor($, colorType);
                if (selectedColor) {
                    // If the palette was already opened (e.g. modifying a gradient), the new DOM state
                    // must be reflected in the palette, but the tab selection must not be impacted.
                    this.colorPalettesProps[colorType].selectedColor = selectedColor;
                }
            }
        });
    }
    _updateMediaJustifyButton(commandState) {
        if (!this.lastMediaClicked) {
            return;
        }
        const $paragraphDropdownButton = $(this.toolbarEl).find('#paragraphDropdownButton, #mediaParagraphDropdownButton');
        // Change the ID to prevent OdooEditor from controlling it as this is
        // custom behavior for media.
        $paragraphDropdownButton.attr('id', 'mediaParagraphDropdownButton');
        let resetAlignment = true;
        if (!commandState) {
            const justifyMapping = [
                ['float-start', 'justifyLeft'],
                ['mx-auto', 'justifyCenter'],
                ['float-end', 'justifyRight'],
            ];
            commandState = (justifyMapping.find(pair => (
                this.lastMediaClicked.classList.contains(pair[0]))
            ) || [])[1];
            resetAlignment = !commandState;
        }
        let newClass;
        if (commandState) {
            const direction = commandState.replace('justify', '').toLowerCase();
            newClass = `fa-align-${direction === 'full' ? 'justify' : direction}`;
            resetAlignment = !['float-start', 'mx-auto', 'float-end'].some(className => (
                this.lastMediaClicked.classList.contains(className)
            ));
        }
        for (const button of this.toolbarEl.querySelectorAll('#justify div.btn')) {
            button.classList.toggle('active', !resetAlignment && button.id === commandState);
        }
        $paragraphDropdownButton.removeClass((index, className) => (
            (className.match(/(^|\s)fa-align-\w+/g) || []).join(' ')
        ));
        if (commandState && !resetAlignment) {
            $paragraphDropdownButton.addClass(newClass);
        } else {
            // Ensure we always display an icon in the align toolbar button.
            $paragraphDropdownButton.addClass('fa-align-justify');
        }
    }
    _updateFaResizeButtons() {
        if (!this.lastMediaClicked) {
            return;
        }
        const match = this.lastMediaClicked.className.match(/\s*fa-([0-9]+)x/);
        const value = match && match[1] ? match[1] : '1';
        for (const button of this.toolbarEl.querySelectorAll('#fa-resize div')) {
            button.classList.toggle('active', button.dataset.value === value);
        }
    }
    _getEditorOptions(options) {
        const finalOptions = {...this.defaultOptions, ...options};
        // autohideToolbar is true by default (false by default if navbar present).
        finalOptions.autohideToolbar = typeof finalOptions.autohideToolbar === 'boolean'
            ? finalOptions.autohideToolbar
            : !finalOptions.snippets;
        if (finalOptions.inlineStyle) {
            finalOptions.dropImageAsAttachment = false;
        }

        return finalOptions;
    }
    _getBannerCommand(title, alertClass, iconClass, description, priority) {
        return {
            category: _t('Banners'),
            name: title,
            priority: priority,
            description: description,
            fontawesome: iconClass,
            isDisabled: () => isSelectionInSelectors('.o_editor_banner') || !this.odooEditor.isSelectionInBlockRoot(),
            callback: () => {
                const bannerElement = parseHTML(this.odooEditor.document, `
                    <div class="o_editor_banner o_not_editable lh-1 d-flex align-items-center alert alert-${alertClass} pb-0 pt-3" role="status" data-oe-protected="true">
                        <i class="fs-4 fa ${iconClass} mb-3" aria-label="${_t(title)}"></i>
                        <div class="w-100 px-3" data-oe-protected="false">
                            <p><br></p>
                        </div>
                    </div>
                `).childNodes[0];
                this.odooEditor.execCommand('insert', bannerElement);
                this.odooEditor.activateContenteditable();
                setSelection(bannerElement.querySelector('.o_editor_banner > div > p'), 0);
            },
        }
    }
    _insertSnippetMenu() {
        return this.snippetsMenu.insertBefore(this.$el);
    }
    /**
     * If the element holds a translation, saves it. Otherwise, fallback to the
     * standard saving but with the lang kept.
     *
     * @override
     */
    _saveTranslationElement($el, context, withLang = true) {
        if ($el.data('oe-translation-initial-sha')) {
            const $els = $el;
            const translations = {};
            translations[context.lang] = Object.assign({}, ...$els.toArray().map(
                (x) => ({
                    [$(x).data('oe-translation-initial-sha')]: this._getEscapedElement($(x)).html()
                })
            ));
            return this.orm.call(
                $els.data('oe-model'),
                'update_field_translations_sha',
                [
                    [+$els.data('oe-id')],
                    $els.data('oe-field'),
                    translations,
                ], { context });
        } else {
            var viewID = $el.data('oe-id');
            if (!viewID) {
                return Promise.resolve();
            }

            return this.orm.call(
                'ir.ui.view',
                'save',
                [
                    viewID,
                    this._getEscapedElement($el).prop('outerHTML'),
                    !$el.data('oe-expression') && $el.data('oe-xpath') || null, // Note: hacky way to get the oe-xpath only if not a t-field
                ], { context }
            );
        }
    }
    _getPowerboxOptions() {
        const editorOptions = this.options;
        const categories = [{ name: _t('Banners'), priority: 65 },];
        const commands = [
            this._getBannerCommand(_t('Banner Info'), 'info', 'fa-info-circle', _t('Insert an info banner'), 24),
            this._getBannerCommand(_t('Banner Success'), 'success', 'fa-check-circle', _t('Insert a success banner'), 23),
            this._getBannerCommand(_t('Banner Warning'), 'warning', 'fa-exclamation-triangle', _t('Insert a warning banner'), 22),
            this._getBannerCommand(_t('Banner Danger'), 'danger', 'fa-exclamation-circle', _t('Insert a danger banner'), 21),
            {
                category: _t('Structure'),
                name: _t('Quote'),
                priority: 30,
                description: _t('Add a blockquote section'),
                fontawesome: 'fa-quote-right',
                isDisabled: () => !this.odooEditor.isSelectionInBlockRoot(),
                callback: () => {
                    this.odooEditor.execCommand('setTag', 'blockquote');
                },
            },
            {
                category: _t('Structure'),
                name: _t('Code'),
                priority: 20,
                description: _t('Add a code section'),
                fontawesome: 'fa-code',
                isDisabled: () => !this.odooEditor.isSelectionInBlockRoot(),
                callback: () => {
                    this.odooEditor.execCommand('setTag', 'pre');
                },
            },
            {
                category: _t('Basic blocks'),
                name: _t('Signature'),
                description: _t('Insert your signature'),
                fontawesome: 'fa-pencil-square-o',
                isDisabled: () => !this.odooEditor.isSelectionInBlockRoot(),
                callback: async () => {
                    const uid = Array.isArray(session.user_id) ? session.user_id[0] : session.user_id;
                    const [user] = await this.orm.read(
                        'res.users',
                        [uid],
                        ['signature'],
                    );
                    if (user && user.signature) {
                        this.odooEditor.execCommand('insert', parseHTML(this.odooEditor.document, user.signature));
                    }
                },
            },
            {
                category: _t('AI Tools'),
                name: _t('ChatGPT'),
                description: _t('Generate or transform content with AI.'),
                fontawesome: 'fa-magic',
                priority: 1,
                isDisabled: () => !this.odooEditor.isSelectionInBlockRoot(),
                callback: async () => this.openChatGPTDialog(),
            },
        ];
        if (!editorOptions.inlineStyle) {
            commands.push(
                {
                    category: _t('Structure'),
                    name: _t('2 columns'),
                    priority: 13,
                    description: _t('Convert into 2 columns'),
                    fontawesome: 'fa-columns',
                    callback: () => this.odooEditor.execCommand('columnize', 2, editorOptions.insertParagraphAfterColumns),
                    isDisabled: () => {
                        if (!this.odooEditor.isSelectionInBlockRoot()) {
                            return true;
                        }
                        const anchor = this.odooEditor.document.getSelection().anchorNode;
                        const row = closestElement(anchor, '.o_text_columns .row');
                        return row && row.childElementCount === 2;
                    },
                },
                {
                    category: _t('Structure'),
                    name: _t('3 columns'),
                    priority: 12,
                    description: _t('Convert into 3 columns'),
                    fontawesome: 'fa-columns',
                    callback: () => this.odooEditor.execCommand('columnize', 3, editorOptions.insertParagraphAfterColumns),
                    isDisabled: () => {
                        if (!this.odooEditor.isSelectionInBlockRoot()) {
                            return true;
                        }
                        const anchor = this.odooEditor.document.getSelection().anchorNode;
                        const row = closestElement(anchor, '.o_text_columns .row');
                        return row && row.childElementCount === 3;
                    },
                },
                {
                    category: _t('Structure'),
                    name: _t('4 columns'),
                    priority: 11,
                    description: _t('Convert into 4 columns'),
                    fontawesome: 'fa-columns',
                    callback: () => this.odooEditor.execCommand('columnize', 4, editorOptions.insertParagraphAfterColumns),
                    isDisabled: () => {
                        if (!this.odooEditor.isSelectionInBlockRoot()) {
                            return true;
                        }
                        const anchor = this.odooEditor.document.getSelection().anchorNode;
                        const row = closestElement(anchor, '.o_text_columns .row');
                        return row && row.childElementCount === 4;
                    },
                },
                {
                    category: _t('Structure'),
                    name: _t('Remove columns'),
                    priority: 10,
                    description: _t('Back to one column'),
                    fontawesome: 'fa-columns',
                    callback: () => this.odooEditor.execCommand('columnize', 0),
                    isDisabled: () => {
                        if (!this.odooEditor.isSelectionInBlockRoot()) {
                            return true;
                        }
                        const anchor = this.odooEditor.document.getSelection().anchorNode;
                        const row = closestElement(anchor, '.o_text_columns .row');
                        return !row;
                    },
                },
                {
                    category: _t('Widgets'),
                    name: _t('Emoji'),
                    priority: 70,
                    description: _t('Add an emoji'),
                    fontawesome: 'fa-smile-o',
                    callback: () => {
                        this.showEmojiPicker();
                    },
                },
            );
        }
        if (editorOptions.allowCommandLink) {
            categories.push({ name: _t('Navigation'), priority: 40 });
            commands.push(
                {
                    category: _t('Navigation'),
                    name: _t('Link'),
                    priority: 40,
                    description: _t('Add a link'),
                    fontawesome: 'fa-link',
                    callback: () => {
                        this.toggleLinkTools({forceDialog: true});
                    },
                },
                {
                    category: _t('Navigation'),
                    name: _t('Button'),
                    priority: 30,
                    description: _t('Add a button'),
                    fontawesome: 'fa-link',
                    callback: () => {
                        this.toggleLinkTools({forceDialog: true});
                        // Force the button style after the link modal is open.
                        setTimeout(() => {
                            $(".o_link_dialog .link-style[value=primary]").click();
                        }, 150);
                    },
                },
            );
        }
        if (editorOptions.allowCommandImage || editorOptions.allowCommandVideo) {
            categories.push({ name: _t('Media'), priority: 50 });
        }
        if (editorOptions.allowCommandImage) {
            commands.push({
                category: _t('Media'),
                name: _t('Image'),
                priority: 40,
                description: _t('Insert an image'),
                fontawesome: 'fa-file-image-o',
                callback: () => {
                    this.openMediaDialog();
                },
            });
        }
        if (editorOptions.allowCommandVideo) {
            commands.push({
                category: _t('Media'),
                name: _t('Video'),
                priority: 30,
                description: _t('Insert a video'),
                fontawesome: 'fa-file-video-o',
                callback: () => {
                    this.openMediaDialog({noVideos: false, noImages: true, noIcons: true, noDocuments: true});
                },
            });
        }
        if (editorOptions.powerboxCategories) {
            categories.push(...editorOptions.powerboxCategories);
        }
        if (editorOptions.powerboxCommands) {
            commands.push(...editorOptions.powerboxCommands);
        }
        return {commands, categories};
    }

    /**
     * Returns the editable areas on the page.
     *
     * @returns {jQuery}
     */
    editable() {
        return $('#wrapwrap [data-oe-model]')
            .not('.o_not_editable')
            .filter(function () {
                return !$(this).closest('.o_not_editable').length;
            })
            .not('link, script')
            .not('[data-oe-readonly]')
            .not('img[data-oe-field="arch"], br[data-oe-field="arch"], input[data-oe-field="arch"]')
            .not('.oe_snippet_editor')
            .add('.o_editable');
    }

    /**
     * Searches all the dirty element on the page or given element and saves them one by one. If
     * one cannot be saved, this notifies it to the user and restarts rte
     * edition.
     *
     * @param {Object} [context] - the context to use for saving rpc, default to
     *                           the editor context found on the page
     * @param {Object} [element] - Specific given element to save
     * @return {Promise} rejected if the save cannot be done
     */
    _saveViewBlocks(context, element = false) {
        // TODO should be review to probably not search in the whole body,
        // iframe or not.
        // If the element is given, then search within not from the document.
        const $ = element ? getJqueryFromDocument(element) : getJqueryFromDocument(this.$editable[0].ownerDocument);
        const $allBlocks = $((this.options || {}).savableSelector).filter(
            this.options.enableTranslation
            ? '.o_dirty, .o_delay_translation'
            : '.o_dirty');

        const $dirty = $('.o_dirty');
        $dirty
            .removeAttr('contentEditable')
            .removeClass('o_dirty oe_carlos_danger o_is_inline_editable');

        const $delay_translation = $('.o_delay_translation');
        $delay_translation.removeClass('o_delay_translation');

        $('.o_editable')
            .removeClass('o_editable o_is_inline_editable o_editable_date_field_linked o_editable_date_field_format_changed');

        const saveElementFuncName = this.options.enableTranslation
            ? '_saveTranslationElement'
            : '_saveElement';

        // Group elements to save if possible.
        const groupedElements = groupBy($allBlocks.toArray(), el => {
            const model = el.dataset.oeModel;
            const field = el.dataset.oeField;

            // There are elements which have no linked model as something
            // special is to be done "to save them" (potential override to
            // `_saveElement` which is expected to be called for each unique
            // dirty element). In that case, do not group those elements.
            if (!model) {
                return uniqueId("special-element-to-save-");
            }

            // Do not group elements which are parts of views, unless we are
            // in translate mode.
            if (!this.options.enableTranslation
                    && (model === 'ir.ui.view' && field === 'arch')) {
                return uniqueId("view-part-to-save-");
            }

            // Otherwise, group elements which are from the same field of the
            // same record (`_saveElement` will only consider the first one and
            // `_saveTranslationElement` can handle the set if it makes sense).
            return `${model}::${el.dataset.oeId}::${field}`;
        });
        const proms = Object.values(groupedElements).map(els => {
            const $els = $(els);

            $els.find('[class]').filter(function () {
                if (!this.getAttribute('class').match(/\S/)) {
                    this.removeAttribute('class');
                }
            });

            // TODO: Add a queue with concurrency limit in webclient
            return new Promise((resolve, reject) => {
                return this.saving_mutex.exec(() => {
                    return this[saveElementFuncName]($els, context || this.options.context)
                    .then(function () {
                        $els.removeClass('o_dirty');
                        resolve();
                    })
                    .catch(error => {
                        // because ckeditor regenerates all the dom, we can't just
                        // setup the popover here as everything will be destroyed by
                        // the DOM regeneration. Add markings instead, and returns a
                        // new rejection with all relevant info
                        var id = uniqueId("carlos_danger_");
                        $els.addClass('o_dirty o_editable oe_carlos_danger ' + id);
                        $('.o_editable.' + id)
                            .removeClass(id)
                            .popover({
                                trigger: 'hover',
                                content: error.data?.message || '',
                                placement: 'auto',
                            })
                            .popover('show');
                        reject();
                    });
                });
            });
        });
        return Promise.all(proms).then(function () {
            window.onbeforeunload = null;
        });
    }
    // TODO unused => remove or reuse as it should be
    _attachTooltips() {
        $(document.body)
            .tooltip({
                selector: '[data-oe-readonly]',
                container: 'body',
                trigger: 'hover',
                delay: {'show': 1000, 'hide': 100},
                placement: 'bottom',
                title: _t("Readonly field")
            })
            .on('click', function () {
                $(this).tooltip('hide');
            });
    }
    /**
     * Gets jQuery cloned element with internal text nodes escaped for XML
     * storage.
     *
     * @private
     * @param {jQuery} $el
     * @return {jQuery}
     */
    _getEscapedElement($el) {
        var escaped_el = $el.clone();
        var to_escape = escaped_el.find('*').addBack();
        to_escape = to_escape.not(to_escape.filter('object,iframe,script,style,[data-oe-model][data-oe-model!="ir.ui.view"]').find('*').addBack());
        to_escape.contents().each(function () {
            if (this.nodeType === 3) {
                this.nodeValue = $('<div />').text(this.nodeValue).html();
            }
        });
        return escaped_el;
    }
    /**
     * Saves one (dirty) element of the page.
     *
     * @private
     * @param {jQuery} $el - the element to save
     * @param {Object} context - the context to use for the saving rpc
     */
    async _saveElement($el, context) {
        var viewID = $el.data('oe-id');
        if (!viewID) {
            return Promise.resolve();
        }

        // remove ZeroWidthSpace from odoo field value
        // ZeroWidthSpace may be present from OdooEditor edition process
        let escapedHtml = this._getEscapedElement($el).prop('outerHTML');

        const result = this.orm.call('ir.ui.view', 'save', [
            viewID,
            escapedHtml,
            !$el.data('oe-expression') && $el.data('oe-xpath') || null
        ], {
            context: {
                ...context,
                // TODO: Restore the delay translation feature once it's fixed,
                //       see commit msg for more info.
                delay_translations: false,
            },
        });
        return result;
    }

    /**
     * Reloads the page in non-editable mode, with the right scrolling.
     *
     * @private
     * @returns {Promise} (never resolved, the page is reloading anyway)
     */
    _reload() {
        window.location.hash = 'scrollTop=' + window.document.body.scrollTop;
        if (window.location.search.indexOf('enable_editor') >= 0) {
            window.location.href = window.location.href.replace(/&?enable_editor(=[^&]*)?/g, '');
        } else {
            window.location.reload(true);
        }
        return new Promise(function () {});
    }
    _onAttachmentChange(attachment) {
        if (this.options.onAttachmentChange) {
            this.options.onAttachmentChange(attachment);
        }
    }
    _onDblClickEditableMedia(ev) {
        const $el = $(ev.currentTarget);
        $el.selectElement();
        if (!$el.parent().hasClass('o_stars')) {
            // Waiting for all the options to be initialized before
            // opening the media dialog and only if the media has not
            // been deleted in the meantime.
            this.waitForEmptyMutexAction().then(() => {
                if ($el[0].parentElement) {
                    this.openMediaDialog({ node: $el[0] });
                }
            });
        }
    }
    _onSelectionChange() {
        if (this.odooEditor.autohideToolbar && this.linkPopover) {
            const selectionInLink = getInSelection(this.odooEditor.document, 'a') === this.linkPopover.target;
            const isVisible = this.linkPopover.el.offsetParent;
            if (isVisible && !selectionInLink) {
                this.linkPopover.hide();
            }
        }
    }
    _onDocumentMousedown(e) {
        if (!e.target.classList.contains('o_editable_date_field_linked')) {
            this.$editable.find('.o_editable_date_field_linked').removeClass('o_editable_date_field_linked');
        }
        const closestDialog = e.target.closest('.o_dialog, .o_web_editor_dialog');
        if (
            e.target.closest('.oe-toolbar,.oe-powerbox-wrapper,.o_we_crop_widget') ||
            (closestDialog && closestDialog.querySelector('.o_select_media_dialog, .o_link_dialog'))
        ) {
            this._shouldDelayBlur = true;
        } else {
            if (this._pendingBlur && !e.target.closest('.o_wysiwyg_wrapper')) {
                this.options.onWysiwygBlur && this.options.onWysiwygBlur();
                this._pendingBlur = false;
            }
            this._shouldDelayBlur = false;
        }
    }
    _onBlur() {
        if (this._shouldDelayBlur) {
            this._pendingBlur = true;
        } else {
            this.options.onWysiwygBlur && this.options.onWysiwygBlur();
        }
    }
    _onScroll(ev) {
        if (ev.target.contains(this.$editable[0])) {
            this.scrollContainer = ev.target;
            this.odooEditor.updateToolbarPosition();
        }
    }
    _signalOffline() {
        this._isOnline = false;
    }
    async _signalOnline() {
        clearTimeout(this._offlineTimeout);
        this._offlineTimeout = undefined;

        if (this._isOnline || !navigator.onLine) {
            return;
        }
        this._isOnline = true;
        if (!this.ptp) return;

        // If it was disconnected to some peers, send the join signal again.
        this.ptp.notifyAllClients('ptp_join');
        // Send last step to all peers. If the peers cannot add the step, they
        // will ask for missing steps.
        this.ptp.notifyAllClients('oe_history_step', peek(this.odooEditor.historyGetSteps()), { transport: 'rtc' });
    }
    /**
     * Process missing steps received from a peer.
     *
     * @private
     * @param {Array<Object>|-1} missingSteps
     * @return {Promise<boolean>} true if missing steps have been processed
     */
    async _processMissingSteps(missingSteps) {
        // If missing steps === -1, it means that either:
        // - the step.clientId has a stale document
        // - the step.clientId has a snapshot and does not includes the step in
        //   its history
        // - if another share history id
        //   - because the step.clientId has reset from the server and
        //     step.clientId is not synced with this client
        //   - because the step.clientId is in a network partition
        if (missingSteps === -1 || !missingSteps.length) {
            return false;
        }
        this.ptp && this.odooEditor.onExternalHistorySteps(missingSteps);
        return true;
    }
    _showConflictDialog() {
        if (this._conflictDialogOpened) return;
        const content = markup(this.odooEditor.editable.cloneNode(true).outerHTML);
        this._conflictDialogOpened = true;
        this.env.services.dialog.add(ConflictDialog, {
            content,
            close: () => this._conflictDialogOpened = false,
        });
    }
    _getLastHistoryStepId(value) {
        const matchId = value.match(/data-last-history-steps="(?:[0-9]+,)*([0-9]+)"/);
        return matchId && matchId[1];
    }
    _generateClientId() {
        // No need for secure random number.
        return Math.floor(Math.random() * Math.pow(2, 52)).toString();
    }
    _getNewPtp() {
        const rpcMutex = new Mutex();
        const {collaborationChannel} = this.options;
        const modelName = collaborationChannel.collaborationModelName;
        const fieldName = collaborationChannel.collaborationFieldName;
        const resId = collaborationChannel.collaborationResId;

        // Wether or not the history has been sent or received at least
        // once.
        this._historySyncAtLeastOnce = false;

        return new PeerToPeer({
            peerConnectionConfig: { iceServers: this._iceServers },
            currentClientId: this._currentClientId,
            broadcastAll: (rpcData) => {
                return rpcMutex.exec(async () => {
                    return this._serviceRpc('/web_editor/bus_broadcast', {
                        model_name: modelName,
                        field_name: fieldName,
                        res_id: resId,
                        bus_data: rpcData,
                    });
                });
            },
            onRequest: {
                get_start_time: () => this._startCollaborationTime,
                get_client_name: async () => {
                    if (!this._userName) {
                        const [user] = await this.orm.read(
                            'res.users',
                            [session.uid],
                            ['name'],
                        );
                        this._userName = user.name;
                    }
                    return this._userName;
                },
                get_client_avatar: () => `${browser.location.origin}/web/image?model=res.users&field=avatar_128&id=${encodeURIComponent(session.uid)}`,
                get_missing_steps: (params) => this.odooEditor.historyGetMissingSteps(params.requestPayload),
                get_history_from_snapshot: () => this._getHistorySnapshot(),
                get_collaborative_selection: () => this.odooEditor.getCurrentCollaborativeSelection(),
                recover_document: (params) => {
                    const { serverDocumentId, fromStepId } = params.requestPayload;
                    if (!this.odooEditor.historyGetBranchIds().includes(serverDocumentId)) {
                        return;
                    }
                    return {
                        missingSteps: this.odooEditor.historyGetMissingSteps({ fromStepId }),
                        snapshot: this._getHistorySnapshot(),
                    };
                },
            },
            onNotification: async ({ fromClientId, notificationName, notificationPayload }) => {
                switch (notificationName) {
                    case 'ptp_remove':
                        this.odooEditor.multiselectionRemove(notificationPayload);
                        break;
                    case 'ptp_disconnect':
                        this.ptp.removeClient(fromClientId);
                        this.odooEditor.multiselectionRemove(fromClientId);
                        break;
                    case 'rtc_data_channel_open': {
                        fromClientId = notificationPayload.connectionClientId;
                        const remoteStartTime = await this.requestClient(fromClientId, 'get_start_time', undefined, { transport: 'rtc' });
                        if (remoteStartTime === REQUEST_ERROR) return;
                        this.ptp.clientsInfos[fromClientId].startTime = remoteStartTime;

                        if (!this._historySyncAtLeastOnce) {
                            const localClient = { id: this._currentClientId, startTime: this._startCollaborationTime };
                            const remoteClient = { id: fromClientId, startTime: remoteStartTime };
                            if (isClientFirst(localClient, remoteClient)) {
                                this._historySyncAtLeastOnce = true;
                                this._historySyncFinished = true;
                            } else {
                                this._resetCollabRequests();
                                const response = await this._resetFromClient(fromClientId, this._lastCollaborationResetId);
                                if (response === REQUEST_ERROR) {
                                    return;
                                }
                            }
                        } else {
                            // Make both send their last step to each other to
                            // ensure they are in sync.
                            this.ptp.notifyAllClients('oe_history_step', peek(this.odooEditor.historyGetSteps()), { transport: 'rtc' });
                            this._setCollaborativeSelection(fromClientId);
                        }

                        const getClientNamePromise = this.requestClient(
                            fromClientId, 'get_client_name', undefined, { transport: 'rtc' }
                        ).then((clientName) => {
                            if (clientName === REQUEST_ERROR) return;
                            this.ptp.clientsInfos[fromClientId].clientName = clientName;
                            this.odooEditor.multiselectionRefresh();
                        });
                        const getClientAvatar = this.requestClient(
                            fromClientId, 'get_client_avatar', undefined, { transport: 'rtc' }
                        ).then(clientAvatarUrl => {
                            if (clientAvatarUrl === REQUEST_ERROR) return;
                            this.ptp.clientsInfos[fromClientId].clientAvatarUrl = clientAvatarUrl;
                            this.odooEditor.multiselectionRefresh();
                        });
                        await Promise.all([getClientAvatar, getClientNamePromise]);
                        break;
                    }
                    case 'oe_history_step':
                        if (this._historySyncFinished) {
                            this.odooEditor.onExternalHistorySteps([notificationPayload]);
                        } else {
                            this._historyStepsBuffer.push(notificationPayload);
                        }
                        break;
                    case 'oe_history_set_selection': {
                        const client = this.ptp.clientsInfos[fromClientId];
                        if (!client) {
                            return;
                        }
                        const selection = notificationPayload;
                        selection.clientName = client.clientName;
                        selection.clientAvatarUrl = client.clientAvatarUrl;
                        this.odooEditor.onExternalMultiselectionUpdate(selection);
                        break;
                    }
                }
            }
        });
    }
    _getCollaborationClientAvatarUrl() {
        return `${browser.location.origin}/web/image?model=res.users&field=avatar_128&id=${encodeURIComponent(session.uid)}`
    }
    _stopPeerToPeer() {
        this._joiningPtp = false;
        this._ptpJoined = false;
        this._resetCollabRequests();
        this.ptp && this.ptp.stop();
    }
    _joinPeerToPeer() {
        this.$editable[0].removeEventListener('focus', this._joinPeerToPeer);
        if (this._peerToPeerLoading) {
            return this._peerToPeerLoading.then(async () => {
                this._joiningPtp = true;
                if (this._isDocumentStale) {
                    const success = await this._resetFromServerAndResyncWithClients();
                    if (!success) return;
                }
                this.ptp.notifyAllClients('ptp_join');
                this._joiningPtp = false;
                this._ptpJoined = true;
            });
        }
    }
    async _setCollaborativeSelection(fromClientId) {
        const remoteSelection = await this.requestClient(fromClientId, 'get_collaborative_selection', undefined, { transport: 'rtc' });
        if (remoteSelection === REQUEST_ERROR) return;
        if (remoteSelection) {
            this.odooEditor.onExternalMultiselectionUpdate(remoteSelection);
        }
    }
    /**
     * Get peer to peer clients.
     */
    _getPtpClients() {
        const clients = Object.entries(this.ptp.clientsInfos).map(([clientId, clientInfo]) => ({id: clientId, ...clientInfo}));
        return clients.sort((a, b) => isClientFirst(a, b) ? -1 : 1);
    }
    async _getCurrentRecord() {
        const [record] = await this.orm.read(
            this.options.collaborationChannel.collaborationModelName,
            [this.options.collaborationChannel.collaborationResId],
            [this.options.collaborationChannel.collaborationFieldName],
        );
        return record;
    }
    _isLastDocumentStale() {
        if (!this._serverLastStepId) {
            return false;
        }
        return !this.odooEditor.historyGetBranchIds().includes(this._serverLastStepId);
    }
    /**
     * Update the server document last step id and recover from a stale document
     * if this client does not have that step in its history.
     */
    _onServerLastIdUpdate(last_step_id) {
        this._serverLastStepId = last_step_id;
        // Check if the current document is stale.
        this._isDocumentStale = this._isLastDocumentStale();
        if (this._isDocumentStale && this._ptpJoined) {
            return this._recoverFromStaleDocument();
        } else if (this._isDocumentStale && this._joiningPtp) {
            // In case there is a stale document while a previous recovery is
            // ongoing.
            this._resetCollabRequests();
            this._joinPeerToPeer();
        }
    }
    /**
     * Try to recover from a stale document.
     *
     * The strategy is:
     *
     * 1.  Try to get a converging document from the other peers.
     *
     * 1.1 By recovery from missing steps: it is the best possible case of
     *     retrieval.
     *
     * 1.2 By recovery from snapshot: it reset the whole editor (destroying
     *     changes and selection made by the user).
     *
     * 2. Reset from the server:
     *    If the recovery from the other peers fails, reset from the server.
     *
     *    As we know we have a stale document, we need to reset it at least from
     *    the server. We shouldn't wait too long for peers to respond because
     *    the longer we wait for an unresponding peer, the longer a user can
     *    edit a stale document.
     *
     *    The peers timeout is set to PTP_MAX_RECOVERY_TIME.
     */
    async _recoverFromStaleDocument() {
        return new Promise((resolve) => {
            // 1. Try to recover a converging document from other peers.
            const resetCollabCount = this._lastCollaborationResetId;

            const allPeers = this._getPtpClients().map(client => client.id);

            if (allPeers.length === 0) {
                if (this._isDocumentStale) {
                    this._showConflictDialog();
                    resolve();
                    return this._resetFromServerAndResyncWithClients();
                }
            }

            let hasRetrievalBudgetTimeout = false;
            let snapshots = [];
            let nbPendingResponses = allPeers.length;

            const success = () => {
                resolve();
                clearTimeout(timeout);
            };

            for (const peerId of allPeers) {
                this.requestClient(
                    peerId,
                    'recover_document', {
                        serverDocumentId: this._serverLastStepId,
                        fromStepId: peek(this.odooEditor.historyGetBranchIds()),
                    },
                    { transport: 'rtc' }
                ).then((response) => {
                    nbPendingResponses--;
                    if (
                        response === REQUEST_ERROR ||
                        resetCollabCount !== this._lastCollaborationResetId ||
                        hasRetrievalBudgetTimeout ||
                        !response ||
                        !this._isDocumentStale
                    ) {
                        if (nbPendingResponses <= 0) {
                            processSnapshots();
                        }
                        return;
                    }
                    this._processMissingSteps(response.missingSteps);
                    this._isDocumentStale = this._isLastDocumentStale();
                    snapshots.push(response.snapshot);
                    if (nbPendingResponses < 1) {
                        processSnapshots();
                    }
                });
            }

            // Only process the snapshots after having received a response from all
            // the peers or after PTP_MAX_RECOVERY_TIME in order to try to recover
            // from missing steps.
            const processSnapshots = async () => {
                this._isDocumentStale = this._isLastDocumentStale();
                if (!this._isDocumentStale) {
                    return success();
                }
                if (snapshots[0]) {
                    this._showConflictDialog();
                }
                for (const snapshot of snapshots) {
                    this._applySnapshot(snapshot);
                    this._isDocumentStale = this._isLastDocumentStale();
                    // Prevent reseting from another snapshot if the document
                    // converge.
                    if (!this._isDocumentStale) {
                        return success();
                    }
                }

                // 2. If the document is still stale, try to recover from the server.
                if (this._isDocumentStale) {
                    this._showConflictDialog();
                    await this._resetFromServerAndResyncWithClients();
                }

                success();
            }

            // Wait PTP_MAX_RECOVERY_TIME to retrieve data from other peers to
            // avoid reseting from the server if possible.
            const timeout = setTimeout(() => {
                if (resetCollabCount !== this._lastCollaborationResetId) return;
                hasRetrievalBudgetTimeout = true;
                this._onRecoveryClientTimeout(processSnapshots);
            }, PTP_MAX_RECOVERY_TIME);
        });
    }
    /**
     * Callback for when the timeout PTP_MAX_RECOVERY_TIME fires.
     *
     * Used to be hooked in tests.
     *
     * @param {Function} processSnapshots The snapshot processing function.
     */
    async _onRecoveryClientTimeout(processSnapshots) {
        processSnapshots();
    }
    /**
     * Reset the document from the server and resync with the clients.
     */
    async _resetFromServerAndResyncWithClients() {
        let collaborationResetId = this._lastCollaborationResetId;
        const record = await this._getCurrentRecord();
        if (collaborationResetId !== this._lastCollaborationResetId) return;

        const content = record[this.options.collaborationChannel.collaborationFieldName];
        const lastHistoryId = content && this._getLastHistoryStepId(content);
        // If a change was made in the document while retrieving it, the
        // lastHistoryId will be different if the odoo bus did not have time to
        // notify the user.
        if (this._serverLastStepId !== lastHistoryId) {
            // todo: instrument it to ensure it never happens
            throw new Error('Concurency detected while recovering from a stale document. The last history id of the server is different from the history id received by the html_field_write event.');
        }

        this._isDocumentStale = false;
        this.resetValue(content);

        // After resetting from the server, try to resynchronise with a peer as
        // if it was the first time connecting to a peer in order to retrieve a
        // proper snapshot (e.g. This case could arise if we tried to recover
        // from a client but the timeout (PTP_MAX_RECOVERY_TIME) was reached
        // before receiving a response).
        this._historySyncAtLeastOnce = false;
        this._resetCollabRequests();
        collaborationResetId = this._lastCollaborationResetId;
        this._startCollaborationTime = new Date().getTime();
        await Promise.all(this._getPtpClients().map((client) => {
            // Reset from the fastest client. The first client to reset will set
            // this._historySyncAtLeastOnce to true canceling the other peers
            // resets.
            return this._resetFromClient(client.id, collaborationResetId);
        }));
        return true;
    }
    _resetCollabRequests() {
        this._lastCollaborationResetId++;
        // By aborting the current requests from ptp, we ensure that the ongoing
        // `Wysiwyg.requestClient` will return REQUEST_ERROR. Most requests that
        // calls `Wysiwyg.requestClient` might want to check if the response is
        // REQUEST_ERROR.
        this.ptp && this.ptp.abortCurrentRequests();
    }
    async _resetFromClient(fromClientId, resetCollabCount) {
        this._historySyncFinished = false;
        this._historyStepsBuffer = [];
        const snapshot = await this.requestClient(fromClientId, 'get_history_from_snapshot', undefined, { transport: 'rtc' });
        if (snapshot === REQUEST_ERROR) {
            return REQUEST_ERROR;
        }
        if (resetCollabCount !== this._lastCollaborationResetId) {
            return;
        }
        // Ensure that the history hasn't been synced by another client before
        // this `get_history_from_snapshot` finished.
        if (this._historySyncAtLeastOnce) {
            return;
        }
        const applied = this._applySnapshot(snapshot);
        if (!applied) {
            return;
        }
        this._historySyncFinished = true;
        // In case there are steps received in the meantime, process them.
        if (this._historyStepsBuffer.length) {
            this.odooEditor.onExternalHistorySteps(this._historyStepsBuffer);
            this._historyStepsBuffer = [];
        }
        this.options.onHistoryResetFromSteps();
        this._setCollaborativeSelection(fromClientId);
    }
    async requestClient(clientId, requestName, requestPayload, params) {
        return this.ptp.requestClient(clientId, requestName, requestPayload, params).catch((e) => {
            if (e instanceof RequestError) {
                return REQUEST_ERROR;
            } else {
                throw e;
            }
        });
    }
    /**
     * Reset the value and history of the editor.
     */
    async resetValue(value) {
        this.setValue(value);
        this.odooEditor.historyReset();
        this._historyShareId = Math.floor(Math.random() * Math.pow(2,52)).toString();
        this._serverLastStepId = value && this._getLastHistoryStepId(value);
        if (this._serverLastStepId) {
            this.odooEditor.historySetInitialId(this._serverLastStepId);
        }
    }
    /**
     * Reset the editor with a new value and potientially new options.
     */
    async resetEditor(value, options) {
        await this._peerToPeerLoading;
        this.$editable[0].removeEventListener('focus', this._joinPeerToPeer);
        if (options) {
            this.options = this._getEditorOptions(options);
        }
        const {collaborationChannel} = this.options;
        this._stopPeerToPeer();
        this._collaborationStopBus && this._collaborationStopBus();
        this._isDocumentStale = false;
        this._rulesCache = undefined; // Reset the cache of rules.
        // If there is no collaborationResId, the record has been deleted.
        if (!this._isCollaborationEnabled(this.options)) {
            this._currentClientId = undefined;
            this.resetValue(value);
            return;
        }
        this._currentClientId = this._generateClientId();
        this.odooEditor.collaborationSetClientId(this._currentClientId);
        this.resetValue(value);
        this.setupCollaboration(collaborationChannel);
        if (this.options.collaborativeTrigger === 'start') {
            this._joinPeerToPeer();
        } else if (this.options.collaborativeTrigger === 'focus') {
            // Wait until editor is focused to join the peer to peer network.
            this.$editable[0].addEventListener('focus', this._joinPeerToPeer);
        }

        await this._peerToPeerLoading;
    }
    _getHistorySnapshot() {
        return Object.assign(
            {},
            this.odooEditor.historyGetSnapshotSteps(),
            { historyShareId: this._historyShareId }
        );
    }
    _applySnapshot(snapshot) {
        const { steps, historyIds, historyShareId } = snapshot;
        // If there is no serverLastStepId, it means that we use a document
        // that is not versionned yet.
        const isStaleDocument = this._serverLastStepId && !historyIds.includes(this._serverLastStepId);
        if (isStaleDocument) {
            return;
        }
        this._historyShareId = historyShareId;
        this._historySyncAtLeastOnce = true;
        this.odooEditor.historyResetFromSteps(steps, historyIds);
        this.odooEditor.historyResetLatestComputedSelection();
        return true;
    }
    /**
     * Set `contenteditable` according to `.o_not_editable` and `.o_editable`.
     *
     * @param {Node} node
     */
    _onPostSanitize(node) {
        // _fixLinkMutatedElements check to be removed after the new link edge
        // solution is merged.
        if (node?.querySelectorAll && this.odooEditor && !this.odooEditor._fixLinkMutatedElements) {
            // TODO rethink o_editable as a content-editable marker without
            // breaking the o_editable behaviors (website, mass_mailing, ...)
            for (const element of node.querySelectorAll('.o_not_editable')) {
                if (element.isContentEditable !== false) {
                    element.contentEditable = false;
                }
            }
        }
    }
    _attachHistoryIds(editable = this.odooEditor.editable) {
        if (this.options.collaborative) {
            // clean existig 'data-last-history-steps' attributes
            editable.querySelectorAll('[data-last-history-steps]').forEach(
                el => el.removeAttribute('data-last-history-steps')
            );

            const historyIds = this.odooEditor.historyGetBranchIds().join(',');
            const firstChild = editable.children[0];
            if (firstChild) {
                firstChild.setAttribute('data-last-history-steps', historyIds);
            }
        }
    }
    _bindOnBlur() {
        this.$editable.on('blur', this._onBlur);
    }

    _hasICEServers() {
        // Hack: check if mail module is installed.
        return session.notification_type;
    }
    _isCollaborationEnabled(options) {
        return options.collaborationChannel && options.collaborationChannel.collaborationResId && this._hasICEServers() && this.busService;
    }

    /**
     * Saves a base64 encoded image as an attachment.
     * Relies on _saveModifiedImage being called after it for webp.
     *
     * @private
     * @param {Element} el
     * @param {string} resModel
     * @param {number} resId
     */
    async _saveB64Image(el, resModel, resId) {
        el.classList.remove('o_b64_image_to_save');
        const imageData = el.getAttribute('src').split('base64,')[1];
        if (!imageData) {
            // Checks if the image is in base64 format for RPC call. Relying
            // only on the presence of the class "o_b64_image_to_save" is not
            // robust enough.
            return;
        }
        const attachment = await this._serviceRpc(
            '/web_editor/attachment/add_data',
            {
                name: el.dataset.fileName || '',
                data: imageData,
                is_image: true,
                res_model: resModel,
                res_id: resId,
            },
        );
        if (attachment.mimetype === 'image/webp') {
            el.classList.add('o_modified_image_to_save');
            el.dataset.originalId = attachment.id;
            el.dataset.mimetype = attachment.mimetype;
            el.dataset.fileName = attachment.name;
            this._saveModifiedImage(el, resModel, resId);
        } else {
            let src = attachment.image_src;
            if (!attachment.public) {
                let accessToken = attachment.access_token;
                if (!accessToken) {
                    [accessToken] = await this.orm.call(
                        'ir.attachment',
                        'generate_access_token',
                        [attachment.id],
                    );
                }
                src += `?access_token=${encodeURIComponent(accessToken)}`;
            }
            el.setAttribute('src', src);
        }
    }
    /**
     * Saves a modified image as an attachment.
     *
     * @private
     * @param {Element} el
     * @param {string} resModel
     * @param {number} resId
     */
    async _saveModifiedImage(el, resModel, resId) {
        const isBackground = !el.matches('img');
        // Modifying an image always creates a copy of the original, even if
        // it was modified previously, as the other modified image may be used
        // elsewhere if the snippet was duplicated or was saved as a custom one.
        let altData = undefined;
        const isImageField = !!el.closest("[data-oe-type=image]");
        if (el.dataset.mimetype === 'image/webp' && isImageField) {
            // Generate alternate sizes and format for reports.
            altData = {};
            const image = document.createElement('img');
            image.src = isBackground ? el.dataset.bgSrc : el.getAttribute('src');
            await new Promise(resolve => image.addEventListener('load', resolve));
            const originalSize = Math.max(image.width, image.height);
            const smallerSizes = [1024, 512, 256, 128].filter(size => size < originalSize);
            for (const size of [originalSize, ...smallerSizes]) {
                const ratio = size / originalSize;
                const canvas = document.createElement('canvas');
                canvas.width = image.width * ratio;
                canvas.height = image.height * ratio;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'rgb(255, 255, 255)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                altData[size] = {
                    'image/jpeg': canvas.toDataURL('image/jpeg', 0.75).split(',')[1],
                };
                if (size !== originalSize) {
                    altData[size]['image/webp'] = canvas.toDataURL('image/webp', 0.75).split(',')[1];
                }
            }
        }
        const newAttachmentSrc = await this._serviceRpc(
            `/web_editor/modify_image/${encodeURIComponent(el.dataset.originalId)}`,
            {
                res_model: resModel,
                res_id: parseInt(resId),
                data: (isBackground ? el.dataset.bgSrc : el.getAttribute('src')).split(',')[1],
                alt_data: altData,
                mimetype: (isBackground ? el.dataset.mimetype : el.getAttribute('src').split(":")[1].split(";")[0]),
                name: (el.dataset.fileName ? el.dataset.fileName : null),
            },
        );
        el.classList.remove('o_modified_image_to_save');
        if (isBackground) {
            const parts = weUtils.backgroundImageCssToParts($(el).css('background-image'));
            parts.url = `url('${newAttachmentSrc}')`;
            const combined = weUtils.backgroundImagePartsToCss(parts);
            $(el).css('background-image', combined);
            delete el.dataset.bgSrc;
        } else {
            el.setAttribute('src', newAttachmentSrc);
            // Also update carousel thumbnail.
            weUtils.forwardToThumbnail(el);
        }
    }

    /**
     * @private
     */
    _beforeAnyCommand() {
        // Remove any marker of default text in the selection on which the
        // command is being applied. Note that this needs to be done *before*
        // the command and not after because some commands (e.g. font-size)
        // rely on some elements not to have the class to fully work.
        for (const node of OdooEditorLib.getSelectedNodes(this.$editable[0])) {
            const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
            const defaultTextEl = el.closest('.o_default_snippet_text');
            if (defaultTextEl) {
                defaultTextEl.classList.remove('o_default_snippet_text');
            }
        }
    }

    // -----------------------------------------------------------------------------
    // Legacy compatibility layer
    // Remove me when all legacy widgets using wysiwyg are converted to OWL.
    // -----------------------------------------------------------------------------
    _trigger_up(ev) {
        const evType = ev.name;
        const payload = ev.data;
        if (evType === 'call_service') {
            this._callService(payload);
        }
    }
    _callService(payload) {
        const service = this.env.services[payload.service];
        const result = service[payload.method].apply(service, payload.args || []);
        payload.callback(result);
    }
    _serviceRpc(route, params, settings = {}) {
        if (status(this) === "destroyed") {
            return;
        }
        if (params && params.kwargs) {
            params.kwargs.context = {
                ...this.env.services.user.context,
                ...params.kwargs.context,
            };
        }
        return this.rpc(route, params, {
            silent: settings.shadow,
            xhr: settings.xhr,
        });
    }
}
Wysiwyg.activeCollaborationChannelNames = new Set();
Wysiwyg.activeWysiwygs = new Set();
//--------------------------------------------------------------------------
// Public helper
//--------------------------------------------------------------------------
/**
 * @param {Node} [ownerDocument] (document on which to get the selection)
 * @returns {Object}
 * @returns {Node} sc - start container
 * @returns {Number} so - start offset
 * @returns {Node} ec - end container
 * @returns {Number} eo - end offset
 */
Wysiwyg.getRange = function (ownerDocument) {
    const selection = (ownerDocument || document).getSelection();
    if (selection.rangeCount === 0) {
        return {
            sc: null,
            so: 0,
            ec: null,
            eo: 0,
        };
    }
    const range = selection.getRangeAt(0);

    return {
        sc: range.startContainer,
        so: range.startOffset,
        ec: range.endContainer,
        eo: range.endOffset,
    };
};
/**
 * @param {Node} startNode
 * @param {Number} startOffset
 * @param {Node} endNode
 * @param {Number} endOffset
 */
Wysiwyg.setRange = function (startNode, startOffset = 0, endNode = startNode, endOffset = startOffset) {
    const selection = document.getSelection();
    selection.removeAllRanges();

    const range = new Range();
    range.setStart(startNode, startOffset);
    range.setEnd(endNode, endOffset);
    selection.addRange(range);
};

// Check wether clientA is before clientB.
function isClientFirst(clientA, clientB) {
    if (clientA.startTime === clientB.startTime) {
        return clientA.id.localeCompare(clientB.id) === -1;
    } if (clientA.startTime === undefined || clientB.startTime === undefined) {
        return Boolean(clientA.startTime);
    } else {
        return clientA.startTime < clientB.startTime;
    }
}

__exports.stripHistoryIds = stripHistoryIds; function stripHistoryIds(value) {
    return value && value.replace(/\sdata-last-history-steps="[^"]*?"/, '') || value;
}

return __exports;
});
;

/******************************************************************
*  Filepath: /web_editor/static/src/js/wysiwyg/wysiwyg_iframe.js  *
*  Lines: 296                                                     *
******************************************************************/
odoo.define('@web_editor/js/wysiwyg/wysiwyg_iframe', ['@web_editor/js/wysiwyg/wysiwyg', '@web/core/utils/patch', '@web/core/assets', '@web/core/browser/feature_detection', '@web/legacy/js/core/widget'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { Wysiwyg } = require('@web_editor/js/wysiwyg/wysiwyg');
const { patch } = require("@web/core/utils/patch");
const { getBundle } = require("@web/core/assets");
const { isMobileOS } = require("@web/core/browser/feature_detection");

var promiseJsAssets;

/**
 * Add option (inIframe) to load Wysiwyg in an iframe.
 **/

patch(Wysiwyg.prototype, {
    /**
     * Add options to load Wysiwyg in an iframe.
     *
     * @override
     * @param {boolean} options.inIframe
     **/
    init() {
        super.init();
        if (this.options.inIframe) {
            this._onUpdateIframeId = 'onLoad_' + this.id;
        }
    },
    /**
     * @override
     **/
    async startEdition() {
        if (!this.options.inIframe) {
            return super.startEdition();
        } else {
            this.defAsset = this._getAssets();
            await this.defAsset;
            await this._loadIframe();
            return super.startEdition();
        }
    },

    /**
     * @override
     **/
    destroy() {
        if (this.options.inIframe) {
            this.$iframe?.[0].contentDocument.removeEventListener('scroll', this._onScroll, true);
        }
        super.destroy();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     **/
    _getEditorOptions() {
        const options = super._getEditorOptions(...arguments);
        if (!("getContextFromParentRect" in options)) {
            options.getContextFromParentRect = () => {
                return this.$iframe && this.$iframe.length ? this.$iframe[0].getBoundingClientRect() : { top: 0, left: 0 };
            };
        }
        if (this.$iframe && this.$iframe.length) {
            options.document = this.$iframe[0].contentWindow.document;
        }
        return options;
    },
    /**
     * Create iframe, inject css and create a link with the content,
     * then inject the target inside.
     *
     * @private
     * @returns {Promise}
     */
    _loadIframe() {
        var self = this;
        const isEditableRoot = this.$editable === this.$root;
        this.$editable = $('<div class="note-editable oe_structure odoo-editor-editable"></div>');
        this.$el.removeClass('note-editable oe_structure odoo-editor-editable');
        if (isEditableRoot) {
            this.$root = this.$editable;
        }
        this.$iframe = $('<iframe class="wysiwyg_iframe o_iframe">').css({
            width: '100%'
        });
        var avoidDoubleLoad = 0; // this bug only appears on some configurations.

        // resolve promise on load
        var def = new Promise(function (resolve) {
            window.top[self._onUpdateIframeId] = function (_avoidDoubleLoad) {
                if (_avoidDoubleLoad !== avoidDoubleLoad) {
                    console.warn('Wysiwyg iframe double load detected');
                    return;
                }
                delete window.top[self._onUpdateIframeId];
                var $iframeTarget = self.$iframe.contents().find('#iframe_target');
                // copy the html in itself to have the node prototypes relative
                // to this window rather than the iframe window.
                const $targetClone = $iframeTarget.clone();
                $targetClone.find('script').remove();
                $iframeTarget.html($targetClone.html());
                self.$iframeBody = $iframeTarget;
                $iframeTarget.attr("isMobile", isMobileOS());
                const $utilsZone = $('<div class="iframe-utils-zone">');
                self.$utilsZone = $utilsZone;

                const $iframeWrapper = $('<div class="iframe-editor-wrapper odoo-editor">');
                const $codeview = $('<textarea class="o_codeview d-none"/>');
                self.$editable.addClass('o_editable oe_structure');

                $iframeTarget.append($codeview);
                $iframeTarget.append($iframeWrapper);
                $iframeTarget.append($utilsZone);
                $iframeWrapper.append(self.$editable);

                self.options.toolbarHandler = $('#web_editor-top-edit', self.$iframe[0].contentWindow.document);
                $iframeTarget.on('click', '.o_fullscreen_btn', function () {
                    $("body").toggleClass("o_field_widgetTextHtml_fullscreen");
                    var full = $("body").hasClass("o_field_widgetTextHtml_fullscreen");
                    self.$iframe.parents().toggleClass('o_form_fullscreen_ancestor', full);
                    $(window).trigger("resize"); // induce a resize() call and let other backend elements know (the navbar extra items management relies on this)
                });
                resolve();
            };
        });
        this.$iframe.data('loadDef', def); // for unit test

        // inject content in iframe

        this.$iframe.on('load', function onLoad (ev) {
            var _avoidDoubleLoad = ++avoidDoubleLoad;
            self.defAsset.then(function (assets) {
                if (_avoidDoubleLoad !== avoidDoubleLoad) {
                    console.warn('Wysiwyg immediate iframe double load detected');
                    return;
                }

                const iframeContent = getWysiwygIframeContent({
                    assets: assets,
                    updateIframeId: self._onUpdateIframeId,
                    avoidDoubleLoad: _avoidDoubleLoad
                });
                self.$iframe[0].contentWindow.document
                    .open("text/html", "replace")
                    .write(`<!DOCTYPE html><html${
                        self.options.iframeHtmlClass ? ' class="' + self.options.iframeHtmlClass +'"' : ''
                    }>${iframeContent}</html>`);
                // Closing the document might trigger a new 'load' event.
                self.$iframe.off('load', onLoad);
                self.$iframe[0].contentWindow.document.close();
            });
            self.options.document = self.$iframe[0].contentWindow.document;
        });

        this.$el.append(this.$iframe);

        return def.then(() => {
            this.options.onIframeUpdated();
        });
    },

    _insertSnippetMenu() {
        if (this.options.inIframe) {
            return this.snippetsMenu.appendTo(this.$utilsZone);
        } else {
            return super._insertSnippetMenu(...arguments);
        }
    },
    /**
     * Get assets for the iframe.
     *
     * @private
     * @returns {Promise}
     */
    async _getAssets() {
        promiseJsAssets = promiseJsAssets || await getBundle('web_editor.wysiwyg_iframe_editor_assets');
        const assetsPromises = [promiseJsAssets];
        if (this.options.iframeCssAssets) {
            assetsPromises.push(getBundle(this.options.iframeCssAssets));
        }
        return Promise.all(assetsPromises);
    },

    /**
     * Bind the blur event on the iframe so that it would not blur when using
     * the sidebar.
     *
     * @override
     */
    _bindOnBlur() {
        if (!this.options.inIframe) {
            super._bindOnBlur(...arguments);
        } else {
            this.$iframe[0].contentWindow.addEventListener('blur', this._onBlur);
        }
    },

    /**
     * When the editable is inside an iframe, we want to update the toolbar
     * position in 2 scenarios:
     * 1. scroll event in the top document, if the iframe is a descendant of
     * the scroll container.
     * 2. scroll event in the iframe's document.
     * 
     * @override
     */
    _onScroll(ev) {
        if (this.options.inIframe) {
            const iframeDocument = this.$iframe[0].contentDocument;
            const scrollInIframe = ev.target === iframeDocument || ev.target.ownerDocument === iframeDocument;
            if (ev.target.contains(this.$iframe[0]))  {
                this.scrollContainer = ev.target;
                this.odooEditor.updateToolbarPosition();
            } else if (scrollInIframe) {
                // UpdateToolbarPosition needs a scroll container in the top document.
                this.scrollContainer = this.$iframe[0];
                this.odooEditor.updateToolbarPosition();
            }
        } else {
            return super._onScroll(...arguments);
        }
    },

    /**
     * @override
     */
    _configureToolbar(options) {
        super._configureToolbar(...arguments);
        if (this.options.inIframe && !options.snippets) {
            this.$iframe[0].contentDocument.addEventListener('scroll', this._onScroll, true);
        }
    },
});

function getWysiwygIframeContent(params) {
    const assets = {
        cssLibs: [],
        cssContents: [],
        jsLibs: [],
        jsContents: [],
    };
    for (const asset of params.assets) {
        for (const cssLib of asset.cssLibs) {
            assets.cssLibs.push(`<link type="text/css" rel="stylesheet" href="${cssLib}"/>`);
        }
        for (const cssContent of asset.cssContents) {
            assets.cssContents.push(`<style type="text/css">${cssContent}</style>`);
        }
        for (const jsLib of asset.jsLibs) {
            assets.jsLibs.push(`<script type="text/javascript" src="${jsLib}"/>`);
        }
        for (const jsContent of asset.jsContents) {
            if (jsContent.indexOf('inline asset') !== -1) {
                assets.jsContents.push(`<script type="text/javascript">${jsContent}</script>`);
            }
        }
    }
    return `
        <meta charset="utf-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
        ${assets.cssLibs.join('\n')}
        ${assets.cssContents.join('\n')}
        ${assets.jsLibs.join('\n')}
        ${assets.jsContents.join('\n')}

        <script type="text/javascript">
            odoo.define('root.widget', ['@web/legacy/js/core/widget'], function (require) {
                'use strict';
                var Widget = require('@web/legacy/js/core/widget')[Symbol.for("default")];
                var widget = new Widget();
                widget.appendTo(document.body);
                return widget;
            });
        </script>
    </head>
    <body class="o_in_iframe">
        <div id="iframe_target"/>
        <script type="text/javascript">
            odoo.define('web_editor.wysiwyg.iniframe', [], function (require) {
                'use strict';
                if (window.top.${params.updateIframeId}) {
                    window.top.${params.updateIframeId}(${params.avoidDoubleLoad});
                }
            });
        </script>
    </body>`;
}

return __exports;
});


                    /*******************************************
                    *  Templates                               *
                    *******************************************/

                    odoo.define('web_editor.backend_assets_wysiwyg.bundle.xml', ['@web/core/registry'], function(require){
                        'use strict';
                        const { registry } = require('@web/core/registry');
                        registry.category(`xml_templates`).add(`web_editor.backend_assets_wysiwyg`, `<?xml version="1.0" encoding="UTF-8"?>
<templates xml:space="preserve">
<!-- Filepath: /web/static/src/legacy/xml/dialog.xml -->
<t t-name="web.DialogWidget">
    <div role="dialog" t-attf-class="modal o_legacy_dialog #{ technical ? ' o_technical_modal' : '' } #{ fullscreen ? ' o_modal_full': '' }" tabindex="-1" data-bs-backdrop="static" t-att-id="uniqueId" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <header t-if="renderHeader" class="modal-header">
                    <h4 class="modal-title"><t t-out="title"/><span class="o_subtitle text-muted small" t-out="subtitle"/></h4>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" tabindex="-1"/>
                </header>
                <main class="modal-body"/>
                <footer t-if="renderFooter" class="modal-footer justify-content-around justify-content-md-start flex-wrap gap-1"/>
            </div>
        </div>
    </div>
</t>

<!-- Filepath: /web_editor/static/src/js/wysiwyg/conflict_dialog.xml -->

<t t-name="web_editor.ConflictDialog">
            <Dialog size="'xl'" title="'Content conflict'">
                <div>
                    <div style="color: red;">
                        <p>
                            There is a conflict between your version and the one in the database.
                        </p>
                        <p>
                            The version from the database will be used.
                            If you need to keep your changes, copy the content below and edit the new document.
                        </p>
                        <p style="font-weight: bold;">
                            Warning: after closing this dialog, the version you were working on will be discarded and will never be available anymore.
                        </p>
                    </div>
                </div>
                <t t-out="props.content"/>
            </Dialog>
    </t>

<!-- Filepath: /web_editor/static/src/js/wysiwyg/widgets/alt_dialog.xml -->
<t t-name="web_edior.AltDialog">
    <Dialog size="'xl'" title="'Change media description and tooltip'">
        <form action="#">
            <div class="mb-3 row">
                <label class="col-md-3 col-form-label" for="alt" title="'Alt tag' specifies an alternate text for an image, if the image cannot be displayed (slow connection, missing image, screen reader ...).">
                Description <small>(ALT Tag)</small>
                </label>
                <div class="col-md-8">
                    <input class="form-control" t-ref="alt" required="required" t-att-value="props.alt" type="text"/>
                </div>
            </div>
            <div class="mb-3 row">
                <label class="col-md-3 col-form-label" for="title" title="'Title tag' is shown as a tooltip when you hover the picture.">
                Tooltip  <small>(TITLE Tag)</small>
                </label>
                <div class="col-md-8">
                    <input class="form-control" t-ref="tag_title" required="required" t-att-value="props.tag_title" type="text"/>
                </div>
            </div>
        </form>
        <t t-set-slot="footer">
            <button class="btn btn-primary" t-on-click="_confirm">Save</button>
            <button class="btn btn-secondary" t-on-click="_cancel">Discard</button>
        </t>
    </Dialog>
</t>

<!-- Filepath: /web_editor/static/src/js/wysiwyg/widgets/chatgpt_alternatives_dialog.xml -->

<t t-name="web_edior.ChatGPTAlternativesDialog">
    <Dialog size="'lg'" title="'AI Copywriter'">
        <div class="md-8">
            <div class="mb-3">
                <t t-foreach="Object.entries(props.alternativesModes)" t-as="alternative" t-key="alternative_index">
                    <button type="button" class="btn me-2 btn-sm btn-info" t-att-class="state.alternativesMode == alternative[0] and state.messagesInProgress ? 'btn-success' : 'btn-info'" t-on-click="switchAlternativesMode" t-att-data-mode="alternative[0]">
                        <t t-out="alternative[1]"/>
                    </button>
                </t>
            </div>
            <div class="list-group">
                <div t-if="state.messagesInProgress" class="d-flex align" t-att-class="{ 'mb-3': state.messages.length }">
                    <img src="/web/static/img/spin.svg" alt="Loading..." class="me-2" style="filter:invert(1); opacity: 0.5; width: 30px; height: 30px;"/>
                    <p class="m-0 text-muted align-self-center">
                        <em t-if="state.messagesInProgress == 1">Generating an alternative...</em>
                        <em t-else="">Generating <t t-out="state.messagesInProgress"/> alternatives...</em>
                    </p>
                </div>
                <t t-foreach="[...state.messages].reverse()" t-as="message" t-key="message.id">
                    <t t-if="message.isError">
                        <div class="list-group-item o-chatgpt-alternative border-danger bg-danger o-message-error" t-att-class="{ 'text-muted': state.currentBatchId != message.batchId }">
                            <t t-out="message.text"/>
                        </div>
                    </t>
                    <t t-else="">
                        <button type="button" class="list-group-item list-group-item-action o-chatgpt-alternative" t-on-click="selectMessage" t-att-data-message-id="message.id" t-att-class="{                                 active: state.selectedMessageId == message.id,                                 'text-muted': state.selectedMessageId != message.id and state.currentBatchId != message.batchId,                             }">
                            <span t-if="message.mode" class="badge bg-secondary float-end"><t t-out="props.alternativesModes[message.mode]"/></span>
                            <t t-out="formatContent(message.text)"/>
                        </button>
                    </t>
                </t>
            </div>
        </div>


        <t t-set-slot="footer">
            <button class="btn btn-primary" t-on-click="_confirm" t-att-disabled="typeof state.selectedMessageId !== 'number'">Insert</button>
            <button class="btn btn-secondary" t-on-click="_cancel">Cancel</button>
        </t>
    </Dialog>
</t>

<!-- Filepath: /web_editor/static/src/js/wysiwyg/widgets/chatgpt_prompt_dialog.xml -->
<t t-name="web_edior.ChatGPTPromptDialog">
    <Dialog size="'lg'" title="'Generate Text with AI'">
        <div t-foreach="state.messages" t-as="message" t-key="message_index" class="position-relative py-1 px-3" t-att-class="message_index ? 'mt-2' : 'mt-0'">
            <div class="position-relative d-flex flex-shrink-0">
                <div class="d-flex flex-shrink-0" style="flex-basis: 42px; max-width: 42px;">
                    <div class="position-relative bg-view" style="width: 36px; height: 36px;">
                        <img class="w-100 h-100 rounded" t-att-src="message.author === 'user' ? userAvatarUrl : assistantAvatarUrl"/>
                    </div>
                </div>
                <div class="w-100 o-min-width-0">
                    <div class="d-flex flex-wrap align-items-baseline mb-1 lh-1">
                        <strong class="me-1 text-truncate"><t t-esc="message.author === 'user' ? 'You' : 'OdooBot'"/></strong>
                    </div>
                    <div class="position-relative d-flex">
                        <div class="o-min-width-0">
                            <div class="position-relative d-flex">
                                <div class="position-relative overflow-x-auto d-inline-block">
                                    <div class="rounded-bottom-3 position-absolute top-0 start-0 w-100 h-100 border opacity-25" t-att-class="{                                             'border-success bg-success-light': message.author === 'user' and message.isError !== true,                                             'border-info bg-info-light': message.author === 'assistant' and message.isError !== true,                                             'border-danger bg-danger': message.isError,                                         }"/>
                                    <div class="position-relative text-break mb-0 py-2 px-3 align-self-start rounded-end-3 rounded-bottom-3 o-chatgpt-message">

                                        <button t-if="message.author === 'assistant' and 'text' in message and message.isError !== true" t-att-data-message-id="message.id" class="o-message-insert d-block float-end p-1 mb-1 btn btn-info opacity-75 fst-italic ms-3" t-on-click="insertMessage">Insert</button>
                                        <div class="d-inline">

                                            <div t-if="message.author === 'assistant' and !('text' in message)" class="d-flex align">
                                                <img src="/web/static/img/spin.svg" alt="Loading..." class="me-2" style="filter:invert(1); opacity: 0.5; width: 30px; height: 30px;"/>
                                                <p class="m-0 text-muted align-self-center">
                                                    <em>Thinking...</em>
                                                </p>
                                            </div>

                                            <div t-elif="message.isError" class="o-message-error">
                                                <t t-out="message.text"/>
                                            </div>
                                            <t t-else="">
                                                <t t-out="formatContent(message.text)"/>
                                            </t>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div t-if="!state.messages.length" style="min-height: 150px;"/> 


        <t t-set-slot="footer">
            <div class="md-8 mb-8 d-flex bg-view flex-grow-1 border rounded-3">
                <div class="o-prompt-input position-relative flex-grow-1">
                    <textarea type="text" id="promptInput" t-ref="promptInput" name="promptInput" t-on-keydown="onTextareaKeydown" class="form-control bg-view px-3 border-0 overflow-auto" placeholder="Send a message" autocomplete="off" t-model="state.prompt" required="required"/>
                </div>
                <div class="border-start-0 rounded-0 rounded-end-3 align-self-center ms-2 me-3">
                    <button class="btn" t-att-class="state.prompt.length ? 'btn-success' : 'disabled'" t-on-click="submitPrompt">
                        <i class="fa fa-paper-plane"/>
                    </button>
                </div>
            </div>
        </t>
    </Dialog>
</t>

<!-- Filepath: /web_editor/static/src/xml/editor.xml -->
<t t-name="web_editor.toolbar">
        <div id="toolbar" class="oe-toolbar oe-floating" t-ref="toolbarRef">
            <div t-if="props.showStyle" id="style" t-attf-class="btn-group {{ props.dropDirection }}">
                <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown" data-bs-original-title="Text style" tabindex="-1" aria-expanded="false">
                    <span title="Text style">Normal</span>
                </button>
                <ul class="dropdown-menu">
                    <li id="display-1-dropdown-item">
                        <a class="dropdown-item" href="#" id="display-1" data-call="setTag" data-arg1="h1,display-1">Header 1 Display 1</a>
                    </li>
                    <li id="display-2-dropdown-item">
                        <a class="dropdown-item" href="#" id="display-2" data-call="setTag" data-arg1="h1,display-2" data-extended-text-style="">Header 1 Display 2</a>
                    </li>
                    <li id="display-3-dropdown-item">
                        <a class="dropdown-item" href="#" id="display-3" data-call="setTag" data-arg1="h1,display-3" data-extended-text-style="">Header 1 Display 3</a>
                    </li>
                    <li id="display-4-dropdown-item">
                        <a class="dropdown-item" href="#" id="display-4" data-call="setTag" data-arg1="h1,display-4" data-extended-text-style="">Header 1 Display 4</a>
                    </li>
                    <li t-if="props.showHeading1" id="heading1-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading1" data-call="setTag" data-arg1="h1">Header 1</a>
                    </li>
                    <li t-if="props.showHeading2" id="heading2-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading2" data-call="setTag" data-arg1="h2">Header 2</a>
                    </li>
                    <li t-if="props.showHeading3" id="heading3-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading3" data-call="setTag" data-arg1="h3">Header 3</a>
                    </li>
                    <li t-if="props.showHeading4" id="heading4-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading4" data-call="setTag" data-arg1="h4">Header 4</a>
                    </li>
                    <li t-if="props.showHeading5" id="heading5-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading5" data-call="setTag" data-arg1="h5">Header 5</a>
                    </li>
                    <li t-if="props.showHeading6" id="heading6-dropdown-item">
                        <a class="dropdown-item" href="#" id="heading6" data-call="setTag" data-arg1="h6">Header 6</a>
                    </li>
                    <li id="paragraph-dropdown-item">
                        <a class="dropdown-item" href="#" id="paragraph" data-call="setTag" data-arg1="p">Normal</a>
                    </li>
                    <li id="light-dropdown-item">
                        <a class="dropdown-item" href="#" id="light" data-call="setTag" data-arg1="p,lead" data-extended-text-style="">Light</a>
                    </li>
                    <li id="small-dropdown-item">
                        <a class="dropdown-item" href="#" id="small" data-call="setTag" data-arg1="p,o_small" data-extended-text-style="">Small</a>
                    </li>
                    <li id="pre-dropdown-item">
                        <a class="dropdown-item" href="#" id="pre" data-call="setTag" data-arg1="pre">Code</a>
                    </li>
                    <li id="blockquote-dropdown-item">
                        <a class="dropdown-item" href="#" id="blockquote" data-call="setTag" data-arg1="blockquote">Quote</a>
                    </li>
                </ul>
            </div>

            <div id="decoration" class="btn-group">
                <div id="bold" data-call="bold" title="Toggle bold" class="btn fa fa-bold fa-fw"/>
                <div id="italic" data-call="italic" title="Toggle italic" class="btn fa fa-italic fa-fw"/>
                <div id="underline" data-call="underline" title="Toggle underline" class="btn fa fa-underline fa-fw"/>
                <div id="strikethrough" data-call="strikeThrough" title="Toggle strikethrough" class="btn fa fa-strikethrough fa-fw"/>
                <div id="removeFormat" data-call="removeFormat" title="Remove format" class="btn fa fa-eraser fa-fw"/>
            </div>

            <div t-if="props.showColors" id="colorInputButtonGroup" class="btn-group">
                <div class="colorpicker-group note-fore-color-preview" data-name="color" t-ref="textColorpickerDropdown" data-color-type="text">
                    <div id="oe-text-color" class="btn color-button dropdown-toggle editor-ignore" data-bs-toggle="dropdown" tabindex="-1">
                        <i class="fa fa-font color-indicator fore-color" title="Font Color"/>
                    </div>
                    <ul class="dropdown-menu colorpicker-menu">
                        <li><ColorPalette t-props="props.textColorPaletteProps"/></li>
                    </ul>
                </div>
                <div class="colorpicker-group note-back-color-preview" data-name="color" t-ref="backgroundColorpaletteDropdown" data-color-type="background">
                    <button id="oe-fore-color" type="button" class="btn dropdown-toggle editor-ignore" data-bs-toggle="dropdown" tabindex="-1">
                        <i class="fa fa-paint-brush color-indicator hilite-color" title="Background Color"/>
                    </button>
                    <ul class="dropdown-menu colorpicker-menu">
                        <li><ColorPalette t-props="props.backgroundColorPaletteProps"/></li>
                    </ul>
                </div>
            </div>

            <t t-if="!this.isMobile()">
                <div t-if="props.useFontSizeInput or props.showFontSize" id="font-size" t-attf-class="btn-group {{ props.dropDirection }}">
                    <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown" tabindex="-1" data-bs-original-title="Font Size" aria-expanded="false">
                        <div id="font-size-input-container">
                            <input type="text" id="fontSizeCurrentValue" title="Font size" value="13" t-att-readonly="props.showFontSize" t-att-class="props.showFontSize ? 'cursor-pointer' : ''"/>
                        </div>
                    </button>
                    <ul class="dropdown-menu">

                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="display-1-font-size" data-apply-class="display-1-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Display 1</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="display-2-font-size" data-apply-class="display-2-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Display 2</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="display-3-font-size" data-apply-class="display-3-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Display 3</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="display-4-font-size" data-apply-class="display-4-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Display 4</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h1-font-size" data-apply-class="h1-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 1</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h2-font-size" data-apply-class="h2-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 2</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h3-font-size" data-apply-class="h3-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 3</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h4-font-size" data-apply-class="h4-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 4</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h5-font-size" data-apply-class="h5-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 5</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="h6-font-size" data-apply-class="h6-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Heading 6</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="font-size-base" data-apply-class="base-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Normal</span></a></li>
                        <li><a class="dropdown-item d-flex justify-content-between align-items-center" data-dynamic-value="small-font-size" data-apply-class="o_small-fs" href="#">? <span class="d-none o_we_font_size_badge badge rounded-pill text-bg-dark ms-4">Small</span></a></li>
                    </ul>
                </div>
            </t>

            <div t-if="props.showJustify" id="justify" t-attf-class="btn-group {{ props.dropDirection }}">
                <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown" tabindex="-1" data-bs-original-title="Paragraph" aria-expanded="false">
                    <i id="paragraphDropdownButton" class="fa fa-align-left fa-fw" title="Text align"/>
                </button>
                <div class="dropdown-menu">
                    <div class="btn-group">
                        <div class="btn" id="justifyLeft" data-call="justifyLeft"><i class="fa fa-align-left fa-fw"/></div>
                        <div class="btn" id="justifyCenter" data-call="justifyCenter"><i class="fa fa-align-center fa-fw"/></div>
                        <div class="btn" id="justifyRight" data-call="justifyRight"><i class="fa fa-align-right fa-fw"/></div>
                        <div class="btn" id="justifyFull" data-call="justifyFull"><i class="fa fa-align-justify fa-fw"/></div>
                    </div>
                </div>
            </div>

            <t t-if="this.isMobile()">
                <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown" title="List" tabindex="-1" data-bs-original-title="List" aria-expanded="false">
                    <i class="fa fa-list fa-fw"/>
                </button>
                <div class="dropdown-menu">
                    <div t-if="props.showList" id="list" class="btn-group">
                        <div id="unordered" data-call="toggleList" data-arg1="UL" title="Toggle unordered list" class="oe-toggle-unordered fa fa-list-ul fa-fw btn"/>
                        <div id="ordered" data-call="toggleList" data-arg1="OL" title="Toggle ordered list" class="oe-toggle-ordered fa fa-list-ol fa-fw btn"/>
                        <div t-if="props.showChecklist" id="checklist" data-call="toggleList" data-arg1="CL" title="Toggle checklist" class="oe-toggle-checklist btn fa fa-fw">
                            <div class="small">
                                <div class="fa fa-square-o d-block small"/>
                                <div class="fa fa-check-square d-block small"/>
                            </div>
                        </div>
                    </div>
                </div>
            </t>
            <t t-else="">
                <div t-if="props.showList" id="list" class="btn-group">
                    <div id="unordered" data-call="toggleList" data-arg1="UL" title="Toggle unordered list" class="oe-toggle-unordered fa fa-list-ul fa-fw btn"/>
                    <div id="ordered" data-call="toggleList" data-arg1="OL" title="Toggle ordered list" class="oe-toggle-ordered fa fa-list-ol fa-fw btn"/>
                    <div t-if="props.showChecklist" id="checklist" data-call="toggleList" data-arg1="CL" title="Toggle checklist" class="oe-toggle-checklist btn fa fa-fw">
                        <div class="small">
                            <div class="fa fa-square-o d-block small"/>
                            <div class="fa fa-check-square d-block small"/>
                        </div>
                    </div>
                </div>
            </t>

            <div id="image-preview" class="btn-group">
                <div id="image-fullscreen" title="Full screen" class="fa fa-search-plus btn editor-ignore"/>
            </div>

            <div t-if="props.showLink" id="link" class="btn-group">
                <div id="media-insert" title="Insert media" class="fa fa-file-image-o fa-fw btn editor-ignore"/>

                <div id="unlink" data-call="unlink" title="Remove link" class="fa fa-unlink fa-fw btn order-1"/>
                <div id="create-link" title="Insert or edit link" class="fa fa-link fa-fw btn editor-ignore"/>
                <a id="media-description" href="#" title="Edit media description" class="btn editor-ignore">Description</a>
            </div>

            <div id="chatgpt" class="btn-group">
                <div id="open-chatgpt" title="Generate or transform content with AI" class="btn editor-ignore">
                    <span class="fa fa-magic fa-fw"/>
                </div>
            </div>

            <div t-if="props.showImageShape" id="image-shape" class="btn-group">
                <div id="rounded" title="Shape: Rounded" class="fa fa-square fa-fw btn editor-ignore"/>
                <div id="rounded-circle" title="Shape: Circle" class="fa fa-circle-o fa-fw btn editor-ignore"/>
                <div id="shadow" title="Shadow" class="fa fa-sun-o fa-fw btn editor-ignore"/>
                <div id="img-thumbnail" title="Shape: Thumbnail" class="fa fa-picture-o fa-fw btn editor-ignore"/>
            </div>

            <div t-if="props.showImagePadding" id="image-padding" t-attf-class="btn-group {{ props.dropDirection }}">
                <button type="button" class="btn dropdown-toggle" data-bs-toggle="dropdown" tabindex="-1" aria-expanded="false">
                    <span class="fa fa-plus-square-o" title="Image padding"/>
                </button>
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item editor-ignore" href="#" data-class="">None</a></li>
                    <li><a class="dropdown-item editor-ignore" href="#" data-class="padding-small">Small</a></li>
                    <li><a class="dropdown-item editor-ignore" href="#" data-class="padding-medium">Medium</a></li>
                    <li><a class="dropdown-item editor-ignore" href="#" data-class="padding-large">Large</a></li>
                    <li><a class="dropdown-item editor-ignore" href="#" data-class="padding-xl">XL</a></li>
                </ul>
            </div>

            <div t-if="props.showImageWidth" id="image-width" class="btn-group">
                <div title="Resize Default" class="btn editor-ignore">Default</div>
                <div id="100%" title="Resize Full" class="btn editor-ignore">100%</div>
                <div id="50%" title="Resize Half" class="btn editor-ignore">50%</div>
                <div id="25%" title="Resize Quarter" class="btn editor-ignore">25%</div>
            </div>

            <div t-if="props.showImageEdit" id="image-edit" class="btn-group">
                <div id="image-crop" title="Crop Image" class="btn fa fa-crop editor-ignore"/>
                <div id="image-transform" class="btn editor-ignore fa fa-object-ungroup" title="Transform the picture (click twice to reset transformation)"/>
                <span class="oe-toolbar-separator d-flex"/>
                <div id="media-replace" title="Replace media" class="btn o_we_bg_success editor-ignore">Replace</div>
                <span class="oe-toolbar-separator d-flex"/>
                <div id="image-delete" class="btn btn-link text-danger editor-ignore fa fa-trash" title="Remove (DELETE)"/>
            </div>

            <div id="fa-resize" class="btn-group only_fa">
                <div class="editor-ignore btn" title="Icon size 1x" data-value="1">1x</div>
                <div class="editor-ignore btn" title="Icon size 2x" data-value="2">2x</div>
                <div class="editor-ignore btn" title="Icon size 3x" data-value="3">3x</div>
                <div class="editor-ignore btn" title="Icon size 4x" data-value="4">4x</div>
                <div class="editor-ignore btn" title="Icon size 5x" data-value="5">5x</div>
            </div>

            <div class="btn-group only_fa">
                <div id="fa-spin" title="Toggle icon spin" class="editor-ignore btn fa fa-play"/>
            </div>

            <div t-if="props.showHistory" id="history" class="btn-group">
                <div id="undo" data-call="undo" class="btn fa fa-undo"/>
                <div id="redo" data-call="redo" class="btn fa fa-repeat"/>
            </div>

            <t t-slot="default"/>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/editor.xml -->




    <t t-name="web_editor.toolbar.table-options">
        <we-customizeblock-options id="o-we-editor-table-container">
            <we-title>
                <span>Table Options</span>
                <div id="oe-table-delete-table" data-call="deleteTable" class="o_we_hover_danger">
                    <i class="fa fa-trash"/>
                </div>
            </we-title>
            <div id="oe-table-options">
                <div class="oe-table-row">
                    <span class="oe-table-label">Add Column</span>
                    <div class="w-100">
                        <div class="oe-table-selection btn-group w-100">
                            <button class="btn w-50" data-call="addColumn" data-arg1="before">
                                <i class="small fa fa-fw fa-step-backward"/> Left
                            </button>
                            <button class="btn w-50" data-call="addColumn" data-arg1="after">
                                Right <i class="small fa fa-fw fa-step-forward"/>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="oe-table-row">
                    <span class="oe-table-label">Add Row</span>
                    <div class="w-100">
                        <div class="oe-table-selection btn-group w-100">
                            <button class="btn w-50" data-call="addRow" data-arg1="before">
                                <i class="small fa fa-fw fa-step-backward fa-rotate-90"/> Above
                            </button>
                            <button class="btn w-50" data-call="addRow" data-arg1="after">
                                Below <i class="small fa fa-fw fa-step-forward fa-rotate-90"/>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="oe-table-row mt-3">
                    <span class="oe-table-label">Remove Current</span>
                    <div class="w-100">
                        <div class="oe-table-selection btn-group w-100">
                            <button class="btn w-50" data-call="removeColumn">
                                <i class="small fa fa-fw fa-columns"/> Column
                            </button>
                            <button class="btn w-50" data-call="removeRow">
                                <i class="small fa fa-fw fa-bars"/> Row
                            </button>
                        </div>
                    </div>
                </div>
                 <div class="oe-table-row mt-3">
                    <span class="oe-table-label"/>
                    <div class="w-100">
                        <div class="oe-table-selection btn-group w-100">
                            <button class="btn w-50" data-call="resetSize">
                                <i class="small fa fa-fw fa-table"/> Reset Size
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </we-customizeblock-options>
    </t>

<!-- Filepath: /web_editor/static/src/xml/editor.xml -->






    <t t-name="web_editor.background_position_overlay">
        <div class="o_we_background_position_overlay oe_overlay">
            <div class="o_we_overlay_content position-absolute">
                <div class="o_overlay_background"/>
                <div class="o_we_overlay_buttons position-absolute d-flex m-1" style="top: 0">
                    <button class="btn btn-primary me-1 o_btn_apply">Apply</button>
                    <button class="btn btn-danger o_btn_discard">Discard</button>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/commands.xml -->
<t t-name="web_editor.banner">
        <div t-attf-class="o_editor_banner o_not_editable lh-1 d-flex align-items-center alert alert-#{alertClass} pb-0 pt-3" role="status" data-oe-protected="true">
            <i t-attf-class="fs-4 fa #{iconClass} mb-3" t-att-aria-label="label"/>
            <div class="o_editable o_editable_no_shadow w-100 ms-3" data-oe-protected="false">
                <p><br/></p>
            </div>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/grid_layout.xml -->
<t t-name="web_editor.background_grid">
    <div t-attf-style="grid-area: 1 / 1 / #{rowCount} / -1;" class="o_we_background_grid">
        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
            <defs>
                <pattern id="cell" t-attf-width="#{columnSize + columnGap}px" t-attf-height="#{rowSize + rowGap}px" patternUnits="userSpaceOnUse">
                    <rect class="o_we_cell" x="2" y="2" rx="4" t-attf-width="#{columnSize - 4}px" t-attf-height="#{rowSize - 4}px"/>
                </pattern>
            </defs>

            <rect fill="url(#cell)" width="100%" height="100%"/>
        </svg>
    </div>
</t>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->

<t t-name="web_editor.snippet_overlay">
        <div class="oe_overlay o_handlers_idle">
            <div class="o_handles">

                <div class="o_handle o_column_handle o_side o_side_y n readonly"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_column_handle o_side o_side_x e readonly"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_column_handle o_side o_side_x w readonly"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_column_handle o_side o_side_y s readonly"><span class="o_handle_indicator"/></div>


                <div class="o_handle o_grid_handle o_side o_side_y n d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_side o_side_x e d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_side o_side_x w d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_side o_side_y s d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_corner_handle ne d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_corner_handle nw d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_corner_handle se d-none"><span class="o_handle_indicator"/></div>
                <div class="o_handle o_grid_handle o_corner_handle sw d-none"><span class="o_handle_indicator"/></div>

                <div class="o_overlay_options_wrap">

                    <div class="o_overlay_move_options">

                        <div class="o_front_back o_send_back d-none"/>
                        <div class="o_front_back o_bring_front d-none"/>
                        <div class="o_move_handle fa fa-arrows"/>
                    </div>
                    <div class="o_overlay_edit_options">
                        <button type="button" class="oe_snippet_remove o_we_bg_danger fa fa-trash"/>
                    </div>
                </div>
            </div>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->
    <t t-name="web_editor.customize_block_options_section">
        <we-customizeblock-options>
            <we-title>
                <span t-esc="name"/>
                <we-top-button-group>
                    <we-button class="fa fa-fw fa-clone oe_snippet_clone o_we_link o_we_hover_success" title="Duplicate Container" aria-label="Duplicate Container"/>
                    <we-button class="fa fa-fw fa-trash oe_snippet_remove o_we_link o_we_hover_danger" title="Remove Block" aria-label="Remove Block"/>
                </we-top-button-group>
            </we-title>
        </we-customizeblock-options>
    </t>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->
    <t t-name="web_editor.outdated_block_message">
        <we-alert class="d-flex flex-column p-3 pt-4 align-items-center text-center text-white">
            <we-title>This block is outdated.</we-title>
            <span>You might not be able to customize it anymore.</span>
            <we-button class="o_we_bg_brand_primary py-2 my-4 border-0" data-no-preview="true" data-replace-snippet="">REPLACE BY NEW VERSION</we-button>
            <span>You can still access the block options but it might be ineffective.</span>
            <we-button class="o_we_bg_brand_primary py-2 my-4 border-0" data-no-preview="true" data-discard-alert="">ACCESS OPTIONS ANYWAY</we-button>
        </we-alert>
    </t>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->


    <div t-name="web_editor.ColorPalette" class="colorpicker" t-ref="el" t-on-click="this._onColorpickerClick">
        <div class="o_we_colorpicker_switch_panel d-flex justify-content-end px-2">
            <t t-set="first_button_name"><t t-if="props.withCombinations">Theme</t><t t-else="">Solid</t></t>
            <button type="button" tabindex="1" class="o_we_colorpicker_switch_pane_btn" t-attf-data-target="#{props.withCombinations ? 'color-combinations' : 'theme-colors'}" t-att-title="first_button_name" t-on-click="this._onSwitchPaneButtonClick">
                <span t-out="first_button_name"/>
            </button>
            <button type="button" tabindex="2" class="o_we_colorpicker_switch_pane_btn" data-target="custom-colors" title="Custom" t-on-click="this._onSwitchPaneButtonClick">
                <span>Custom</span>
            </button>
            <button type="button" tabindex="3" class="o_we_colorpicker_switch_pane_btn" data-target="gradients" title="Gradient" t-on-click="this._onSwitchPaneButtonClick">
                <span>Gradient</span>
            </button>
            <t t-if="props.resetButton">
                <t t-set="trash_title"><t t-if="props.withCombinations">None</t><t t-else="">Reset</t></t>
                <button type="button" class="fa fa-trash my-1 ms-5 py-0 o_we_color_btn o_colorpicker_reset o_we_hover_danger" t-att-title="trash_title"/>
            </t>
        </div>
        <div class="o_colorpicker_sections pt-2 px-2 pb-3" data-color-tab="color-combinations">

            <t t-foreach="[1, 2, 3, 4, 5]" t-as="number" t-key="number">
                <button type="button" class="o_we_color_btn o_we_color_combination_btn" t-att-data-color="number" t-attf-title="Preset #{number}">
                    <t t-call="web_editor.color.combination.preview"/>
                </button>
            </t>
        </div>
        <div class="o_colorpicker_sections py-3 px-2" data-color-tab="theme-colors"/>
        <div class="o_colorpicker_sections py-3 px-2" data-color-tab="custom-colors">
            <div class="o_colorpicker_section_container"/>
            <t t-if="!this.props.excluded.includes('custom')">
                <Colorpicker document="this.props.document" defaultColor="this.state.customDefaultColor" noTransparency="!!this.props.noTransparency" selectedColor="this.state.customSelectedColor" onColorSelect.bind="_onColorPickerSelect" onColorPreview.bind="_onColorPickerPreview" onInputEnter="props.onInputEnter"/>
            </t>
        </div>
        <div class="o_colorpicker_sections py-3 px-2" data-color-tab="gradients">
            <div class="o_colorpicker_section_container"/>
            <t t-if="state.showGradientPicker">
                <Colorpicker document="this.props.document" stopClickPropagation="true" selectedColor="this.state.gradientSelectedColor" onColorSelect.bind="_onColorPickerSelectGradient" onColorPreview.bind="_onColorPickerPreviewGradient" onInputEnter="props.onInputEnter"/>
            </t>
        </div>
    </div>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->
    <t t-name="web_editor.color.combination.preview">
        <div class="o_we_cc_preview_wrapper d-flex justify-content-between">
            <h1 class="o_we_color_combination_btn_title">Title</h1>
            <p class="o_we_color_combination_btn_text flex-grow-1">Text</p>
            <span class="o_we_color_combination_btn_btn btn btn-sm btn-primary o_btn_preview me-1"><small>Button</small></span>
            <span class="o_we_color_combination_btn_btn btn btn-sm btn-secondary o_btn_preview"><small>Button</small></span>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/snippets.xml -->
    <t t-name="web_editor.color.combination.preview.legacy">
        <div class="o_we_cc_preview_wrapper d-flex justify-content-between">
            <h1 class="o_we_color_combination_btn_title">Title</h1>
            <p class="o_we_color_combination_btn_text flex-grow-1">Text</p>
            <span class="o_we_color_combination_btn_btn btn btn-sm btn-primary o_btn_preview me-1"><small>Button</small></span>
            <span class="o_we_color_combination_btn_btn btn btn-sm btn-secondary o_btn_preview"><small>Button</small></span>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg.xml -->

<t t-name="web_editor.Wysiwyg">
        <div style="display: contents;" t-ref="toolbar">
            <Toolbar t-props="this.state.toolbarProps" t-if="this.state.showToolbar"/>
        </div>
        <div style="display: contents;" t-ref="imageCrop">
            <ImageCrop t-props="this.imageCropProps"/>
        </div>
        <div t-ref="el"/>
    </t>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg.xml -->






    <div t-name="web_editor.LinkDialog">
        <t t-set="title">Insert a Link / Button</t>
        <Dialog size="'xl'" title="title">
            <div class="o_link_dialog">
                <div class="row" t-ref="linkComponentWrapper">
                    <form class="col-lg-8">
                        <div t-attf-class="mb-3 row#{props.needLabel ? '' : ' d-none'}">
                            <label class="col-form-label col-md-3" for="o_link_dialog_label_input">Link Label</label>
                            <div class="col-md-9">
                                <input type="text" name="label" class="form-control" id="o_link_dialog_label_input" required="required" t-ref="inputText"/>
                            </div>
                        </div>
                        <div t-attf-class="mb-3 row o_url_input#{state.isButton ? ' d-none' : ''}">
                            <label class="col-form-label col-md-3" for="o_link_dialog_url_input">URL or Email</label>
                            <div class="col-md-9">
                                <input type="text" name="url" class="form-control" id="o_link_dialog_url_input" required="required" t-ref="inputUrl"/>
                                <div class="form-check o_strip_domain d-none">
                                    <input type="checkbox" id="o_link_dialog_url_strip_domain" checked="checked" class="form-check-input"/>
                                    <label for="o_link_dialog_url_strip_domain" class="form-check-label fw-normal">
                                        Autoconvert to relative link
                                    </label>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3 row">
                            <label class="col-form-label col-md-3">Type</label>
                            <div class="col-md-9 d-flex align-items-center">
                                <div t-attf-class="#{this.colorCombinationClass ? ('p-2 ' + this.colorCombinationClass) : ''}">
                                    <t t-foreach="this.colorsData" t-as="colorData" t-key="colorData.type">
                                        <label role="button" class="m-0 me-2" t-if="colorData.type !== 'custom'">
                                            <input type="radio" name="link_style_color" class="d-none link-style" t-att-value="colorData.type"/>
                                            <span t-esc="colorData.label" t-attf-class="o_btn_preview btn btn-sm btn-#{colorData.btnPreview} #{colorData.type ? '' : 'px-0'}"/>
                                        </label>
                                    </t>
                                </div>
                            </div>
                        </div>
                        <div id="o_link_dialog_button_opts_collapse" class="collapse">
                            <div class="mb-3 row">
                                <label class="col-form-label col-md-3">Size</label>
                                <div class="col-md-9">
                                    <select name="link_style_size" class="form-select link-style">
                                        <option value="sm">Small</option>
                                        <option value="" selected="selected">Medium</option>
                                        <option value="lg">Large</option>
                                    </select>
                                </div>
                            </div>
                            <div class="mb-3 row">
                                <label class="col-form-label col-md-3">Style</label>
                                <div class="col-md-9">
                                    <select name="link_style_shape" class="form-select link-style">
                                        <option value="" selected="selected">Default</option>
                                        <option value="rounded-circle">Default + Rounded</option>
                                        <option value="outline">Outline</option>
                                        <option value="outline,rounded-circle">Outline + Rounded</option>
                                        <option value="fill">Fill</option>
                                        <option value="fill,rounded-circle">Fill + Rounded</option>
                                        <option value="flat">Flat</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="mb-3 row" t-if="!state.isButton and !props.forceNewWindow">
                            <div class="offset-md-3 col-md-9">
                                <label class="o_switch">
                                    <input type="checkbox" name="is_new_window" t-att-checked="this.initialNewWindow ? 'checked' : undefined"/>
                                    <span/>
                                    Open in new window
                                </label>
                            </div>
                        </div>
                    </form>
                    <div class="col-lg-4 o_link_dialog_preview">
                        <div class="mb-3 text-center">
                            <label>Preview</label>
                            <div t-attf-class="#{this.colorCombinationClass ? ('p-2 ' + this.colorCombinationClass) : ''}" style="overflow-x: auto; max-width: 100%; max-height: 200px;">
                                <a href="#" id="link-preview" aria-label="Preview" title="Preview"/>
                            </div>
                        </div>
                    </div>
                </div>
                <t t-set-slot="footer">
                    <button class="btn btn-primary" t-on-click="this.onSave">Insert</button>
                    <button class="btn btn-secondary" t-on-click="this.onDiscard">Discard</button>
                </t>
            </div>
        </Dialog>
    </div>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg.xml -->

    <we-customizeblock-option t-name="web_editor.LinkTools">
        <div style="display: contents" t-ref="linkComponentWrapper">
            <we-row id="url_row" t-attf-class="#{state.isButton ? ' d-none' : ''}">
                <we-input class="o_we_user_value_widget o_we_sublevel_1">
                    <we-title class="o_short_title"/>
                    <div class="o_url_input">
                        <input name="url" id="o_link_dialog_url_input" type="text" placeholder="Your URL"/>
                    </div>
                </we-input>
            </we-row>
            <we-row class="o_strip_domain d-none" t-attf-class="#{state.isButton ? ' d-none' : ''}">
                <we-button class="o_we_user_value_widget o_we_checkbox_wrapper o_we_sublevel_1 active">
                    <we-title class="o_long_title">Autoconvert to relative link</we-title>
                        <div class="o_switch">
                            <we-checkbox name="do_strip_domain"/>
                        </div>
                </we-button>
            </we-row>
            <we-row t-attf-class="o_we_sublevel_1 {{props.needLabel ? '' : 'd-none'}}">
                <we-title>Label</we-title>
                <we-input class="o_we_user_value_widget">
                    <div>
                        <input name="label" id="o_link_dialog_label_input" type="text"/>
                    </div>
                </we-input>
            </we-row>
            <we-row>
                <we-select class="o_we_user_value_widget o_we_sublevel_1">
                    <we-title>Style</we-title>
                    <div class="dropdown">
                        <button class="dropdown-toggle" data-bs-toggle="dropdown" tabindex="-1" aria-expanded="false">
                            <we-toggler title="Link Style"/>
                        </button>
                        <we-selection-items class="dropdown-menu" name="link_style_color">
                            <t t-foreach="this.colorsData" t-as="colorData" t-key="colorData.type">
                                <we-button class="dropdown-item" href="#" t-att-data-value="colorData.type">
                                    <t t-esc="colorData.label"/>
                                </we-button>
                            </t>
                        </we-selection-items>
                        <span class="o_we_dropdown_caret"/>
                    </div>
                </we-select>
            </we-row>
            <we-row class="link-custom-color link-custom-color-text" t-att-class="{'d-none': !state.showLinkCustomColor}">
                <we-select title="Color" class="o_we_user_value_widget o_we_so_color_palette o_we_sublevel_2">
                    <we-title>Text Color</we-title>
                    <div class="dropdown">
                        <span data-bs-toggle="dropdown" data-css-property="color" class="o_we_color_preview"/>
                        <we-selection-items class="dropdown-menu" name="link_text_color">
                            <ColorPalette selectedColor="colorpickerProps['color'].selectedColor" excluded="['transparent_grayscale']" document="this.props.wysiwyg.options.document" onSetColorNames="(colorNames) =&gt; this._onColorpaletteSetColorNames('color', colorNames)" onColorHover="(params) =&gt; this._colorpaletteApply('color', params)" onColorLeave="(params) =&gt; this._colorpaletteApply('color', params)" onColorPicked="(params) =&gt; this._onColorpaletteColorPicked('color', params)" onCustomColorPicked="(params) =&gt; this._onColorpaletteColorPicked('color', params)" getTemplate="this.props.getColorpickerTemplate"/>
                        </we-selection-items>
                    </div>
                </we-select>
            </we-row>
            <we-row class="link-custom-color link-custom-color-fill" t-att-class="{'d-none': !state.showLinkCustomColor}">
                <we-select title="Color" class="o_we_user_value_widget o_we_so_color_palette o_we_sublevel_2">
                    <we-title>Fill Color</we-title>
                    <div class="dropdown">
                        <span data-bs-toggle="dropdown" data-css-property="background-color" class="o_we_color_preview"/>
                        <we-selection-items class="dropdown-menu" name="link_fill_color">
                            <ColorPalette selectedColor="colorpickerProps['background-color'].selectedColor" excluded="['transparent_grayscale']" document="this.props.wysiwyg.options.document" withGradients="true" onSetColorNames="(colorNames) =&gt; this._onColorpaletteSetColorNames('background-color', colorNames)" onColorHover="(params) =&gt; this._colorpaletteApply('background-color', params)" onColorLeave="(params) =&gt; this._colorpaletteApply('background-color', params)" onColorPicked="(params) =&gt; this._onColorpaletteColorPicked('background-color', params)" onCustomColorPicked="(params) =&gt; this._onColorpaletteColorPicked('background-color', params)" getTemplate="this.props.getColorpickerTemplate"/>
                        </we-selection-items>
                    </div>
                </we-select>
            </we-row>
            <we-row class="link-custom-color link-custom-color-border o_we_sublevel_2" t-att-class="{'d-none': !state.showLinkCustomColor}">
                <we-title>Border</we-title>
                <div>
                    <we-input class="o_we_user_value_widget" title="Border Width">
                        <div class="o_custom_border_width_input">
                            <input name="custom_border_width" type="number" class="text-end" size="2"/>
                            <span>px</span>
                        </div>
                    </we-input>
                    <we-select class="o_we_user_value_widget" title="Border Style">
                        <div class="dropdown">
                            <button class="dropdown-toggle" data-bs-toggle="dropdown" title="" tabindex="-1" data-bs-original-title="Link Border Style" aria-expanded="false">
                                <we-toggler/>
                            </button>
                            <we-selection-items class="dropdown-menu" name="link_border_style">
                                <we-button title="Solid" class="dropdown-item" data-value="solid"><div class="o_we_fake_img_item o_we_border_preview" style="border-style: solid;"/></we-button>
                                <we-button title="Dashed" class="dropdown-item" data-value="dashed"><div class="o_we_fake_img_item o_we_border_preview" style="border-style: dashed;"/></we-button>
                                <we-button title="Dotted" class="dropdown-item" data-value="dotted"><div class="o_we_fake_img_item o_we_border_preview" style="border-style: dotted;"/></we-button>
                                <we-button title="Double" class="dropdown-item" data-value="double"><div class="o_we_fake_img_item o_we_border_preview" style="border-style: double; border-left: none; border-right: none;"/></we-button>
                            </we-selection-items>
                        </div>
                    </we-select>
                    <we-select title="Border Color" class="o_we_user_value_widget o_we_so_color_palette">
                        <div class="dropdown">
                            <span data-bs-toggle="dropdown" data-css-property="border-color" class="o_we_color_preview"/>
                            <we-selection-items class="dropdown-menu" name="link_border_color">
                                <ColorPalette selectedColor="colorpickerProps['border-color'].selectedColor" excluded="['transparent_grayscale']" document="this.props.wysiwyg.options.document" onSetColorNames="(colorNames) =&gt; this._onColorpaletteSetColorNames('border-color', colorNames)" onColorHover="(params) =&gt; this._colorpaletteApply('border-color', params)" onColorLeave="(params) =&gt; this._colorpaletteApply('border-color', params)" onColorPicked="(params) =&gt; this._onColorpaletteColorPicked('border-color', params)" onCustomColorPicked="(params) =&gt; this._onColorpaletteColorPicked('border-color', params)" getTemplate="this.props.getColorpickerTemplate"/>
                            </we-selection-items>
                        </div>
                    </we-select>
                </div>
            </we-row>
            <we-row class="link-size-row" t-att-class="{'d-none': !state.showLinkSizeRow}">
                <we-select class="o_we_user_value_widget o_we_sublevel_2">
                    <we-title>Size</we-title>
                    <div>
                        <div class="dropdown">
                            <button class="dropdown-toggle" data-bs-toggle="dropdown" title="" tabindex="-1" aria-expanded="false">
                                <we-toggler title="Link Size">
                                    Medium
                                </we-toggler>
                            </button>
                            <we-selection-items name="link_style_size" class="dropdown-menu link-style">
                                <we-button class="dropdown-item" href="#" data-value="sm">
                                    Small
                                </we-button>
                                <we-button class="dropdown-item active" href="#" data-value="">
                                    Medium
                                </we-button>
                                <we-button class="dropdown-item" href="#" data-value="lg">
                                    Large
                                </we-button>
                            </we-selection-items>
                            <span class="o_we_dropdown_caret"/>
                        </div>
                    </div>
                </we-select>
            </we-row>
            <we-row class="link-shape-row" t-att-class="{'d-none': !state.showLinkShapeRow}">
                <we-select class="o_we_user_value_widget o_we_sublevel_2">
                    <we-title>Shape</we-title>
                    <div>
                        <div class="dropdown">
                            <button class="dropdown-toggle" data-bs-toggle="dropdown" tabindex="-1" aria-expanded="false">
                                <we-toggler title="Link Shape">
                                    Default
                                </we-toggler>
                            </button>
                            <we-selection-items name="link_style_shape" class="dropdown-menu link-style">
                                <we-button class="dropdown-item active" data-value="">Default</we-button>
                                <we-button class="dropdown-item" data-value="rounded-circle">Default + Rounded</we-button>
                                <we-button class="dropdown-item" data-value="outline">Outline</we-button>
                                <we-button class="dropdown-item" data-value="outline,rounded-circle">Outline + Rounded</we-button>
                                <we-button class="dropdown-item" data-value="fill">Fill</we-button>
                                <we-button class="dropdown-item" data-value="fill,rounded-circle">Fill + Rounded</we-button>
                                <we-button class="dropdown-item" data-value="flat">Flat</we-button>
                            </we-selection-items>
                        </div>
                    </div>
                </we-select>
            </we-row>
            <we-row t-if="!state.isButton and !props.forceNewWindow">
                <we-button t-attf-class="o_we_user_value_widget o_we_checkbox_wrapper o_we_sublevel_1 #{this.initialNewWindow ? 'active' : ''}">
                    <we-title class="o_long_title">Open in new window</we-title>
                        <div class="o_switch">
                            <we-checkbox name="is_new_window" t-att-checked="this.initialNewWindow ? 'checked' : undefined"/>
                        </div>
                </we-button>
            </we-row>
        </div>
    </we-customizeblock-option>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg.xml -->


    <div t-name="web_editor.ImageCrop" class="o_we_crop_widget" contenteditable="false" t-att-class="this.state.active ? '' : 'd-none'" t-ref="el">
        <div class="o_we_cropper_wrapper">
            <img class="o_we_cropper_img"/>
            <div class="o_we_crop_buttons text-center mt16 position-fixed o_we_no_overlay" contenteditable="false">
                <div class="btn-group btn-group-toggle" title="Aspect Ratio" data-bs-toggle="buttons">
                    <t t-foreach="this.aspectRatios" t-as="ratio" t-key="ratio">
                        <t t-set="is_active" t-value="ratio === this.aspectRatio"/>
                        <label t-attf-class="btn #{is_active and 'active' or ''}" data-action="ratio" t-att-data-value="ratio">
                            <input type="radio"/><t t-esc="ratio_value.label"/>
                        </label>
                    </t>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" title="Zoom In" data-action="zoom" data-value="0.1"><i class="fa fa-fw fa-search-plus"/></button>
                    <button type="button" title="Zoom Out" data-action="zoom" data-value="-0.1"><i class="fa fa-fw fa-search-minus"/></button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" title="Rotate Left" data-action="rotate" data-value="-90"><i class="fa fa-fw fa-rotate-left"/></button>
                    <button type="button" title="Rotate Right" data-action="rotate" data-value="90"><i class="fa fa-fw fa-rotate-right"/></button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" title="Flip Horizontal" data-action="flip" data-scale-direction="scaleX"><i class="oi oi-fw oi-arrows-h"/></button>
                    <button type="button" title="Flip Vertical" data-action="flip" data-scale-direction="scaleY"><i class="oi oi-fw oi-arrows-v"/></button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" title="Reset Image" data-action="reset"><i class="fa fa-refresh"/> Reset Image</button>
                </div>
                <div class="btn-group" role="group">
                    <button type="button" title="Apply" data-action="apply" class="btn btn-primary"><i class="fa fa-check"/> Apply</button>
                    <button type="button" title="Discard" data-action="discard" class="btn btn-danger"><i class="fa fa-times"/> Discard</button>
                </div>
            </div>
        </div>
    </div>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg_colorpicker.xml -->

<t t-name="wysiwyg.plugin.font.paletteButton">
        <div t-attf-class="note-btn-group btn-group {{className}}">
            <button type="button" class="note-btn btn btn-light btn-sm dropdown-toggle" tabindex="-1" data-bs-toggle="dropdown"><i t-att-class="icon"/></button>
            <div class="dropdown-menu"/>
        </div>
    </t>

<!-- Filepath: /web_editor/static/src/xml/wysiwyg_colorpicker.xml -->

    <t t-name="wysiwyg.plugin.font.colorPalette">
        <div class="note-palette">
            <button type="button" class="note-color-reset btn btn-light note-color-btn bg-undefined">
                <t t-esc="lang.color.resetToDefault"/></button>
            <div class="note-holder">
                <div class="note-color-palette">
                    <h6 class="mt-2">Theme colors</h6>
                    <div class="o_theme_color_placeholder"/>
                    <h6 class="mt-2">Transparent colors</h6>
                    <div class="o_transparent_color_placeholder"/>
                    <h6 class="mt-2">Common colors</h6>
                    <div class="o_common_color_placeholder">
                        <div class="note-color-row" t-foreach="colors" t-as="rowColors" t-key="rowColors_index">
                            <button t-foreach="rowColors" t-as="color" t-key="color_index" type="button" class="note-color-btn" data-bs-toggle="button" tabindex="-1" t-attf-style="background-color:{{color}}" t-att-data-value="color" t-att-title="color"/>
                        </div>
                    </div>
                </div>
                <h6 class="note-custom-color mt8">
                    <t t-esc="lang.color.customColor"/>
                </h6>
                <button class="note-custom-color-btn note-color-btn" style="display: none;"/>
            </div>
        </div>
    </t>

</templates>`);
                    });

//# sourceMappingURL=/web/assets/ed71fc4/web_editor.backend_assets_wysiwyg.js.map